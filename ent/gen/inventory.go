// Code generated by ent, DO NOT EDIT.

package gen

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/heshaofeng1991/entgo/ent/gen/inventory"
	"github.com/heshaofeng1991/entgo/ent/gen/product"
	"github.com/heshaofeng1991/entgo/ent/gen/tenant"
)

// Inventory is the model entity for the Inventory schema.
type Inventory struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt time.Time `json:"deleted_at,omitempty"`
	// ProductID holds the value of the "product_id" field.
	ProductID int64 `json:"product_id,omitempty"`
	// WarehouseID holds the value of the "warehouse_id" field.
	WarehouseID int64 `json:"warehouse_id,omitempty"`
	// 总数量=可用数量+准备发货数量+准备上架数量
	StorageQty int32 `json:"storage_qty,omitempty"`
	// 可用数量
	AvailableQty int32 `json:"available_qty,omitempty"`
	// 准备发货数量
	PrepareShipQty int32 `json:"prepare_ship_qty,omitempty"`
	// 准备上架数量
	PrepareShelveQty int32 `json:"prepare_shelve_qty,omitempty"`
	// 快仓总数量=可用数量+准备下架数量+准备上架数量
	QuicktronStorageQty int32 `json:"quicktron_storage_qty,omitempty"`
	// 快仓可用数量
	QuicktronAvailableQty int32 `json:"quicktron_available_qty,omitempty"`
	// 快仓准备下架数量
	QuicktronPrepareOutboundQty int32 `json:"quicktron_prepare_outbound_qty,omitempty"`
	// 快仓准备上架数量
	QuicktronPrepareShelveQty int32 `json:"quicktron_prepare_shelve_qty,omitempty"`
	// 传统区域总数量=可用数量+准备下架数量+准备上架数量
	NormalStorageQty int32 `json:"normal_storage_qty,omitempty"`
	// 传统区域可用数量
	NormalAvailableQty int32 `json:"normal_available_qty,omitempty"`
	// 传统区域准备下架数量
	NormalPrepareOutboundQty int32 `json:"normal_prepare_outbound_qty,omitempty"`
	// 传统区域准备上架数量
	NormalPrepareShelveQty int32 `json:"normal_prepare_shelve_qty,omitempty"`
	// Status holds the value of the "status" field.
	Status int8 `json:"status,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the InventoryQuery when eager-loading is set.
	Edges            InventoryEdges `json:"edges"`
	inventory_tenant *int64
}

// InventoryEdges holds the relations/edges for other nodes in the graph.
type InventoryEdges struct {
	// Tenant holds the value of the tenant edge.
	Tenant *Tenant `json:"tenant,omitempty"`
	// Products holds the value of the products edge.
	Products *Product `json:"products,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// TenantOrErr returns the Tenant value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e InventoryEdges) TenantOrErr() (*Tenant, error) {
	if e.loadedTypes[0] {
		if e.Tenant == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: tenant.Label}
		}
		return e.Tenant, nil
	}
	return nil, &NotLoadedError{edge: "tenant"}
}

// ProductsOrErr returns the Products value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e InventoryEdges) ProductsOrErr() (*Product, error) {
	if e.loadedTypes[1] {
		if e.Products == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: product.Label}
		}
		return e.Products, nil
	}
	return nil, &NotLoadedError{edge: "products"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Inventory) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case inventory.FieldID, inventory.FieldProductID, inventory.FieldWarehouseID, inventory.FieldStorageQty, inventory.FieldAvailableQty, inventory.FieldPrepareShipQty, inventory.FieldPrepareShelveQty, inventory.FieldQuicktronStorageQty, inventory.FieldQuicktronAvailableQty, inventory.FieldQuicktronPrepareOutboundQty, inventory.FieldQuicktronPrepareShelveQty, inventory.FieldNormalStorageQty, inventory.FieldNormalAvailableQty, inventory.FieldNormalPrepareOutboundQty, inventory.FieldNormalPrepareShelveQty, inventory.FieldStatus:
			values[i] = new(sql.NullInt64)
		case inventory.FieldCreatedAt, inventory.FieldUpdatedAt, inventory.FieldDeletedAt:
			values[i] = new(sql.NullTime)
		case inventory.ForeignKeys[0]: // inventory_tenant
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Inventory", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Inventory fields.
func (i *Inventory) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for j := range columns {
		switch columns[j] {
		case inventory.FieldID:
			value, ok := values[j].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			i.ID = int64(value.Int64)
		case inventory.FieldCreatedAt:
			if value, ok := values[j].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[j])
			} else if value.Valid {
				i.CreatedAt = value.Time
			}
		case inventory.FieldUpdatedAt:
			if value, ok := values[j].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[j])
			} else if value.Valid {
				i.UpdatedAt = value.Time
			}
		case inventory.FieldDeletedAt:
			if value, ok := values[j].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[j])
			} else if value.Valid {
				i.DeletedAt = value.Time
			}
		case inventory.FieldProductID:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field product_id", values[j])
			} else if value.Valid {
				i.ProductID = value.Int64
			}
		case inventory.FieldWarehouseID:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field warehouse_id", values[j])
			} else if value.Valid {
				i.WarehouseID = value.Int64
			}
		case inventory.FieldStorageQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field storage_qty", values[j])
			} else if value.Valid {
				i.StorageQty = int32(value.Int64)
			}
		case inventory.FieldAvailableQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field available_qty", values[j])
			} else if value.Valid {
				i.AvailableQty = int32(value.Int64)
			}
		case inventory.FieldPrepareShipQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field prepare_ship_qty", values[j])
			} else if value.Valid {
				i.PrepareShipQty = int32(value.Int64)
			}
		case inventory.FieldPrepareShelveQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field prepare_shelve_qty", values[j])
			} else if value.Valid {
				i.PrepareShelveQty = int32(value.Int64)
			}
		case inventory.FieldQuicktronStorageQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field quicktron_storage_qty", values[j])
			} else if value.Valid {
				i.QuicktronStorageQty = int32(value.Int64)
			}
		case inventory.FieldQuicktronAvailableQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field quicktron_available_qty", values[j])
			} else if value.Valid {
				i.QuicktronAvailableQty = int32(value.Int64)
			}
		case inventory.FieldQuicktronPrepareOutboundQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field quicktron_prepare_outbound_qty", values[j])
			} else if value.Valid {
				i.QuicktronPrepareOutboundQty = int32(value.Int64)
			}
		case inventory.FieldQuicktronPrepareShelveQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field quicktron_prepare_shelve_qty", values[j])
			} else if value.Valid {
				i.QuicktronPrepareShelveQty = int32(value.Int64)
			}
		case inventory.FieldNormalStorageQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field normal_storage_qty", values[j])
			} else if value.Valid {
				i.NormalStorageQty = int32(value.Int64)
			}
		case inventory.FieldNormalAvailableQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field normal_available_qty", values[j])
			} else if value.Valid {
				i.NormalAvailableQty = int32(value.Int64)
			}
		case inventory.FieldNormalPrepareOutboundQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field normal_prepare_outbound_qty", values[j])
			} else if value.Valid {
				i.NormalPrepareOutboundQty = int32(value.Int64)
			}
		case inventory.FieldNormalPrepareShelveQty:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field normal_prepare_shelve_qty", values[j])
			} else if value.Valid {
				i.NormalPrepareShelveQty = int32(value.Int64)
			}
		case inventory.FieldStatus:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[j])
			} else if value.Valid {
				i.Status = int8(value.Int64)
			}
		case inventory.ForeignKeys[0]:
			if value, ok := values[j].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field inventory_tenant", value)
			} else if value.Valid {
				i.inventory_tenant = new(int64)
				*i.inventory_tenant = int64(value.Int64)
			}
		}
	}
	return nil
}

// QueryTenant queries the "tenant" edge of the Inventory entity.
func (i *Inventory) QueryTenant() *TenantQuery {
	return (&InventoryClient{config: i.config}).QueryTenant(i)
}

// QueryProducts queries the "products" edge of the Inventory entity.
func (i *Inventory) QueryProducts() *ProductQuery {
	return (&InventoryClient{config: i.config}).QueryProducts(i)
}

// Update returns a builder for updating this Inventory.
// Note that you need to call Inventory.Unwrap() before calling this method if this Inventory
// was returned from a transaction, and the transaction was committed or rolled back.
func (i *Inventory) Update() *InventoryUpdateOne {
	return (&InventoryClient{config: i.config}).UpdateOne(i)
}

// Unwrap unwraps the Inventory entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (i *Inventory) Unwrap() *Inventory {
	_tx, ok := i.config.driver.(*txDriver)
	if !ok {
		panic("gen: Inventory is not a transactional entity")
	}
	i.config.driver = _tx.drv
	return i
}

// String implements the fmt.Stringer.
func (i *Inventory) String() string {
	var builder strings.Builder
	builder.WriteString("Inventory(")
	builder.WriteString(fmt.Sprintf("id=%v, ", i.ID))
	builder.WriteString("created_at=")
	builder.WriteString(i.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(i.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(i.DeletedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("product_id=")
	builder.WriteString(fmt.Sprintf("%v", i.ProductID))
	builder.WriteString(", ")
	builder.WriteString("warehouse_id=")
	builder.WriteString(fmt.Sprintf("%v", i.WarehouseID))
	builder.WriteString(", ")
	builder.WriteString("storage_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.StorageQty))
	builder.WriteString(", ")
	builder.WriteString("available_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.AvailableQty))
	builder.WriteString(", ")
	builder.WriteString("prepare_ship_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.PrepareShipQty))
	builder.WriteString(", ")
	builder.WriteString("prepare_shelve_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.PrepareShelveQty))
	builder.WriteString(", ")
	builder.WriteString("quicktron_storage_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.QuicktronStorageQty))
	builder.WriteString(", ")
	builder.WriteString("quicktron_available_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.QuicktronAvailableQty))
	builder.WriteString(", ")
	builder.WriteString("quicktron_prepare_outbound_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.QuicktronPrepareOutboundQty))
	builder.WriteString(", ")
	builder.WriteString("quicktron_prepare_shelve_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.QuicktronPrepareShelveQty))
	builder.WriteString(", ")
	builder.WriteString("normal_storage_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.NormalStorageQty))
	builder.WriteString(", ")
	builder.WriteString("normal_available_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.NormalAvailableQty))
	builder.WriteString(", ")
	builder.WriteString("normal_prepare_outbound_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.NormalPrepareOutboundQty))
	builder.WriteString(", ")
	builder.WriteString("normal_prepare_shelve_qty=")
	builder.WriteString(fmt.Sprintf("%v", i.NormalPrepareShelveQty))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", i.Status))
	builder.WriteByte(')')
	return builder.String()
}

// Inventories is a parsable slice of Inventory.
type Inventories []*Inventory

func (i Inventories) config(cfg config) {
	for _i := range i {
		i[_i].config = cfg
	}
}
