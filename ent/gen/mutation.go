// Code generated by ent, DO NOT EDIT.

package gen

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/heshaofeng1991/entgo/ent/gen/announcements"
	"github.com/heshaofeng1991/entgo/ent/gen/attribute"
	"github.com/heshaofeng1991/entgo/ent/gen/channel"
	"github.com/heshaofeng1991/entgo/ent/gen/channelcost"
	"github.com/heshaofeng1991/entgo/ent/gen/channelcostbatche"
	"github.com/heshaofeng1991/entgo/ent/gen/channeloption"
	"github.com/heshaofeng1991/entgo/ent/gen/channelrecommend"
	"github.com/heshaofeng1991/entgo/ent/gen/channelvolumefactor"
	"github.com/heshaofeng1991/entgo/ent/gen/country"
	"github.com/heshaofeng1991/entgo/ent/gen/countryzone"
	"github.com/heshaofeng1991/entgo/ent/gen/courierorder"
	"github.com/heshaofeng1991/entgo/ent/gen/customerconfig"
	"github.com/heshaofeng1991/entgo/ent/gen/inbound"
	"github.com/heshaofeng1991/entgo/ent/gen/inbounditem"
	"github.com/heshaofeng1991/entgo/ent/gen/inventory"
	"github.com/heshaofeng1991/entgo/ent/gen/order"
	"github.com/heshaofeng1991/entgo/ent/gen/orderholdreason"
	"github.com/heshaofeng1991/entgo/ent/gen/orderitem"
	"github.com/heshaofeng1991/entgo/ent/gen/ordertaxation"
	"github.com/heshaofeng1991/entgo/ent/gen/pickuporder"
	"github.com/heshaofeng1991/entgo/ent/gen/pickuporderitem"
	"github.com/heshaofeng1991/entgo/ent/gen/platformproduct"
	"github.com/heshaofeng1991/entgo/ent/gen/predicate"
	"github.com/heshaofeng1991/entgo/ent/gen/product"
	"github.com/heshaofeng1991/entgo/ent/gen/productmapping"
	"github.com/heshaofeng1991/entgo/ent/gen/sequence"
	"github.com/heshaofeng1991/entgo/ent/gen/store"
	"github.com/heshaofeng1991/entgo/ent/gen/taskschedule"
	"github.com/heshaofeng1991/entgo/ent/gen/tenant"
	"github.com/heshaofeng1991/entgo/ent/gen/token"
	"github.com/heshaofeng1991/entgo/ent/gen/trackmapping"
	"github.com/heshaofeng1991/entgo/ent/gen/transaction"
	"github.com/heshaofeng1991/entgo/ent/gen/transactiondetail"
	"github.com/heshaofeng1991/entgo/ent/gen/user"
	"github.com/heshaofeng1991/entgo/ent/gen/userreferral"
	"github.com/heshaofeng1991/entgo/ent/gen/valueaddedtax"
	"github.com/heshaofeng1991/entgo/ent/gen/warehouse"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnouncements       = "Announcements"
	TypeAttribute           = "Attribute"
	TypeChannel             = "Channel"
	TypeChannelCost         = "ChannelCost"
	TypeChannelCostBatche   = "ChannelCostBatche"
	TypeChannelOption       = "ChannelOption"
	TypeChannelRecommend    = "ChannelRecommend"
	TypeChannelVolumeFactor = "ChannelVolumeFactor"
	TypeCountry             = "Country"
	TypeCountryZone         = "CountryZone"
	TypeCourierOrder        = "CourierOrder"
	TypeCustomerConfig      = "CustomerConfig"
	TypeInbound             = "Inbound"
	TypeInboundItem         = "InboundItem"
	TypeInventory           = "Inventory"
	TypeOrder               = "Order"
	TypeOrderHoldReason     = "OrderHoldReason"
	TypeOrderItem           = "OrderItem"
	TypeOrderTaxation       = "OrderTaxation"
	TypePickupOrder         = "PickupOrder"
	TypePickupOrderItem     = "PickupOrderItem"
	TypePlatformProduct     = "PlatformProduct"
	TypeProduct             = "Product"
	TypeProductMapping      = "ProductMapping"
	TypeSequence            = "Sequence"
	TypeStore               = "Store"
	TypeTaskSchedule        = "TaskSchedule"
	TypeTenant              = "Tenant"
	TypeToken               = "Token"
	TypeTrackMapping        = "TrackMapping"
	TypeTransaction         = "Transaction"
	TypeTransactionDetail   = "TransactionDetail"
	TypeUser                = "User"
	TypeUserReferral        = "UserReferral"
	TypeValueAddedTax       = "ValueAddedTax"
	TypeWarehouse           = "Warehouse"
)

// AnnouncementsMutation represents an operation that mutates the Announcements nodes in the graph.
type AnnouncementsMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	title          *string
	content        *string
	status         *int
	addstatus      *int
	index          *int
	addindex       *int
	expiration     *time.Time
	effective_time *time.Time
	clearedFields  map[string]struct{}
	users          *int64
	clearedusers   bool
	done           bool
	oldValue       func(context.Context) (*Announcements, error)
	predicates     []predicate.Announcements
}

var _ ent.Mutation = (*AnnouncementsMutation)(nil)

// announcementsOption allows management of the mutation configuration using functional options.
type announcementsOption func(*AnnouncementsMutation)

// newAnnouncementsMutation creates new mutation for the Announcements entity.
func newAnnouncementsMutation(c config, op Op, opts ...announcementsOption) *AnnouncementsMutation {
	m := &AnnouncementsMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnouncements,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnouncementsID sets the ID field of the mutation.
func withAnnouncementsID(id int64) announcementsOption {
	return func(m *AnnouncementsMutation) {
		var (
			err   error
			once  sync.Once
			value *Announcements
		)
		m.oldValue = func(ctx context.Context) (*Announcements, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Announcements.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnouncements sets the old Announcements of the mutation.
func withAnnouncements(node *Announcements) announcementsOption {
	return func(m *AnnouncementsMutation) {
		m.oldValue = func(context.Context) (*Announcements, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnouncementsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnouncementsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Announcements entities.
func (m *AnnouncementsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnouncementsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnouncementsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Announcements.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AnnouncementsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnnouncementsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnnouncementsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AnnouncementsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AnnouncementsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AnnouncementsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AnnouncementsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AnnouncementsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AnnouncementsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[announcements.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AnnouncementsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[announcements.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AnnouncementsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, announcements.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *AnnouncementsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AnnouncementsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AnnouncementsMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *AnnouncementsMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AnnouncementsMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AnnouncementsMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *AnnouncementsMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AnnouncementsMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AnnouncementsMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AnnouncementsMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AnnouncementsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetIndex sets the "index" field.
func (m *AnnouncementsMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *AnnouncementsMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *AnnouncementsMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *AnnouncementsMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *AnnouncementsMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetCreateBy sets the "create_by" field.
func (m *AnnouncementsMutation) SetCreateBy(i int64) {
	m.users = &i
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *AnnouncementsMutation) CreateBy() (r int64, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldCreateBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *AnnouncementsMutation) ClearCreateBy() {
	m.users = nil
	m.clearedFields[announcements.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *AnnouncementsMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[announcements.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *AnnouncementsMutation) ResetCreateBy() {
	m.users = nil
	delete(m.clearedFields, announcements.FieldCreateBy)
}

// SetExpiration sets the "expiration" field.
func (m *AnnouncementsMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *AnnouncementsMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldExpiration(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *AnnouncementsMutation) ResetExpiration() {
	m.expiration = nil
}

// SetEffectiveTime sets the "effective_time" field.
func (m *AnnouncementsMutation) SetEffectiveTime(t time.Time) {
	m.effective_time = &t
}

// EffectiveTime returns the value of the "effective_time" field in the mutation.
func (m *AnnouncementsMutation) EffectiveTime() (r time.Time, exists bool) {
	v := m.effective_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveTime returns the old "effective_time" field's value of the Announcements entity.
// If the Announcements object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementsMutation) OldEffectiveTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveTime: %w", err)
	}
	return oldValue.EffectiveTime, nil
}

// ResetEffectiveTime resets all changes to the "effective_time" field.
func (m *AnnouncementsMutation) ResetEffectiveTime() {
	m.effective_time = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *AnnouncementsMutation) SetUsersID(id int64) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *AnnouncementsMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *AnnouncementsMutation) UsersCleared() bool {
	return m.CreateByCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *AnnouncementsMutation) UsersID() (id int64, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *AnnouncementsMutation) UsersIDs() (ids []int64) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AnnouncementsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the AnnouncementsMutation builder.
func (m *AnnouncementsMutation) Where(ps ...predicate.Announcements) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AnnouncementsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Announcements).
func (m *AnnouncementsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnouncementsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, announcements.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, announcements.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, announcements.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, announcements.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, announcements.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, announcements.FieldStatus)
	}
	if m.index != nil {
		fields = append(fields, announcements.FieldIndex)
	}
	if m.users != nil {
		fields = append(fields, announcements.FieldCreateBy)
	}
	if m.expiration != nil {
		fields = append(fields, announcements.FieldExpiration)
	}
	if m.effective_time != nil {
		fields = append(fields, announcements.FieldEffectiveTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnouncementsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announcements.FieldCreatedAt:
		return m.CreatedAt()
	case announcements.FieldUpdatedAt:
		return m.UpdatedAt()
	case announcements.FieldDeletedAt:
		return m.DeletedAt()
	case announcements.FieldTitle:
		return m.Title()
	case announcements.FieldContent:
		return m.Content()
	case announcements.FieldStatus:
		return m.Status()
	case announcements.FieldIndex:
		return m.Index()
	case announcements.FieldCreateBy:
		return m.CreateBy()
	case announcements.FieldExpiration:
		return m.Expiration()
	case announcements.FieldEffectiveTime:
		return m.EffectiveTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnouncementsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announcements.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case announcements.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case announcements.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case announcements.FieldTitle:
		return m.OldTitle(ctx)
	case announcements.FieldContent:
		return m.OldContent(ctx)
	case announcements.FieldStatus:
		return m.OldStatus(ctx)
	case announcements.FieldIndex:
		return m.OldIndex(ctx)
	case announcements.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case announcements.FieldExpiration:
		return m.OldExpiration(ctx)
	case announcements.FieldEffectiveTime:
		return m.OldEffectiveTime(ctx)
	}
	return nil, fmt.Errorf("unknown Announcements field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announcements.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case announcements.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case announcements.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case announcements.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case announcements.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case announcements.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case announcements.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case announcements.FieldCreateBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case announcements.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case announcements.FieldEffectiveTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveTime(v)
		return nil
	}
	return fmt.Errorf("unknown Announcements field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnouncementsMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, announcements.FieldStatus)
	}
	if m.addindex != nil {
		fields = append(fields, announcements.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnouncementsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case announcements.FieldStatus:
		return m.AddedStatus()
	case announcements.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case announcements.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case announcements.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Announcements numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnouncementsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(announcements.FieldDeletedAt) {
		fields = append(fields, announcements.FieldDeletedAt)
	}
	if m.FieldCleared(announcements.FieldCreateBy) {
		fields = append(fields, announcements.FieldCreateBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnouncementsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnouncementsMutation) ClearField(name string) error {
	switch name {
	case announcements.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case announcements.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	}
	return fmt.Errorf("unknown Announcements nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnouncementsMutation) ResetField(name string) error {
	switch name {
	case announcements.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case announcements.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case announcements.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case announcements.FieldTitle:
		m.ResetTitle()
		return nil
	case announcements.FieldContent:
		m.ResetContent()
		return nil
	case announcements.FieldStatus:
		m.ResetStatus()
		return nil
	case announcements.FieldIndex:
		m.ResetIndex()
		return nil
	case announcements.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case announcements.FieldExpiration:
		m.ResetExpiration()
		return nil
	case announcements.FieldEffectiveTime:
		m.ResetEffectiveTime()
		return nil
	}
	return fmt.Errorf("unknown Announcements field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnouncementsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, announcements.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnouncementsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case announcements.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnouncementsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnouncementsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnouncementsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, announcements.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnouncementsMutation) EdgeCleared(name string) bool {
	switch name {
	case announcements.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnouncementsMutation) ClearEdge(name string) error {
	switch name {
	case announcements.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Announcements unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnouncementsMutation) ResetEdge(name string) error {
	switch name {
	case announcements.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Announcements edge %s", name)
}

// AttributeMutation represents an operation that mutates the Attribute nodes in the graph.
type AttributeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	_type         *int8
	add_type      *int8
	value         *string
	description   *string
	status        *int8
	addstatus     *int8
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Attribute, error)
	predicates    []predicate.Attribute
}

var _ ent.Mutation = (*AttributeMutation)(nil)

// attributeOption allows management of the mutation configuration using functional options.
type attributeOption func(*AttributeMutation)

// newAttributeMutation creates new mutation for the Attribute entity.
func newAttributeMutation(c config, op Op, opts ...attributeOption) *AttributeMutation {
	m := &AttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeID sets the ID field of the mutation.
func withAttributeID(id int64) attributeOption {
	return func(m *AttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *Attribute
		)
		m.oldValue = func(ctx context.Context) (*Attribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttribute sets the old Attribute of the mutation.
func withAttribute(node *Attribute) attributeOption {
	return func(m *AttributeMutation) {
		m.oldValue = func(context.Context) (*Attribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attribute entities.
func (m *AttributeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *AttributeMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *AttributeMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *AttributeMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *AttributeMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *AttributeMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetValue sets the "value" field.
func (m *AttributeMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *AttributeMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AttributeMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *AttributeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AttributeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AttributeMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *AttributeMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AttributeMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *AttributeMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AttributeMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AttributeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AttributeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttributeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttributeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttributeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttributeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttributeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttributeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttributeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttributeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attribute.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttributeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attribute.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttributeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attribute.FieldDeletedAt)
}

// Where appends a list predicates to the AttributeMutation builder.
func (m *AttributeMutation) Where(ps ...predicate.Attribute) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttributeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attribute).
func (m *AttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, attribute.FieldType)
	}
	if m.value != nil {
		fields = append(fields, attribute.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, attribute.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, attribute.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, attribute.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attribute.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attribute.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldType:
		return m.GetType()
	case attribute.FieldValue:
		return m.Value()
	case attribute.FieldDescription:
		return m.Description()
	case attribute.FieldStatus:
		return m.Status()
	case attribute.FieldCreatedAt:
		return m.CreatedAt()
	case attribute.FieldUpdatedAt:
		return m.UpdatedAt()
	case attribute.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attribute.FieldType:
		return m.OldType(ctx)
	case attribute.FieldValue:
		return m.OldValue(ctx)
	case attribute.FieldDescription:
		return m.OldDescription(ctx)
	case attribute.FieldStatus:
		return m.OldStatus(ctx)
	case attribute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attribute.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attribute.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Attribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case attribute.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case attribute.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case attribute.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case attribute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attribute.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attribute.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, attribute.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, attribute.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldType:
		return m.AddedType()
	case attribute.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case attribute.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attribute.FieldDeletedAt) {
		fields = append(fields, attribute.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeMutation) ClearField(name string) error {
	switch name {
	case attribute.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Attribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeMutation) ResetField(name string) error {
	switch name {
	case attribute.FieldType:
		m.ResetType()
		return nil
	case attribute.FieldValue:
		m.ResetValue()
		return nil
	case attribute.FieldDescription:
		m.ResetDescription()
		return nil
	case attribute.FieldStatus:
		m.ResetStatus()
		return nil
	case attribute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attribute.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attribute.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Attribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Attribute edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	warehouse_id           *int64
	addwarehouse_id        *int64
	courier_platform       *string
	name                   *string
	code                   *string
	_type                  *int8
	add_type               *int8
	quotation_currency     *string
	volume_factor          *int32
	addvolume_factor       *int32
	en_name                *string
	display_name           *string
	has_tracking_number    *int8
	addhas_tracking_number *int8
	min_normal_days        *int32
	addmin_normal_days     *int32
	max_normal_days        *int32
	addmax_normal_days     *int32
	max_weight             *int
	addmax_weight          *int
	max_length             *int
	addmax_length          *int
	min_length             *int
	addmin_length          *int
	max_three_side_sum     *int
	addmax_three_side_sum  *int
	description            *string
	sorting_port           *int32
	addsorting_port        *int32
	prepay_tariff          *bool
	status                 *int8
	addstatus              *int8
	test                   *bool
	options                *string
	exclude_attributes     *string
	battery                *int8
	addbattery             *int8
	virtual                *int8
	addvirtual             *int8
	channel_type           *int8
	addchannel_type        *int8
	deliver_duty           *string
	special                *int8
	addspecial             *int8
	clearedFields          map[string]struct{}
	channel_costs          map[int64]struct{}
	removedchannel_costs   map[int64]struct{}
	clearedchannel_costs   bool
	orders                 map[int64]struct{}
	removedorders          map[int64]struct{}
	clearedorders          bool
	done                   bool
	oldValue               func(context.Context) (*Channel, error)
	predicates             []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int64) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Channel entities.
func (m *ChannelMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channel.FieldDeletedAt)
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *ChannelMutation) SetWarehouseID(i int64) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *ChannelMutation) WarehouseID() (r int64, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldWarehouseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *ChannelMutation) AddWarehouseID(i int64) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *ChannelMutation) AddedWarehouseID() (r int64, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *ChannelMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
}

// SetCourierPlatform sets the "courier_platform" field.
func (m *ChannelMutation) SetCourierPlatform(s string) {
	m.courier_platform = &s
}

// CourierPlatform returns the value of the "courier_platform" field in the mutation.
func (m *ChannelMutation) CourierPlatform() (r string, exists bool) {
	v := m.courier_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierPlatform returns the old "courier_platform" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCourierPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourierPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourierPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierPlatform: %w", err)
	}
	return oldValue.CourierPlatform, nil
}

// ResetCourierPlatform resets all changes to the "courier_platform" field.
func (m *ChannelMutation) ResetCourierPlatform() {
	m.courier_platform = nil
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *ChannelMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ChannelMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ChannelMutation) ResetCode() {
	m.code = nil
}

// SetType sets the "type" field.
func (m *ChannelMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChannelMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *ChannelMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *ChannelMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *ChannelMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetQuotationCurrency sets the "quotation_currency" field.
func (m *ChannelMutation) SetQuotationCurrency(s string) {
	m.quotation_currency = &s
}

// QuotationCurrency returns the value of the "quotation_currency" field in the mutation.
func (m *ChannelMutation) QuotationCurrency() (r string, exists bool) {
	v := m.quotation_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotationCurrency returns the old "quotation_currency" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldQuotationCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotationCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotationCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotationCurrency: %w", err)
	}
	return oldValue.QuotationCurrency, nil
}

// ResetQuotationCurrency resets all changes to the "quotation_currency" field.
func (m *ChannelMutation) ResetQuotationCurrency() {
	m.quotation_currency = nil
}

// SetVolumeFactor sets the "volume_factor" field.
func (m *ChannelMutation) SetVolumeFactor(i int32) {
	m.volume_factor = &i
	m.addvolume_factor = nil
}

// VolumeFactor returns the value of the "volume_factor" field in the mutation.
func (m *ChannelMutation) VolumeFactor() (r int32, exists bool) {
	v := m.volume_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeFactor returns the old "volume_factor" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldVolumeFactor(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeFactor: %w", err)
	}
	return oldValue.VolumeFactor, nil
}

// AddVolumeFactor adds i to the "volume_factor" field.
func (m *ChannelMutation) AddVolumeFactor(i int32) {
	if m.addvolume_factor != nil {
		*m.addvolume_factor += i
	} else {
		m.addvolume_factor = &i
	}
}

// AddedVolumeFactor returns the value that was added to the "volume_factor" field in this mutation.
func (m *ChannelMutation) AddedVolumeFactor() (r int32, exists bool) {
	v := m.addvolume_factor
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolumeFactor resets all changes to the "volume_factor" field.
func (m *ChannelMutation) ResetVolumeFactor() {
	m.volume_factor = nil
	m.addvolume_factor = nil
}

// SetEnName sets the "en_name" field.
func (m *ChannelMutation) SetEnName(s string) {
	m.en_name = &s
}

// EnName returns the value of the "en_name" field in the mutation.
func (m *ChannelMutation) EnName() (r string, exists bool) {
	v := m.en_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEnName returns the old "en_name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldEnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnName: %w", err)
	}
	return oldValue.EnName, nil
}

// ResetEnName resets all changes to the "en_name" field.
func (m *ChannelMutation) ResetEnName() {
	m.en_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ChannelMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ChannelMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ChannelMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetHasTrackingNumber sets the "has_tracking_number" field.
func (m *ChannelMutation) SetHasTrackingNumber(i int8) {
	m.has_tracking_number = &i
	m.addhas_tracking_number = nil
}

// HasTrackingNumber returns the value of the "has_tracking_number" field in the mutation.
func (m *ChannelMutation) HasTrackingNumber() (r int8, exists bool) {
	v := m.has_tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTrackingNumber returns the old "has_tracking_number" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldHasTrackingNumber(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTrackingNumber: %w", err)
	}
	return oldValue.HasTrackingNumber, nil
}

// AddHasTrackingNumber adds i to the "has_tracking_number" field.
func (m *ChannelMutation) AddHasTrackingNumber(i int8) {
	if m.addhas_tracking_number != nil {
		*m.addhas_tracking_number += i
	} else {
		m.addhas_tracking_number = &i
	}
}

// AddedHasTrackingNumber returns the value that was added to the "has_tracking_number" field in this mutation.
func (m *ChannelMutation) AddedHasTrackingNumber() (r int8, exists bool) {
	v := m.addhas_tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetHasTrackingNumber resets all changes to the "has_tracking_number" field.
func (m *ChannelMutation) ResetHasTrackingNumber() {
	m.has_tracking_number = nil
	m.addhas_tracking_number = nil
}

// SetMinNormalDays sets the "min_normal_days" field.
func (m *ChannelMutation) SetMinNormalDays(i int32) {
	m.min_normal_days = &i
	m.addmin_normal_days = nil
}

// MinNormalDays returns the value of the "min_normal_days" field in the mutation.
func (m *ChannelMutation) MinNormalDays() (r int32, exists bool) {
	v := m.min_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// OldMinNormalDays returns the old "min_normal_days" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldMinNormalDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinNormalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinNormalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinNormalDays: %w", err)
	}
	return oldValue.MinNormalDays, nil
}

// AddMinNormalDays adds i to the "min_normal_days" field.
func (m *ChannelMutation) AddMinNormalDays(i int32) {
	if m.addmin_normal_days != nil {
		*m.addmin_normal_days += i
	} else {
		m.addmin_normal_days = &i
	}
}

// AddedMinNormalDays returns the value that was added to the "min_normal_days" field in this mutation.
func (m *ChannelMutation) AddedMinNormalDays() (r int32, exists bool) {
	v := m.addmin_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinNormalDays resets all changes to the "min_normal_days" field.
func (m *ChannelMutation) ResetMinNormalDays() {
	m.min_normal_days = nil
	m.addmin_normal_days = nil
}

// SetMaxNormalDays sets the "max_normal_days" field.
func (m *ChannelMutation) SetMaxNormalDays(i int32) {
	m.max_normal_days = &i
	m.addmax_normal_days = nil
}

// MaxNormalDays returns the value of the "max_normal_days" field in the mutation.
func (m *ChannelMutation) MaxNormalDays() (r int32, exists bool) {
	v := m.max_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxNormalDays returns the old "max_normal_days" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldMaxNormalDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxNormalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxNormalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxNormalDays: %w", err)
	}
	return oldValue.MaxNormalDays, nil
}

// AddMaxNormalDays adds i to the "max_normal_days" field.
func (m *ChannelMutation) AddMaxNormalDays(i int32) {
	if m.addmax_normal_days != nil {
		*m.addmax_normal_days += i
	} else {
		m.addmax_normal_days = &i
	}
}

// AddedMaxNormalDays returns the value that was added to the "max_normal_days" field in this mutation.
func (m *ChannelMutation) AddedMaxNormalDays() (r int32, exists bool) {
	v := m.addmax_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxNormalDays resets all changes to the "max_normal_days" field.
func (m *ChannelMutation) ResetMaxNormalDays() {
	m.max_normal_days = nil
	m.addmax_normal_days = nil
}

// SetMaxWeight sets the "max_weight" field.
func (m *ChannelMutation) SetMaxWeight(i int) {
	m.max_weight = &i
	m.addmax_weight = nil
}

// MaxWeight returns the value of the "max_weight" field in the mutation.
func (m *ChannelMutation) MaxWeight() (r int, exists bool) {
	v := m.max_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWeight returns the old "max_weight" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldMaxWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWeight: %w", err)
	}
	return oldValue.MaxWeight, nil
}

// AddMaxWeight adds i to the "max_weight" field.
func (m *ChannelMutation) AddMaxWeight(i int) {
	if m.addmax_weight != nil {
		*m.addmax_weight += i
	} else {
		m.addmax_weight = &i
	}
}

// AddedMaxWeight returns the value that was added to the "max_weight" field in this mutation.
func (m *ChannelMutation) AddedMaxWeight() (r int, exists bool) {
	v := m.addmax_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxWeight resets all changes to the "max_weight" field.
func (m *ChannelMutation) ResetMaxWeight() {
	m.max_weight = nil
	m.addmax_weight = nil
}

// SetMaxLength sets the "max_length" field.
func (m *ChannelMutation) SetMaxLength(i int) {
	m.max_length = &i
	m.addmax_length = nil
}

// MaxLength returns the value of the "max_length" field in the mutation.
func (m *ChannelMutation) MaxLength() (r int, exists bool) {
	v := m.max_length
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLength returns the old "max_length" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldMaxLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLength: %w", err)
	}
	return oldValue.MaxLength, nil
}

// AddMaxLength adds i to the "max_length" field.
func (m *ChannelMutation) AddMaxLength(i int) {
	if m.addmax_length != nil {
		*m.addmax_length += i
	} else {
		m.addmax_length = &i
	}
}

// AddedMaxLength returns the value that was added to the "max_length" field in this mutation.
func (m *ChannelMutation) AddedMaxLength() (r int, exists bool) {
	v := m.addmax_length
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLength resets all changes to the "max_length" field.
func (m *ChannelMutation) ResetMaxLength() {
	m.max_length = nil
	m.addmax_length = nil
}

// SetMinLength sets the "min_length" field.
func (m *ChannelMutation) SetMinLength(i int) {
	m.min_length = &i
	m.addmin_length = nil
}

// MinLength returns the value of the "min_length" field in the mutation.
func (m *ChannelMutation) MinLength() (r int, exists bool) {
	v := m.min_length
	if v == nil {
		return
	}
	return *v, true
}

// OldMinLength returns the old "min_length" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldMinLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinLength: %w", err)
	}
	return oldValue.MinLength, nil
}

// AddMinLength adds i to the "min_length" field.
func (m *ChannelMutation) AddMinLength(i int) {
	if m.addmin_length != nil {
		*m.addmin_length += i
	} else {
		m.addmin_length = &i
	}
}

// AddedMinLength returns the value that was added to the "min_length" field in this mutation.
func (m *ChannelMutation) AddedMinLength() (r int, exists bool) {
	v := m.addmin_length
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinLength resets all changes to the "min_length" field.
func (m *ChannelMutation) ResetMinLength() {
	m.min_length = nil
	m.addmin_length = nil
}

// SetMaxThreeSideSum sets the "max_three_side_sum" field.
func (m *ChannelMutation) SetMaxThreeSideSum(i int) {
	m.max_three_side_sum = &i
	m.addmax_three_side_sum = nil
}

// MaxThreeSideSum returns the value of the "max_three_side_sum" field in the mutation.
func (m *ChannelMutation) MaxThreeSideSum() (r int, exists bool) {
	v := m.max_three_side_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxThreeSideSum returns the old "max_three_side_sum" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldMaxThreeSideSum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxThreeSideSum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxThreeSideSum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxThreeSideSum: %w", err)
	}
	return oldValue.MaxThreeSideSum, nil
}

// AddMaxThreeSideSum adds i to the "max_three_side_sum" field.
func (m *ChannelMutation) AddMaxThreeSideSum(i int) {
	if m.addmax_three_side_sum != nil {
		*m.addmax_three_side_sum += i
	} else {
		m.addmax_three_side_sum = &i
	}
}

// AddedMaxThreeSideSum returns the value that was added to the "max_three_side_sum" field in this mutation.
func (m *ChannelMutation) AddedMaxThreeSideSum() (r int, exists bool) {
	v := m.addmax_three_side_sum
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxThreeSideSum resets all changes to the "max_three_side_sum" field.
func (m *ChannelMutation) ResetMaxThreeSideSum() {
	m.max_three_side_sum = nil
	m.addmax_three_side_sum = nil
}

// SetDescription sets the "description" field.
func (m *ChannelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChannelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ChannelMutation) ResetDescription() {
	m.description = nil
}

// SetSortingPort sets the "sorting_port" field.
func (m *ChannelMutation) SetSortingPort(i int32) {
	m.sorting_port = &i
	m.addsorting_port = nil
}

// SortingPort returns the value of the "sorting_port" field in the mutation.
func (m *ChannelMutation) SortingPort() (r int32, exists bool) {
	v := m.sorting_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingPort returns the old "sorting_port" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSortingPort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingPort: %w", err)
	}
	return oldValue.SortingPort, nil
}

// AddSortingPort adds i to the "sorting_port" field.
func (m *ChannelMutation) AddSortingPort(i int32) {
	if m.addsorting_port != nil {
		*m.addsorting_port += i
	} else {
		m.addsorting_port = &i
	}
}

// AddedSortingPort returns the value that was added to the "sorting_port" field in this mutation.
func (m *ChannelMutation) AddedSortingPort() (r int32, exists bool) {
	v := m.addsorting_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortingPort resets all changes to the "sorting_port" field.
func (m *ChannelMutation) ResetSortingPort() {
	m.sorting_port = nil
	m.addsorting_port = nil
}

// SetPrepayTariff sets the "prepay_tariff" field.
func (m *ChannelMutation) SetPrepayTariff(b bool) {
	m.prepay_tariff = &b
}

// PrepayTariff returns the value of the "prepay_tariff" field in the mutation.
func (m *ChannelMutation) PrepayTariff() (r bool, exists bool) {
	v := m.prepay_tariff
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepayTariff returns the old "prepay_tariff" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldPrepayTariff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepayTariff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepayTariff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepayTariff: %w", err)
	}
	return oldValue.PrepayTariff, nil
}

// ResetPrepayTariff resets all changes to the "prepay_tariff" field.
func (m *ChannelMutation) ResetPrepayTariff() {
	m.prepay_tariff = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ChannelMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ChannelMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTest sets the "test" field.
func (m *ChannelMutation) SetTest(b bool) {
	m.test = &b
}

// Test returns the value of the "test" field in the mutation.
func (m *ChannelMutation) Test() (r bool, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTest returns the old "test" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldTest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTest: %w", err)
	}
	return oldValue.Test, nil
}

// ResetTest resets all changes to the "test" field.
func (m *ChannelMutation) ResetTest() {
	m.test = nil
}

// SetOptions sets the "options" field.
func (m *ChannelMutation) SetOptions(s string) {
	m.options = &s
}

// Options returns the value of the "options" field in the mutation.
func (m *ChannelMutation) Options() (r string, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldOptions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ClearOptions clears the value of the "options" field.
func (m *ChannelMutation) ClearOptions() {
	m.options = nil
	m.clearedFields[channel.FieldOptions] = struct{}{}
}

// OptionsCleared returns if the "options" field was cleared in this mutation.
func (m *ChannelMutation) OptionsCleared() bool {
	_, ok := m.clearedFields[channel.FieldOptions]
	return ok
}

// ResetOptions resets all changes to the "options" field.
func (m *ChannelMutation) ResetOptions() {
	m.options = nil
	delete(m.clearedFields, channel.FieldOptions)
}

// SetExcludeAttributes sets the "exclude_attributes" field.
func (m *ChannelMutation) SetExcludeAttributes(s string) {
	m.exclude_attributes = &s
}

// ExcludeAttributes returns the value of the "exclude_attributes" field in the mutation.
func (m *ChannelMutation) ExcludeAttributes() (r string, exists bool) {
	v := m.exclude_attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludeAttributes returns the old "exclude_attributes" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldExcludeAttributes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludeAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludeAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludeAttributes: %w", err)
	}
	return oldValue.ExcludeAttributes, nil
}

// ClearExcludeAttributes clears the value of the "exclude_attributes" field.
func (m *ChannelMutation) ClearExcludeAttributes() {
	m.exclude_attributes = nil
	m.clearedFields[channel.FieldExcludeAttributes] = struct{}{}
}

// ExcludeAttributesCleared returns if the "exclude_attributes" field was cleared in this mutation.
func (m *ChannelMutation) ExcludeAttributesCleared() bool {
	_, ok := m.clearedFields[channel.FieldExcludeAttributes]
	return ok
}

// ResetExcludeAttributes resets all changes to the "exclude_attributes" field.
func (m *ChannelMutation) ResetExcludeAttributes() {
	m.exclude_attributes = nil
	delete(m.clearedFields, channel.FieldExcludeAttributes)
}

// SetBattery sets the "battery" field.
func (m *ChannelMutation) SetBattery(i int8) {
	m.battery = &i
	m.addbattery = nil
}

// Battery returns the value of the "battery" field in the mutation.
func (m *ChannelMutation) Battery() (r int8, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBattery returns the old "battery" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBattery(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBattery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBattery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattery: %w", err)
	}
	return oldValue.Battery, nil
}

// AddBattery adds i to the "battery" field.
func (m *ChannelMutation) AddBattery(i int8) {
	if m.addbattery != nil {
		*m.addbattery += i
	} else {
		m.addbattery = &i
	}
}

// AddedBattery returns the value that was added to the "battery" field in this mutation.
func (m *ChannelMutation) AddedBattery() (r int8, exists bool) {
	v := m.addbattery
	if v == nil {
		return
	}
	return *v, true
}

// ResetBattery resets all changes to the "battery" field.
func (m *ChannelMutation) ResetBattery() {
	m.battery = nil
	m.addbattery = nil
}

// SetVirtual sets the "virtual" field.
func (m *ChannelMutation) SetVirtual(i int8) {
	m.virtual = &i
	m.addvirtual = nil
}

// Virtual returns the value of the "virtual" field in the mutation.
func (m *ChannelMutation) Virtual() (r int8, exists bool) {
	v := m.virtual
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtual returns the old "virtual" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldVirtual(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtual: %w", err)
	}
	return oldValue.Virtual, nil
}

// AddVirtual adds i to the "virtual" field.
func (m *ChannelMutation) AddVirtual(i int8) {
	if m.addvirtual != nil {
		*m.addvirtual += i
	} else {
		m.addvirtual = &i
	}
}

// AddedVirtual returns the value that was added to the "virtual" field in this mutation.
func (m *ChannelMutation) AddedVirtual() (r int8, exists bool) {
	v := m.addvirtual
	if v == nil {
		return
	}
	return *v, true
}

// ResetVirtual resets all changes to the "virtual" field.
func (m *ChannelMutation) ResetVirtual() {
	m.virtual = nil
	m.addvirtual = nil
}

// SetChannelType sets the "channel_type" field.
func (m *ChannelMutation) SetChannelType(i int8) {
	m.channel_type = &i
	m.addchannel_type = nil
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *ChannelMutation) ChannelType() (r int8, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldChannelType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// AddChannelType adds i to the "channel_type" field.
func (m *ChannelMutation) AddChannelType(i int8) {
	if m.addchannel_type != nil {
		*m.addchannel_type += i
	} else {
		m.addchannel_type = &i
	}
}

// AddedChannelType returns the value that was added to the "channel_type" field in this mutation.
func (m *ChannelMutation) AddedChannelType() (r int8, exists bool) {
	v := m.addchannel_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *ChannelMutation) ResetChannelType() {
	m.channel_type = nil
	m.addchannel_type = nil
}

// SetDeliverDuty sets the "deliver_duty" field.
func (m *ChannelMutation) SetDeliverDuty(s string) {
	m.deliver_duty = &s
}

// DeliverDuty returns the value of the "deliver_duty" field in the mutation.
func (m *ChannelMutation) DeliverDuty() (r string, exists bool) {
	v := m.deliver_duty
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliverDuty returns the old "deliver_duty" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeliverDuty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliverDuty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliverDuty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliverDuty: %w", err)
	}
	return oldValue.DeliverDuty, nil
}

// ResetDeliverDuty resets all changes to the "deliver_duty" field.
func (m *ChannelMutation) ResetDeliverDuty() {
	m.deliver_duty = nil
}

// SetSpecial sets the "special" field.
func (m *ChannelMutation) SetSpecial(i int8) {
	m.special = &i
	m.addspecial = nil
}

// Special returns the value of the "special" field in the mutation.
func (m *ChannelMutation) Special() (r int8, exists bool) {
	v := m.special
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecial returns the old "special" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSpecial(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecial: %w", err)
	}
	return oldValue.Special, nil
}

// AddSpecial adds i to the "special" field.
func (m *ChannelMutation) AddSpecial(i int8) {
	if m.addspecial != nil {
		*m.addspecial += i
	} else {
		m.addspecial = &i
	}
}

// AddedSpecial returns the value that was added to the "special" field in this mutation.
func (m *ChannelMutation) AddedSpecial() (r int8, exists bool) {
	v := m.addspecial
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecial resets all changes to the "special" field.
func (m *ChannelMutation) ResetSpecial() {
	m.special = nil
	m.addspecial = nil
}

// AddChannelCostIDs adds the "channel_costs" edge to the ChannelCost entity by ids.
func (m *ChannelMutation) AddChannelCostIDs(ids ...int64) {
	if m.channel_costs == nil {
		m.channel_costs = make(map[int64]struct{})
	}
	for i := range ids {
		m.channel_costs[ids[i]] = struct{}{}
	}
}

// ClearChannelCosts clears the "channel_costs" edge to the ChannelCost entity.
func (m *ChannelMutation) ClearChannelCosts() {
	m.clearedchannel_costs = true
}

// ChannelCostsCleared reports if the "channel_costs" edge to the ChannelCost entity was cleared.
func (m *ChannelMutation) ChannelCostsCleared() bool {
	return m.clearedchannel_costs
}

// RemoveChannelCostIDs removes the "channel_costs" edge to the ChannelCost entity by IDs.
func (m *ChannelMutation) RemoveChannelCostIDs(ids ...int64) {
	if m.removedchannel_costs == nil {
		m.removedchannel_costs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.channel_costs, ids[i])
		m.removedchannel_costs[ids[i]] = struct{}{}
	}
}

// RemovedChannelCosts returns the removed IDs of the "channel_costs" edge to the ChannelCost entity.
func (m *ChannelMutation) RemovedChannelCostsIDs() (ids []int64) {
	for id := range m.removedchannel_costs {
		ids = append(ids, id)
	}
	return
}

// ChannelCostsIDs returns the "channel_costs" edge IDs in the mutation.
func (m *ChannelMutation) ChannelCostsIDs() (ids []int64) {
	for id := range m.channel_costs {
		ids = append(ids, id)
	}
	return
}

// ResetChannelCosts resets all changes to the "channel_costs" edge.
func (m *ChannelMutation) ResetChannelCosts() {
	m.channel_costs = nil
	m.clearedchannel_costs = false
	m.removedchannel_costs = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *ChannelMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *ChannelMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *ChannelMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *ChannelMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *ChannelMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *ChannelMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *ChannelMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.warehouse_id != nil {
		fields = append(fields, channel.FieldWarehouseID)
	}
	if m.courier_platform != nil {
		fields = append(fields, channel.FieldCourierPlatform)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.code != nil {
		fields = append(fields, channel.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, channel.FieldType)
	}
	if m.quotation_currency != nil {
		fields = append(fields, channel.FieldQuotationCurrency)
	}
	if m.volume_factor != nil {
		fields = append(fields, channel.FieldVolumeFactor)
	}
	if m.en_name != nil {
		fields = append(fields, channel.FieldEnName)
	}
	if m.display_name != nil {
		fields = append(fields, channel.FieldDisplayName)
	}
	if m.has_tracking_number != nil {
		fields = append(fields, channel.FieldHasTrackingNumber)
	}
	if m.min_normal_days != nil {
		fields = append(fields, channel.FieldMinNormalDays)
	}
	if m.max_normal_days != nil {
		fields = append(fields, channel.FieldMaxNormalDays)
	}
	if m.max_weight != nil {
		fields = append(fields, channel.FieldMaxWeight)
	}
	if m.max_length != nil {
		fields = append(fields, channel.FieldMaxLength)
	}
	if m.min_length != nil {
		fields = append(fields, channel.FieldMinLength)
	}
	if m.max_three_side_sum != nil {
		fields = append(fields, channel.FieldMaxThreeSideSum)
	}
	if m.description != nil {
		fields = append(fields, channel.FieldDescription)
	}
	if m.sorting_port != nil {
		fields = append(fields, channel.FieldSortingPort)
	}
	if m.prepay_tariff != nil {
		fields = append(fields, channel.FieldPrepayTariff)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.test != nil {
		fields = append(fields, channel.FieldTest)
	}
	if m.options != nil {
		fields = append(fields, channel.FieldOptions)
	}
	if m.exclude_attributes != nil {
		fields = append(fields, channel.FieldExcludeAttributes)
	}
	if m.battery != nil {
		fields = append(fields, channel.FieldBattery)
	}
	if m.virtual != nil {
		fields = append(fields, channel.FieldVirtual)
	}
	if m.channel_type != nil {
		fields = append(fields, channel.FieldChannelType)
	}
	if m.deliver_duty != nil {
		fields = append(fields, channel.FieldDeliverDuty)
	}
	if m.special != nil {
		fields = append(fields, channel.FieldSpecial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldWarehouseID:
		return m.WarehouseID()
	case channel.FieldCourierPlatform:
		return m.CourierPlatform()
	case channel.FieldName:
		return m.Name()
	case channel.FieldCode:
		return m.Code()
	case channel.FieldType:
		return m.GetType()
	case channel.FieldQuotationCurrency:
		return m.QuotationCurrency()
	case channel.FieldVolumeFactor:
		return m.VolumeFactor()
	case channel.FieldEnName:
		return m.EnName()
	case channel.FieldDisplayName:
		return m.DisplayName()
	case channel.FieldHasTrackingNumber:
		return m.HasTrackingNumber()
	case channel.FieldMinNormalDays:
		return m.MinNormalDays()
	case channel.FieldMaxNormalDays:
		return m.MaxNormalDays()
	case channel.FieldMaxWeight:
		return m.MaxWeight()
	case channel.FieldMaxLength:
		return m.MaxLength()
	case channel.FieldMinLength:
		return m.MinLength()
	case channel.FieldMaxThreeSideSum:
		return m.MaxThreeSideSum()
	case channel.FieldDescription:
		return m.Description()
	case channel.FieldSortingPort:
		return m.SortingPort()
	case channel.FieldPrepayTariff:
		return m.PrepayTariff()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldTest:
		return m.Test()
	case channel.FieldOptions:
		return m.Options()
	case channel.FieldExcludeAttributes:
		return m.ExcludeAttributes()
	case channel.FieldBattery:
		return m.Battery()
	case channel.FieldVirtual:
		return m.Virtual()
	case channel.FieldChannelType:
		return m.ChannelType()
	case channel.FieldDeliverDuty:
		return m.DeliverDuty()
	case channel.FieldSpecial:
		return m.Special()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case channel.FieldCourierPlatform:
		return m.OldCourierPlatform(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldCode:
		return m.OldCode(ctx)
	case channel.FieldType:
		return m.OldType(ctx)
	case channel.FieldQuotationCurrency:
		return m.OldQuotationCurrency(ctx)
	case channel.FieldVolumeFactor:
		return m.OldVolumeFactor(ctx)
	case channel.FieldEnName:
		return m.OldEnName(ctx)
	case channel.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case channel.FieldHasTrackingNumber:
		return m.OldHasTrackingNumber(ctx)
	case channel.FieldMinNormalDays:
		return m.OldMinNormalDays(ctx)
	case channel.FieldMaxNormalDays:
		return m.OldMaxNormalDays(ctx)
	case channel.FieldMaxWeight:
		return m.OldMaxWeight(ctx)
	case channel.FieldMaxLength:
		return m.OldMaxLength(ctx)
	case channel.FieldMinLength:
		return m.OldMinLength(ctx)
	case channel.FieldMaxThreeSideSum:
		return m.OldMaxThreeSideSum(ctx)
	case channel.FieldDescription:
		return m.OldDescription(ctx)
	case channel.FieldSortingPort:
		return m.OldSortingPort(ctx)
	case channel.FieldPrepayTariff:
		return m.OldPrepayTariff(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldTest:
		return m.OldTest(ctx)
	case channel.FieldOptions:
		return m.OldOptions(ctx)
	case channel.FieldExcludeAttributes:
		return m.OldExcludeAttributes(ctx)
	case channel.FieldBattery:
		return m.OldBattery(ctx)
	case channel.FieldVirtual:
		return m.OldVirtual(ctx)
	case channel.FieldChannelType:
		return m.OldChannelType(ctx)
	case channel.FieldDeliverDuty:
		return m.OldDeliverDuty(ctx)
	case channel.FieldSpecial:
		return m.OldSpecial(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case channel.FieldCourierPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierPlatform(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case channel.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case channel.FieldQuotationCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotationCurrency(v)
		return nil
	case channel.FieldVolumeFactor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeFactor(v)
		return nil
	case channel.FieldEnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnName(v)
		return nil
	case channel.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case channel.FieldHasTrackingNumber:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTrackingNumber(v)
		return nil
	case channel.FieldMinNormalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinNormalDays(v)
		return nil
	case channel.FieldMaxNormalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxNormalDays(v)
		return nil
	case channel.FieldMaxWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWeight(v)
		return nil
	case channel.FieldMaxLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLength(v)
		return nil
	case channel.FieldMinLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinLength(v)
		return nil
	case channel.FieldMaxThreeSideSum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxThreeSideSum(v)
		return nil
	case channel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case channel.FieldSortingPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingPort(v)
		return nil
	case channel.FieldPrepayTariff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepayTariff(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldTest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTest(v)
		return nil
	case channel.FieldOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case channel.FieldExcludeAttributes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludeAttributes(v)
		return nil
	case channel.FieldBattery:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattery(v)
		return nil
	case channel.FieldVirtual:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtual(v)
		return nil
	case channel.FieldChannelType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case channel.FieldDeliverDuty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliverDuty(v)
		return nil
	case channel.FieldSpecial:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecial(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.addwarehouse_id != nil {
		fields = append(fields, channel.FieldWarehouseID)
	}
	if m.add_type != nil {
		fields = append(fields, channel.FieldType)
	}
	if m.addvolume_factor != nil {
		fields = append(fields, channel.FieldVolumeFactor)
	}
	if m.addhas_tracking_number != nil {
		fields = append(fields, channel.FieldHasTrackingNumber)
	}
	if m.addmin_normal_days != nil {
		fields = append(fields, channel.FieldMinNormalDays)
	}
	if m.addmax_normal_days != nil {
		fields = append(fields, channel.FieldMaxNormalDays)
	}
	if m.addmax_weight != nil {
		fields = append(fields, channel.FieldMaxWeight)
	}
	if m.addmax_length != nil {
		fields = append(fields, channel.FieldMaxLength)
	}
	if m.addmin_length != nil {
		fields = append(fields, channel.FieldMinLength)
	}
	if m.addmax_three_side_sum != nil {
		fields = append(fields, channel.FieldMaxThreeSideSum)
	}
	if m.addsorting_port != nil {
		fields = append(fields, channel.FieldSortingPort)
	}
	if m.addstatus != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.addbattery != nil {
		fields = append(fields, channel.FieldBattery)
	}
	if m.addvirtual != nil {
		fields = append(fields, channel.FieldVirtual)
	}
	if m.addchannel_type != nil {
		fields = append(fields, channel.FieldChannelType)
	}
	if m.addspecial != nil {
		fields = append(fields, channel.FieldSpecial)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldWarehouseID:
		return m.AddedWarehouseID()
	case channel.FieldType:
		return m.AddedType()
	case channel.FieldVolumeFactor:
		return m.AddedVolumeFactor()
	case channel.FieldHasTrackingNumber:
		return m.AddedHasTrackingNumber()
	case channel.FieldMinNormalDays:
		return m.AddedMinNormalDays()
	case channel.FieldMaxNormalDays:
		return m.AddedMaxNormalDays()
	case channel.FieldMaxWeight:
		return m.AddedMaxWeight()
	case channel.FieldMaxLength:
		return m.AddedMaxLength()
	case channel.FieldMinLength:
		return m.AddedMinLength()
	case channel.FieldMaxThreeSideSum:
		return m.AddedMaxThreeSideSum()
	case channel.FieldSortingPort:
		return m.AddedSortingPort()
	case channel.FieldStatus:
		return m.AddedStatus()
	case channel.FieldBattery:
		return m.AddedBattery()
	case channel.FieldVirtual:
		return m.AddedVirtual()
	case channel.FieldChannelType:
		return m.AddedChannelType()
	case channel.FieldSpecial:
		return m.AddedSpecial()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case channel.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case channel.FieldVolumeFactor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolumeFactor(v)
		return nil
	case channel.FieldHasTrackingNumber:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHasTrackingNumber(v)
		return nil
	case channel.FieldMinNormalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinNormalDays(v)
		return nil
	case channel.FieldMaxNormalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxNormalDays(v)
		return nil
	case channel.FieldMaxWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxWeight(v)
		return nil
	case channel.FieldMaxLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLength(v)
		return nil
	case channel.FieldMinLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinLength(v)
		return nil
	case channel.FieldMaxThreeSideSum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxThreeSideSum(v)
		return nil
	case channel.FieldSortingPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortingPort(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case channel.FieldBattery:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBattery(v)
		return nil
	case channel.FieldVirtual:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVirtual(v)
		return nil
	case channel.FieldChannelType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelType(v)
		return nil
	case channel.FieldSpecial:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecial(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldDeletedAt) {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.FieldCleared(channel.FieldOptions) {
		fields = append(fields, channel.FieldOptions)
	}
	if m.FieldCleared(channel.FieldExcludeAttributes) {
		fields = append(fields, channel.FieldExcludeAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case channel.FieldOptions:
		m.ClearOptions()
		return nil
	case channel.FieldExcludeAttributes:
		m.ClearExcludeAttributes()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case channel.FieldCourierPlatform:
		m.ResetCourierPlatform()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldCode:
		m.ResetCode()
		return nil
	case channel.FieldType:
		m.ResetType()
		return nil
	case channel.FieldQuotationCurrency:
		m.ResetQuotationCurrency()
		return nil
	case channel.FieldVolumeFactor:
		m.ResetVolumeFactor()
		return nil
	case channel.FieldEnName:
		m.ResetEnName()
		return nil
	case channel.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case channel.FieldHasTrackingNumber:
		m.ResetHasTrackingNumber()
		return nil
	case channel.FieldMinNormalDays:
		m.ResetMinNormalDays()
		return nil
	case channel.FieldMaxNormalDays:
		m.ResetMaxNormalDays()
		return nil
	case channel.FieldMaxWeight:
		m.ResetMaxWeight()
		return nil
	case channel.FieldMaxLength:
		m.ResetMaxLength()
		return nil
	case channel.FieldMinLength:
		m.ResetMinLength()
		return nil
	case channel.FieldMaxThreeSideSum:
		m.ResetMaxThreeSideSum()
		return nil
	case channel.FieldDescription:
		m.ResetDescription()
		return nil
	case channel.FieldSortingPort:
		m.ResetSortingPort()
		return nil
	case channel.FieldPrepayTariff:
		m.ResetPrepayTariff()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldTest:
		m.ResetTest()
		return nil
	case channel.FieldOptions:
		m.ResetOptions()
		return nil
	case channel.FieldExcludeAttributes:
		m.ResetExcludeAttributes()
		return nil
	case channel.FieldBattery:
		m.ResetBattery()
		return nil
	case channel.FieldVirtual:
		m.ResetVirtual()
		return nil
	case channel.FieldChannelType:
		m.ResetChannelType()
		return nil
	case channel.FieldDeliverDuty:
		m.ResetDeliverDuty()
		return nil
	case channel.FieldSpecial:
		m.ResetSpecial()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channel_costs != nil {
		edges = append(edges, channel.EdgeChannelCosts)
	}
	if m.orders != nil {
		edges = append(edges, channel.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeChannelCosts:
		ids := make([]ent.Value, 0, len(m.channel_costs))
		for id := range m.channel_costs {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchannel_costs != nil {
		edges = append(edges, channel.EdgeChannelCosts)
	}
	if m.removedorders != nil {
		edges = append(edges, channel.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeChannelCosts:
		ids := make([]ent.Value, 0, len(m.removedchannel_costs))
		for id := range m.removedchannel_costs {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannel_costs {
		edges = append(edges, channel.EdgeChannelCosts)
	}
	if m.clearedorders {
		edges = append(edges, channel.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeChannelCosts:
		return m.clearedchannel_costs
	case channel.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeChannelCosts:
		m.ResetChannelCosts()
		return nil
	case channel.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ChannelCostMutation represents an operation that mutates the ChannelCost nodes in the graph.
type ChannelCostMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	channel_cost_batch_id    *int64
	addchannel_cost_batch_id *int64
	mode                     *int8
	addmode                  *int8
	country_code             *string
	zone                     *string
	start_weight             *int
	addstart_weight          *int
	end_weight               *int
	addend_weight            *int
	first_weight             *int
	addfirst_weight          *int
	first_weight_fee         *float64
	addfirst_weight_fee      *float64
	unit_weight              *int
	addunit_weight           *int
	unit_weight_fee          *float64
	addunit_weight_fee       *float64
	fuel_fee                 *float64
	addfuel_fee              *float64
	processing_fee           *float64
	addprocessing_fee        *float64
	registration_fee         *float64
	addregistration_fee      *float64
	misc_fee                 *float64
	addmisc_fee              *float64
	min_normal_days          *int
	addmin_normal_days       *int
	max_normal_days          *int
	addmax_normal_days       *int
	status                   *int8
	addstatus                *int8
	average_days             *int
	addaverage_days          *int
	clearedFields            map[string]struct{}
	channels                 *int64
	clearedchannels          bool
	done                     bool
	oldValue                 func(context.Context) (*ChannelCost, error)
	predicates               []predicate.ChannelCost
}

var _ ent.Mutation = (*ChannelCostMutation)(nil)

// channelcostOption allows management of the mutation configuration using functional options.
type channelcostOption func(*ChannelCostMutation)

// newChannelCostMutation creates new mutation for the ChannelCost entity.
func newChannelCostMutation(c config, op Op, opts ...channelcostOption) *ChannelCostMutation {
	m := &ChannelCostMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelCost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelCostID sets the ID field of the mutation.
func withChannelCostID(id int64) channelcostOption {
	return func(m *ChannelCostMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelCost
		)
		m.oldValue = func(ctx context.Context) (*ChannelCost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelCost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelCost sets the old ChannelCost of the mutation.
func withChannelCost(node *ChannelCost) channelcostOption {
	return func(m *ChannelCostMutation) {
		m.oldValue = func(context.Context) (*ChannelCost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelCostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelCostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelCost entities.
func (m *ChannelCostMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelCostMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelCostMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelCost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelCostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelCostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelCostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelCostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelCostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelCostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelCostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelCostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelCostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channelcost.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelCostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channelcost.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelCostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channelcost.FieldDeletedAt)
}

// SetChannelCostBatchID sets the "channel_cost_batch_id" field.
func (m *ChannelCostMutation) SetChannelCostBatchID(i int64) {
	m.channel_cost_batch_id = &i
	m.addchannel_cost_batch_id = nil
}

// ChannelCostBatchID returns the value of the "channel_cost_batch_id" field in the mutation.
func (m *ChannelCostMutation) ChannelCostBatchID() (r int64, exists bool) {
	v := m.channel_cost_batch_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelCostBatchID returns the old "channel_cost_batch_id" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldChannelCostBatchID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelCostBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelCostBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelCostBatchID: %w", err)
	}
	return oldValue.ChannelCostBatchID, nil
}

// AddChannelCostBatchID adds i to the "channel_cost_batch_id" field.
func (m *ChannelCostMutation) AddChannelCostBatchID(i int64) {
	if m.addchannel_cost_batch_id != nil {
		*m.addchannel_cost_batch_id += i
	} else {
		m.addchannel_cost_batch_id = &i
	}
}

// AddedChannelCostBatchID returns the value that was added to the "channel_cost_batch_id" field in this mutation.
func (m *ChannelCostMutation) AddedChannelCostBatchID() (r int64, exists bool) {
	v := m.addchannel_cost_batch_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelCostBatchID resets all changes to the "channel_cost_batch_id" field.
func (m *ChannelCostMutation) ResetChannelCostBatchID() {
	m.channel_cost_batch_id = nil
	m.addchannel_cost_batch_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelCostMutation) SetChannelID(i int64) {
	m.channels = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelCostMutation) ChannelID() (r int64, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *ChannelCostMutation) ClearChannelID() {
	m.channels = nil
	m.clearedFields[channelcost.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *ChannelCostMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[channelcost.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelCostMutation) ResetChannelID() {
	m.channels = nil
	delete(m.clearedFields, channelcost.FieldChannelID)
}

// SetMode sets the "mode" field.
func (m *ChannelCostMutation) SetMode(i int8) {
	m.mode = &i
	m.addmode = nil
}

// Mode returns the value of the "mode" field in the mutation.
func (m *ChannelCostMutation) Mode() (r int8, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldMode(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// AddMode adds i to the "mode" field.
func (m *ChannelCostMutation) AddMode(i int8) {
	if m.addmode != nil {
		*m.addmode += i
	} else {
		m.addmode = &i
	}
}

// AddedMode returns the value that was added to the "mode" field in this mutation.
func (m *ChannelCostMutation) AddedMode() (r int8, exists bool) {
	v := m.addmode
	if v == nil {
		return
	}
	return *v, true
}

// ResetMode resets all changes to the "mode" field.
func (m *ChannelCostMutation) ResetMode() {
	m.mode = nil
	m.addmode = nil
}

// SetCountryCode sets the "country_code" field.
func (m *ChannelCostMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ChannelCostMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ChannelCostMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetZone sets the "zone" field.
func (m *ChannelCostMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the value of the "zone" field in the mutation.
func (m *ChannelCostMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old "zone" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ResetZone resets all changes to the "zone" field.
func (m *ChannelCostMutation) ResetZone() {
	m.zone = nil
}

// SetStartWeight sets the "start_weight" field.
func (m *ChannelCostMutation) SetStartWeight(i int) {
	m.start_weight = &i
	m.addstart_weight = nil
}

// StartWeight returns the value of the "start_weight" field in the mutation.
func (m *ChannelCostMutation) StartWeight() (r int, exists bool) {
	v := m.start_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldStartWeight returns the old "start_weight" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldStartWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartWeight: %w", err)
	}
	return oldValue.StartWeight, nil
}

// AddStartWeight adds i to the "start_weight" field.
func (m *ChannelCostMutation) AddStartWeight(i int) {
	if m.addstart_weight != nil {
		*m.addstart_weight += i
	} else {
		m.addstart_weight = &i
	}
}

// AddedStartWeight returns the value that was added to the "start_weight" field in this mutation.
func (m *ChannelCostMutation) AddedStartWeight() (r int, exists bool) {
	v := m.addstart_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartWeight resets all changes to the "start_weight" field.
func (m *ChannelCostMutation) ResetStartWeight() {
	m.start_weight = nil
	m.addstart_weight = nil
}

// SetEndWeight sets the "end_weight" field.
func (m *ChannelCostMutation) SetEndWeight(i int) {
	m.end_weight = &i
	m.addend_weight = nil
}

// EndWeight returns the value of the "end_weight" field in the mutation.
func (m *ChannelCostMutation) EndWeight() (r int, exists bool) {
	v := m.end_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldEndWeight returns the old "end_weight" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldEndWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndWeight: %w", err)
	}
	return oldValue.EndWeight, nil
}

// AddEndWeight adds i to the "end_weight" field.
func (m *ChannelCostMutation) AddEndWeight(i int) {
	if m.addend_weight != nil {
		*m.addend_weight += i
	} else {
		m.addend_weight = &i
	}
}

// AddedEndWeight returns the value that was added to the "end_weight" field in this mutation.
func (m *ChannelCostMutation) AddedEndWeight() (r int, exists bool) {
	v := m.addend_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndWeight resets all changes to the "end_weight" field.
func (m *ChannelCostMutation) ResetEndWeight() {
	m.end_weight = nil
	m.addend_weight = nil
}

// SetFirstWeight sets the "first_weight" field.
func (m *ChannelCostMutation) SetFirstWeight(i int) {
	m.first_weight = &i
	m.addfirst_weight = nil
}

// FirstWeight returns the value of the "first_weight" field in the mutation.
func (m *ChannelCostMutation) FirstWeight() (r int, exists bool) {
	v := m.first_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstWeight returns the old "first_weight" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldFirstWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstWeight: %w", err)
	}
	return oldValue.FirstWeight, nil
}

// AddFirstWeight adds i to the "first_weight" field.
func (m *ChannelCostMutation) AddFirstWeight(i int) {
	if m.addfirst_weight != nil {
		*m.addfirst_weight += i
	} else {
		m.addfirst_weight = &i
	}
}

// AddedFirstWeight returns the value that was added to the "first_weight" field in this mutation.
func (m *ChannelCostMutation) AddedFirstWeight() (r int, exists bool) {
	v := m.addfirst_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstWeight resets all changes to the "first_weight" field.
func (m *ChannelCostMutation) ResetFirstWeight() {
	m.first_weight = nil
	m.addfirst_weight = nil
}

// SetFirstWeightFee sets the "first_weight_fee" field.
func (m *ChannelCostMutation) SetFirstWeightFee(f float64) {
	m.first_weight_fee = &f
	m.addfirst_weight_fee = nil
}

// FirstWeightFee returns the value of the "first_weight_fee" field in the mutation.
func (m *ChannelCostMutation) FirstWeightFee() (r float64, exists bool) {
	v := m.first_weight_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstWeightFee returns the old "first_weight_fee" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldFirstWeightFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstWeightFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstWeightFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstWeightFee: %w", err)
	}
	return oldValue.FirstWeightFee, nil
}

// AddFirstWeightFee adds f to the "first_weight_fee" field.
func (m *ChannelCostMutation) AddFirstWeightFee(f float64) {
	if m.addfirst_weight_fee != nil {
		*m.addfirst_weight_fee += f
	} else {
		m.addfirst_weight_fee = &f
	}
}

// AddedFirstWeightFee returns the value that was added to the "first_weight_fee" field in this mutation.
func (m *ChannelCostMutation) AddedFirstWeightFee() (r float64, exists bool) {
	v := m.addfirst_weight_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstWeightFee resets all changes to the "first_weight_fee" field.
func (m *ChannelCostMutation) ResetFirstWeightFee() {
	m.first_weight_fee = nil
	m.addfirst_weight_fee = nil
}

// SetUnitWeight sets the "unit_weight" field.
func (m *ChannelCostMutation) SetUnitWeight(i int) {
	m.unit_weight = &i
	m.addunit_weight = nil
}

// UnitWeight returns the value of the "unit_weight" field in the mutation.
func (m *ChannelCostMutation) UnitWeight() (r int, exists bool) {
	v := m.unit_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitWeight returns the old "unit_weight" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldUnitWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitWeight: %w", err)
	}
	return oldValue.UnitWeight, nil
}

// AddUnitWeight adds i to the "unit_weight" field.
func (m *ChannelCostMutation) AddUnitWeight(i int) {
	if m.addunit_weight != nil {
		*m.addunit_weight += i
	} else {
		m.addunit_weight = &i
	}
}

// AddedUnitWeight returns the value that was added to the "unit_weight" field in this mutation.
func (m *ChannelCostMutation) AddedUnitWeight() (r int, exists bool) {
	v := m.addunit_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitWeight resets all changes to the "unit_weight" field.
func (m *ChannelCostMutation) ResetUnitWeight() {
	m.unit_weight = nil
	m.addunit_weight = nil
}

// SetUnitWeightFee sets the "unit_weight_fee" field.
func (m *ChannelCostMutation) SetUnitWeightFee(f float64) {
	m.unit_weight_fee = &f
	m.addunit_weight_fee = nil
}

// UnitWeightFee returns the value of the "unit_weight_fee" field in the mutation.
func (m *ChannelCostMutation) UnitWeightFee() (r float64, exists bool) {
	v := m.unit_weight_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitWeightFee returns the old "unit_weight_fee" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldUnitWeightFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitWeightFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitWeightFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitWeightFee: %w", err)
	}
	return oldValue.UnitWeightFee, nil
}

// AddUnitWeightFee adds f to the "unit_weight_fee" field.
func (m *ChannelCostMutation) AddUnitWeightFee(f float64) {
	if m.addunit_weight_fee != nil {
		*m.addunit_weight_fee += f
	} else {
		m.addunit_weight_fee = &f
	}
}

// AddedUnitWeightFee returns the value that was added to the "unit_weight_fee" field in this mutation.
func (m *ChannelCostMutation) AddedUnitWeightFee() (r float64, exists bool) {
	v := m.addunit_weight_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitWeightFee clears the value of the "unit_weight_fee" field.
func (m *ChannelCostMutation) ClearUnitWeightFee() {
	m.unit_weight_fee = nil
	m.addunit_weight_fee = nil
	m.clearedFields[channelcost.FieldUnitWeightFee] = struct{}{}
}

// UnitWeightFeeCleared returns if the "unit_weight_fee" field was cleared in this mutation.
func (m *ChannelCostMutation) UnitWeightFeeCleared() bool {
	_, ok := m.clearedFields[channelcost.FieldUnitWeightFee]
	return ok
}

// ResetUnitWeightFee resets all changes to the "unit_weight_fee" field.
func (m *ChannelCostMutation) ResetUnitWeightFee() {
	m.unit_weight_fee = nil
	m.addunit_weight_fee = nil
	delete(m.clearedFields, channelcost.FieldUnitWeightFee)
}

// SetFuelFee sets the "fuel_fee" field.
func (m *ChannelCostMutation) SetFuelFee(f float64) {
	m.fuel_fee = &f
	m.addfuel_fee = nil
}

// FuelFee returns the value of the "fuel_fee" field in the mutation.
func (m *ChannelCostMutation) FuelFee() (r float64, exists bool) {
	v := m.fuel_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelFee returns the old "fuel_fee" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldFuelFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelFee: %w", err)
	}
	return oldValue.FuelFee, nil
}

// AddFuelFee adds f to the "fuel_fee" field.
func (m *ChannelCostMutation) AddFuelFee(f float64) {
	if m.addfuel_fee != nil {
		*m.addfuel_fee += f
	} else {
		m.addfuel_fee = &f
	}
}

// AddedFuelFee returns the value that was added to the "fuel_fee" field in this mutation.
func (m *ChannelCostMutation) AddedFuelFee() (r float64, exists bool) {
	v := m.addfuel_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFuelFee resets all changes to the "fuel_fee" field.
func (m *ChannelCostMutation) ResetFuelFee() {
	m.fuel_fee = nil
	m.addfuel_fee = nil
}

// SetProcessingFee sets the "processing_fee" field.
func (m *ChannelCostMutation) SetProcessingFee(f float64) {
	m.processing_fee = &f
	m.addprocessing_fee = nil
}

// ProcessingFee returns the value of the "processing_fee" field in the mutation.
func (m *ChannelCostMutation) ProcessingFee() (r float64, exists bool) {
	v := m.processing_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessingFee returns the old "processing_fee" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldProcessingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessingFee: %w", err)
	}
	return oldValue.ProcessingFee, nil
}

// AddProcessingFee adds f to the "processing_fee" field.
func (m *ChannelCostMutation) AddProcessingFee(f float64) {
	if m.addprocessing_fee != nil {
		*m.addprocessing_fee += f
	} else {
		m.addprocessing_fee = &f
	}
}

// AddedProcessingFee returns the value that was added to the "processing_fee" field in this mutation.
func (m *ChannelCostMutation) AddedProcessingFee() (r float64, exists bool) {
	v := m.addprocessing_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcessingFee resets all changes to the "processing_fee" field.
func (m *ChannelCostMutation) ResetProcessingFee() {
	m.processing_fee = nil
	m.addprocessing_fee = nil
}

// SetRegistrationFee sets the "registration_fee" field.
func (m *ChannelCostMutation) SetRegistrationFee(f float64) {
	m.registration_fee = &f
	m.addregistration_fee = nil
}

// RegistrationFee returns the value of the "registration_fee" field in the mutation.
func (m *ChannelCostMutation) RegistrationFee() (r float64, exists bool) {
	v := m.registration_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationFee returns the old "registration_fee" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldRegistrationFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationFee: %w", err)
	}
	return oldValue.RegistrationFee, nil
}

// AddRegistrationFee adds f to the "registration_fee" field.
func (m *ChannelCostMutation) AddRegistrationFee(f float64) {
	if m.addregistration_fee != nil {
		*m.addregistration_fee += f
	} else {
		m.addregistration_fee = &f
	}
}

// AddedRegistrationFee returns the value that was added to the "registration_fee" field in this mutation.
func (m *ChannelCostMutation) AddedRegistrationFee() (r float64, exists bool) {
	v := m.addregistration_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegistrationFee resets all changes to the "registration_fee" field.
func (m *ChannelCostMutation) ResetRegistrationFee() {
	m.registration_fee = nil
	m.addregistration_fee = nil
}

// SetMiscFee sets the "misc_fee" field.
func (m *ChannelCostMutation) SetMiscFee(f float64) {
	m.misc_fee = &f
	m.addmisc_fee = nil
}

// MiscFee returns the value of the "misc_fee" field in the mutation.
func (m *ChannelCostMutation) MiscFee() (r float64, exists bool) {
	v := m.misc_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldMiscFee returns the old "misc_fee" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldMiscFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiscFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiscFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiscFee: %w", err)
	}
	return oldValue.MiscFee, nil
}

// AddMiscFee adds f to the "misc_fee" field.
func (m *ChannelCostMutation) AddMiscFee(f float64) {
	if m.addmisc_fee != nil {
		*m.addmisc_fee += f
	} else {
		m.addmisc_fee = &f
	}
}

// AddedMiscFee returns the value that was added to the "misc_fee" field in this mutation.
func (m *ChannelCostMutation) AddedMiscFee() (r float64, exists bool) {
	v := m.addmisc_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetMiscFee resets all changes to the "misc_fee" field.
func (m *ChannelCostMutation) ResetMiscFee() {
	m.misc_fee = nil
	m.addmisc_fee = nil
}

// SetMinNormalDays sets the "min_normal_days" field.
func (m *ChannelCostMutation) SetMinNormalDays(i int) {
	m.min_normal_days = &i
	m.addmin_normal_days = nil
}

// MinNormalDays returns the value of the "min_normal_days" field in the mutation.
func (m *ChannelCostMutation) MinNormalDays() (r int, exists bool) {
	v := m.min_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// OldMinNormalDays returns the old "min_normal_days" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldMinNormalDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinNormalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinNormalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinNormalDays: %w", err)
	}
	return oldValue.MinNormalDays, nil
}

// AddMinNormalDays adds i to the "min_normal_days" field.
func (m *ChannelCostMutation) AddMinNormalDays(i int) {
	if m.addmin_normal_days != nil {
		*m.addmin_normal_days += i
	} else {
		m.addmin_normal_days = &i
	}
}

// AddedMinNormalDays returns the value that was added to the "min_normal_days" field in this mutation.
func (m *ChannelCostMutation) AddedMinNormalDays() (r int, exists bool) {
	v := m.addmin_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinNormalDays resets all changes to the "min_normal_days" field.
func (m *ChannelCostMutation) ResetMinNormalDays() {
	m.min_normal_days = nil
	m.addmin_normal_days = nil
}

// SetMaxNormalDays sets the "max_normal_days" field.
func (m *ChannelCostMutation) SetMaxNormalDays(i int) {
	m.max_normal_days = &i
	m.addmax_normal_days = nil
}

// MaxNormalDays returns the value of the "max_normal_days" field in the mutation.
func (m *ChannelCostMutation) MaxNormalDays() (r int, exists bool) {
	v := m.max_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxNormalDays returns the old "max_normal_days" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldMaxNormalDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxNormalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxNormalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxNormalDays: %w", err)
	}
	return oldValue.MaxNormalDays, nil
}

// AddMaxNormalDays adds i to the "max_normal_days" field.
func (m *ChannelCostMutation) AddMaxNormalDays(i int) {
	if m.addmax_normal_days != nil {
		*m.addmax_normal_days += i
	} else {
		m.addmax_normal_days = &i
	}
}

// AddedMaxNormalDays returns the value that was added to the "max_normal_days" field in this mutation.
func (m *ChannelCostMutation) AddedMaxNormalDays() (r int, exists bool) {
	v := m.addmax_normal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxNormalDays resets all changes to the "max_normal_days" field.
func (m *ChannelCostMutation) ResetMaxNormalDays() {
	m.max_normal_days = nil
	m.addmax_normal_days = nil
}

// SetStatus sets the "status" field.
func (m *ChannelCostMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelCostMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ChannelCostMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ChannelCostMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelCostMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAverageDays sets the "average_days" field.
func (m *ChannelCostMutation) SetAverageDays(i int) {
	m.average_days = &i
	m.addaverage_days = nil
}

// AverageDays returns the value of the "average_days" field in the mutation.
func (m *ChannelCostMutation) AverageDays() (r int, exists bool) {
	v := m.average_days
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageDays returns the old "average_days" field's value of the ChannelCost entity.
// If the ChannelCost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostMutation) OldAverageDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageDays: %w", err)
	}
	return oldValue.AverageDays, nil
}

// AddAverageDays adds i to the "average_days" field.
func (m *ChannelCostMutation) AddAverageDays(i int) {
	if m.addaverage_days != nil {
		*m.addaverage_days += i
	} else {
		m.addaverage_days = &i
	}
}

// AddedAverageDays returns the value that was added to the "average_days" field in this mutation.
func (m *ChannelCostMutation) AddedAverageDays() (r int, exists bool) {
	v := m.addaverage_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageDays resets all changes to the "average_days" field.
func (m *ChannelCostMutation) ResetAverageDays() {
	m.average_days = nil
	m.addaverage_days = nil
}

// SetChannelsID sets the "channels" edge to the Channel entity by id.
func (m *ChannelCostMutation) SetChannelsID(id int64) {
	m.channels = &id
}

// ClearChannels clears the "channels" edge to the Channel entity.
func (m *ChannelCostMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the Channel entity was cleared.
func (m *ChannelCostMutation) ChannelsCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannels
}

// ChannelsID returns the "channels" edge ID in the mutation.
func (m *ChannelCostMutation) ChannelsID() (id int64, exists bool) {
	if m.channels != nil {
		return *m.channels, true
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelsID instead. It exists only for internal usage by the builders.
func (m *ChannelCostMutation) ChannelsIDs() (ids []int64) {
	if id := m.channels; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *ChannelCostMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
}

// Where appends a list predicates to the ChannelCostMutation builder.
func (m *ChannelCostMutation) Where(ps ...predicate.ChannelCost) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelCostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ChannelCost).
func (m *ChannelCostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelCostMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, channelcost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelcost.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channelcost.FieldDeletedAt)
	}
	if m.channel_cost_batch_id != nil {
		fields = append(fields, channelcost.FieldChannelCostBatchID)
	}
	if m.channels != nil {
		fields = append(fields, channelcost.FieldChannelID)
	}
	if m.mode != nil {
		fields = append(fields, channelcost.FieldMode)
	}
	if m.country_code != nil {
		fields = append(fields, channelcost.FieldCountryCode)
	}
	if m.zone != nil {
		fields = append(fields, channelcost.FieldZone)
	}
	if m.start_weight != nil {
		fields = append(fields, channelcost.FieldStartWeight)
	}
	if m.end_weight != nil {
		fields = append(fields, channelcost.FieldEndWeight)
	}
	if m.first_weight != nil {
		fields = append(fields, channelcost.FieldFirstWeight)
	}
	if m.first_weight_fee != nil {
		fields = append(fields, channelcost.FieldFirstWeightFee)
	}
	if m.unit_weight != nil {
		fields = append(fields, channelcost.FieldUnitWeight)
	}
	if m.unit_weight_fee != nil {
		fields = append(fields, channelcost.FieldUnitWeightFee)
	}
	if m.fuel_fee != nil {
		fields = append(fields, channelcost.FieldFuelFee)
	}
	if m.processing_fee != nil {
		fields = append(fields, channelcost.FieldProcessingFee)
	}
	if m.registration_fee != nil {
		fields = append(fields, channelcost.FieldRegistrationFee)
	}
	if m.misc_fee != nil {
		fields = append(fields, channelcost.FieldMiscFee)
	}
	if m.min_normal_days != nil {
		fields = append(fields, channelcost.FieldMinNormalDays)
	}
	if m.max_normal_days != nil {
		fields = append(fields, channelcost.FieldMaxNormalDays)
	}
	if m.status != nil {
		fields = append(fields, channelcost.FieldStatus)
	}
	if m.average_days != nil {
		fields = append(fields, channelcost.FieldAverageDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelCostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelcost.FieldCreatedAt:
		return m.CreatedAt()
	case channelcost.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelcost.FieldDeletedAt:
		return m.DeletedAt()
	case channelcost.FieldChannelCostBatchID:
		return m.ChannelCostBatchID()
	case channelcost.FieldChannelID:
		return m.ChannelID()
	case channelcost.FieldMode:
		return m.Mode()
	case channelcost.FieldCountryCode:
		return m.CountryCode()
	case channelcost.FieldZone:
		return m.Zone()
	case channelcost.FieldStartWeight:
		return m.StartWeight()
	case channelcost.FieldEndWeight:
		return m.EndWeight()
	case channelcost.FieldFirstWeight:
		return m.FirstWeight()
	case channelcost.FieldFirstWeightFee:
		return m.FirstWeightFee()
	case channelcost.FieldUnitWeight:
		return m.UnitWeight()
	case channelcost.FieldUnitWeightFee:
		return m.UnitWeightFee()
	case channelcost.FieldFuelFee:
		return m.FuelFee()
	case channelcost.FieldProcessingFee:
		return m.ProcessingFee()
	case channelcost.FieldRegistrationFee:
		return m.RegistrationFee()
	case channelcost.FieldMiscFee:
		return m.MiscFee()
	case channelcost.FieldMinNormalDays:
		return m.MinNormalDays()
	case channelcost.FieldMaxNormalDays:
		return m.MaxNormalDays()
	case channelcost.FieldStatus:
		return m.Status()
	case channelcost.FieldAverageDays:
		return m.AverageDays()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelCostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelcost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelcost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelcost.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channelcost.FieldChannelCostBatchID:
		return m.OldChannelCostBatchID(ctx)
	case channelcost.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelcost.FieldMode:
		return m.OldMode(ctx)
	case channelcost.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case channelcost.FieldZone:
		return m.OldZone(ctx)
	case channelcost.FieldStartWeight:
		return m.OldStartWeight(ctx)
	case channelcost.FieldEndWeight:
		return m.OldEndWeight(ctx)
	case channelcost.FieldFirstWeight:
		return m.OldFirstWeight(ctx)
	case channelcost.FieldFirstWeightFee:
		return m.OldFirstWeightFee(ctx)
	case channelcost.FieldUnitWeight:
		return m.OldUnitWeight(ctx)
	case channelcost.FieldUnitWeightFee:
		return m.OldUnitWeightFee(ctx)
	case channelcost.FieldFuelFee:
		return m.OldFuelFee(ctx)
	case channelcost.FieldProcessingFee:
		return m.OldProcessingFee(ctx)
	case channelcost.FieldRegistrationFee:
		return m.OldRegistrationFee(ctx)
	case channelcost.FieldMiscFee:
		return m.OldMiscFee(ctx)
	case channelcost.FieldMinNormalDays:
		return m.OldMinNormalDays(ctx)
	case channelcost.FieldMaxNormalDays:
		return m.OldMaxNormalDays(ctx)
	case channelcost.FieldStatus:
		return m.OldStatus(ctx)
	case channelcost.FieldAverageDays:
		return m.OldAverageDays(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelCost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelCostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelcost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelcost.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelcost.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channelcost.FieldChannelCostBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelCostBatchID(v)
		return nil
	case channelcost.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelcost.FieldMode:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case channelcost.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case channelcost.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	case channelcost.FieldStartWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartWeight(v)
		return nil
	case channelcost.FieldEndWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndWeight(v)
		return nil
	case channelcost.FieldFirstWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstWeight(v)
		return nil
	case channelcost.FieldFirstWeightFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstWeightFee(v)
		return nil
	case channelcost.FieldUnitWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitWeight(v)
		return nil
	case channelcost.FieldUnitWeightFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitWeightFee(v)
		return nil
	case channelcost.FieldFuelFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelFee(v)
		return nil
	case channelcost.FieldProcessingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessingFee(v)
		return nil
	case channelcost.FieldRegistrationFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationFee(v)
		return nil
	case channelcost.FieldMiscFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiscFee(v)
		return nil
	case channelcost.FieldMinNormalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinNormalDays(v)
		return nil
	case channelcost.FieldMaxNormalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxNormalDays(v)
		return nil
	case channelcost.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channelcost.FieldAverageDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageDays(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelCost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelCostMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_cost_batch_id != nil {
		fields = append(fields, channelcost.FieldChannelCostBatchID)
	}
	if m.addmode != nil {
		fields = append(fields, channelcost.FieldMode)
	}
	if m.addstart_weight != nil {
		fields = append(fields, channelcost.FieldStartWeight)
	}
	if m.addend_weight != nil {
		fields = append(fields, channelcost.FieldEndWeight)
	}
	if m.addfirst_weight != nil {
		fields = append(fields, channelcost.FieldFirstWeight)
	}
	if m.addfirst_weight_fee != nil {
		fields = append(fields, channelcost.FieldFirstWeightFee)
	}
	if m.addunit_weight != nil {
		fields = append(fields, channelcost.FieldUnitWeight)
	}
	if m.addunit_weight_fee != nil {
		fields = append(fields, channelcost.FieldUnitWeightFee)
	}
	if m.addfuel_fee != nil {
		fields = append(fields, channelcost.FieldFuelFee)
	}
	if m.addprocessing_fee != nil {
		fields = append(fields, channelcost.FieldProcessingFee)
	}
	if m.addregistration_fee != nil {
		fields = append(fields, channelcost.FieldRegistrationFee)
	}
	if m.addmisc_fee != nil {
		fields = append(fields, channelcost.FieldMiscFee)
	}
	if m.addmin_normal_days != nil {
		fields = append(fields, channelcost.FieldMinNormalDays)
	}
	if m.addmax_normal_days != nil {
		fields = append(fields, channelcost.FieldMaxNormalDays)
	}
	if m.addstatus != nil {
		fields = append(fields, channelcost.FieldStatus)
	}
	if m.addaverage_days != nil {
		fields = append(fields, channelcost.FieldAverageDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelCostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelcost.FieldChannelCostBatchID:
		return m.AddedChannelCostBatchID()
	case channelcost.FieldMode:
		return m.AddedMode()
	case channelcost.FieldStartWeight:
		return m.AddedStartWeight()
	case channelcost.FieldEndWeight:
		return m.AddedEndWeight()
	case channelcost.FieldFirstWeight:
		return m.AddedFirstWeight()
	case channelcost.FieldFirstWeightFee:
		return m.AddedFirstWeightFee()
	case channelcost.FieldUnitWeight:
		return m.AddedUnitWeight()
	case channelcost.FieldUnitWeightFee:
		return m.AddedUnitWeightFee()
	case channelcost.FieldFuelFee:
		return m.AddedFuelFee()
	case channelcost.FieldProcessingFee:
		return m.AddedProcessingFee()
	case channelcost.FieldRegistrationFee:
		return m.AddedRegistrationFee()
	case channelcost.FieldMiscFee:
		return m.AddedMiscFee()
	case channelcost.FieldMinNormalDays:
		return m.AddedMinNormalDays()
	case channelcost.FieldMaxNormalDays:
		return m.AddedMaxNormalDays()
	case channelcost.FieldStatus:
		return m.AddedStatus()
	case channelcost.FieldAverageDays:
		return m.AddedAverageDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelCostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelcost.FieldChannelCostBatchID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelCostBatchID(v)
		return nil
	case channelcost.FieldMode:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMode(v)
		return nil
	case channelcost.FieldStartWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartWeight(v)
		return nil
	case channelcost.FieldEndWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndWeight(v)
		return nil
	case channelcost.FieldFirstWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstWeight(v)
		return nil
	case channelcost.FieldFirstWeightFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstWeightFee(v)
		return nil
	case channelcost.FieldUnitWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitWeight(v)
		return nil
	case channelcost.FieldUnitWeightFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitWeightFee(v)
		return nil
	case channelcost.FieldFuelFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFuelFee(v)
		return nil
	case channelcost.FieldProcessingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessingFee(v)
		return nil
	case channelcost.FieldRegistrationFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegistrationFee(v)
		return nil
	case channelcost.FieldMiscFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMiscFee(v)
		return nil
	case channelcost.FieldMinNormalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinNormalDays(v)
		return nil
	case channelcost.FieldMaxNormalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxNormalDays(v)
		return nil
	case channelcost.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case channelcost.FieldAverageDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageDays(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelCost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelCostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelcost.FieldDeletedAt) {
		fields = append(fields, channelcost.FieldDeletedAt)
	}
	if m.FieldCleared(channelcost.FieldChannelID) {
		fields = append(fields, channelcost.FieldChannelID)
	}
	if m.FieldCleared(channelcost.FieldUnitWeightFee) {
		fields = append(fields, channelcost.FieldUnitWeightFee)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelCostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelCostMutation) ClearField(name string) error {
	switch name {
	case channelcost.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case channelcost.FieldChannelID:
		m.ClearChannelID()
		return nil
	case channelcost.FieldUnitWeightFee:
		m.ClearUnitWeightFee()
		return nil
	}
	return fmt.Errorf("unknown ChannelCost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelCostMutation) ResetField(name string) error {
	switch name {
	case channelcost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelcost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelcost.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channelcost.FieldChannelCostBatchID:
		m.ResetChannelCostBatchID()
		return nil
	case channelcost.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelcost.FieldMode:
		m.ResetMode()
		return nil
	case channelcost.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case channelcost.FieldZone:
		m.ResetZone()
		return nil
	case channelcost.FieldStartWeight:
		m.ResetStartWeight()
		return nil
	case channelcost.FieldEndWeight:
		m.ResetEndWeight()
		return nil
	case channelcost.FieldFirstWeight:
		m.ResetFirstWeight()
		return nil
	case channelcost.FieldFirstWeightFee:
		m.ResetFirstWeightFee()
		return nil
	case channelcost.FieldUnitWeight:
		m.ResetUnitWeight()
		return nil
	case channelcost.FieldUnitWeightFee:
		m.ResetUnitWeightFee()
		return nil
	case channelcost.FieldFuelFee:
		m.ResetFuelFee()
		return nil
	case channelcost.FieldProcessingFee:
		m.ResetProcessingFee()
		return nil
	case channelcost.FieldRegistrationFee:
		m.ResetRegistrationFee()
		return nil
	case channelcost.FieldMiscFee:
		m.ResetMiscFee()
		return nil
	case channelcost.FieldMinNormalDays:
		m.ResetMinNormalDays()
		return nil
	case channelcost.FieldMaxNormalDays:
		m.ResetMaxNormalDays()
		return nil
	case channelcost.FieldStatus:
		m.ResetStatus()
		return nil
	case channelcost.FieldAverageDays:
		m.ResetAverageDays()
		return nil
	}
	return fmt.Errorf("unknown ChannelCost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelCostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.channels != nil {
		edges = append(edges, channelcost.EdgeChannels)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelCostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelcost.EdgeChannels:
		if id := m.channels; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelCostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelCostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelCostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchannels {
		edges = append(edges, channelcost.EdgeChannels)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelCostMutation) EdgeCleared(name string) bool {
	switch name {
	case channelcost.EdgeChannels:
		return m.clearedchannels
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelCostMutation) ClearEdge(name string) error {
	switch name {
	case channelcost.EdgeChannels:
		m.ClearChannels()
		return nil
	}
	return fmt.Errorf("unknown ChannelCost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelCostMutation) ResetEdge(name string) error {
	switch name {
	case channelcost.EdgeChannels:
		m.ResetChannels()
		return nil
	}
	return fmt.Errorf("unknown ChannelCost edge %s", name)
}

// ChannelCostBatcheMutation represents an operation that mutates the ChannelCostBatche nodes in the graph.
type ChannelCostBatcheMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	channel_id     *int64
	addchannel_id  *int64
	effective_date *time.Time
	expiry_date    *time.Time
	status         *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ChannelCostBatche, error)
	predicates     []predicate.ChannelCostBatche
}

var _ ent.Mutation = (*ChannelCostBatcheMutation)(nil)

// channelcostbatcheOption allows management of the mutation configuration using functional options.
type channelcostbatcheOption func(*ChannelCostBatcheMutation)

// newChannelCostBatcheMutation creates new mutation for the ChannelCostBatche entity.
func newChannelCostBatcheMutation(c config, op Op, opts ...channelcostbatcheOption) *ChannelCostBatcheMutation {
	m := &ChannelCostBatcheMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelCostBatche,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelCostBatcheID sets the ID field of the mutation.
func withChannelCostBatcheID(id int64) channelcostbatcheOption {
	return func(m *ChannelCostBatcheMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelCostBatche
		)
		m.oldValue = func(ctx context.Context) (*ChannelCostBatche, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelCostBatche.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelCostBatche sets the old ChannelCostBatche of the mutation.
func withChannelCostBatche(node *ChannelCostBatche) channelcostbatcheOption {
	return func(m *ChannelCostBatcheMutation) {
		m.oldValue = func(context.Context) (*ChannelCostBatche, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelCostBatcheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelCostBatcheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelCostBatche entities.
func (m *ChannelCostBatcheMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelCostBatcheMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelCostBatcheMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelCostBatche.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelCostBatcheMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelCostBatcheMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelCostBatche entity.
// If the ChannelCostBatche object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostBatcheMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelCostBatcheMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelCostBatcheMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelCostBatcheMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelCostBatche entity.
// If the ChannelCostBatche object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostBatcheMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelCostBatcheMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelCostBatcheMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelCostBatcheMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelCostBatche entity.
// If the ChannelCostBatche object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostBatcheMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *ChannelCostBatcheMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *ChannelCostBatcheMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelCostBatcheMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetEffectiveDate sets the "effective_date" field.
func (m *ChannelCostBatcheMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *ChannelCostBatcheMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the ChannelCostBatche entity.
// If the ChannelCostBatche object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostBatcheMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *ChannelCostBatcheMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[channelcostbatche.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *ChannelCostBatcheMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[channelcostbatche.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *ChannelCostBatcheMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, channelcostbatche.FieldEffectiveDate)
}

// SetExpiryDate sets the "expiry_date" field.
func (m *ChannelCostBatcheMutation) SetExpiryDate(t time.Time) {
	m.expiry_date = &t
}

// ExpiryDate returns the value of the "expiry_date" field in the mutation.
func (m *ChannelCostBatcheMutation) ExpiryDate() (r time.Time, exists bool) {
	v := m.expiry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryDate returns the old "expiry_date" field's value of the ChannelCostBatche entity.
// If the ChannelCostBatche object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostBatcheMutation) OldExpiryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryDate: %w", err)
	}
	return oldValue.ExpiryDate, nil
}

// ClearExpiryDate clears the value of the "expiry_date" field.
func (m *ChannelCostBatcheMutation) ClearExpiryDate() {
	m.expiry_date = nil
	m.clearedFields[channelcostbatche.FieldExpiryDate] = struct{}{}
}

// ExpiryDateCleared returns if the "expiry_date" field was cleared in this mutation.
func (m *ChannelCostBatcheMutation) ExpiryDateCleared() bool {
	_, ok := m.clearedFields[channelcostbatche.FieldExpiryDate]
	return ok
}

// ResetExpiryDate resets all changes to the "expiry_date" field.
func (m *ChannelCostBatcheMutation) ResetExpiryDate() {
	m.expiry_date = nil
	delete(m.clearedFields, channelcostbatche.FieldExpiryDate)
}

// SetStatus sets the "status" field.
func (m *ChannelCostBatcheMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelCostBatcheMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChannelCostBatche entity.
// If the ChannelCostBatche object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelCostBatcheMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelCostBatcheMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ChannelCostBatcheMutation builder.
func (m *ChannelCostBatcheMutation) Where(ps ...predicate.ChannelCostBatche) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelCostBatcheMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ChannelCostBatche).
func (m *ChannelCostBatcheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelCostBatcheMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, channelcostbatche.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelcostbatche.FieldUpdatedAt)
	}
	if m.channel_id != nil {
		fields = append(fields, channelcostbatche.FieldChannelID)
	}
	if m.effective_date != nil {
		fields = append(fields, channelcostbatche.FieldEffectiveDate)
	}
	if m.expiry_date != nil {
		fields = append(fields, channelcostbatche.FieldExpiryDate)
	}
	if m.status != nil {
		fields = append(fields, channelcostbatche.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelCostBatcheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelcostbatche.FieldCreatedAt:
		return m.CreatedAt()
	case channelcostbatche.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelcostbatche.FieldChannelID:
		return m.ChannelID()
	case channelcostbatche.FieldEffectiveDate:
		return m.EffectiveDate()
	case channelcostbatche.FieldExpiryDate:
		return m.ExpiryDate()
	case channelcostbatche.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelCostBatcheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelcostbatche.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelcostbatche.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelcostbatche.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelcostbatche.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case channelcostbatche.FieldExpiryDate:
		return m.OldExpiryDate(ctx)
	case channelcostbatche.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelCostBatche field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelCostBatcheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelcostbatche.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelcostbatche.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelcostbatche.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelcostbatche.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case channelcostbatche.FieldExpiryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryDate(v)
		return nil
	case channelcostbatche.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelCostBatche field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelCostBatcheMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, channelcostbatche.FieldChannelID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelCostBatcheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelcostbatche.FieldChannelID:
		return m.AddedChannelID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelCostBatcheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelcostbatche.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelCostBatche numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelCostBatcheMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelcostbatche.FieldEffectiveDate) {
		fields = append(fields, channelcostbatche.FieldEffectiveDate)
	}
	if m.FieldCleared(channelcostbatche.FieldExpiryDate) {
		fields = append(fields, channelcostbatche.FieldExpiryDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelCostBatcheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelCostBatcheMutation) ClearField(name string) error {
	switch name {
	case channelcostbatche.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case channelcostbatche.FieldExpiryDate:
		m.ClearExpiryDate()
		return nil
	}
	return fmt.Errorf("unknown ChannelCostBatche nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelCostBatcheMutation) ResetField(name string) error {
	switch name {
	case channelcostbatche.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelcostbatche.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelcostbatche.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelcostbatche.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case channelcostbatche.FieldExpiryDate:
		m.ResetExpiryDate()
		return nil
	case channelcostbatche.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ChannelCostBatche field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelCostBatcheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelCostBatcheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelCostBatcheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelCostBatcheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelCostBatcheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelCostBatcheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelCostBatcheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChannelCostBatche unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelCostBatcheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChannelCostBatche edge %s", name)
}

// ChannelOptionMutation represents an operation that mutates the ChannelOption nodes in the graph.
type ChannelOptionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	order_id      *int64
	addorder_id   *int64
	channel_id    *int64
	addchannel_id *int64
	country_code  *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ChannelOption, error)
	predicates    []predicate.ChannelOption
}

var _ ent.Mutation = (*ChannelOptionMutation)(nil)

// channeloptionOption allows management of the mutation configuration using functional options.
type channeloptionOption func(*ChannelOptionMutation)

// newChannelOptionMutation creates new mutation for the ChannelOption entity.
func newChannelOptionMutation(c config, op Op, opts ...channeloptionOption) *ChannelOptionMutation {
	m := &ChannelOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelOptionID sets the ID field of the mutation.
func withChannelOptionID(id int64) channeloptionOption {
	return func(m *ChannelOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelOption
		)
		m.oldValue = func(ctx context.Context) (*ChannelOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelOption sets the old ChannelOption of the mutation.
func withChannelOption(node *ChannelOption) channeloptionOption {
	return func(m *ChannelOptionMutation) {
		m.oldValue = func(context.Context) (*ChannelOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelOption entities.
func (m *ChannelOptionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelOptionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelOptionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *ChannelOptionMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *ChannelOptionMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the ChannelOption entity.
// If the ChannelOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOptionMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *ChannelOptionMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *ChannelOptionMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *ChannelOptionMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelOptionMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelOptionMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelOption entity.
// If the ChannelOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOptionMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *ChannelOptionMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *ChannelOptionMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelOptionMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetCountryCode sets the "country_code" field.
func (m *ChannelOptionMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ChannelOptionMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the ChannelOption entity.
// If the ChannelOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOptionMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ChannelOptionMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelOptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelOption entity.
// If the ChannelOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelOptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelOptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelOption entity.
// If the ChannelOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelOptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelOptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelOptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelOption entity.
// If the ChannelOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelOptionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelOptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channeloption.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelOptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channeloption.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelOptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channeloption.FieldDeletedAt)
}

// Where appends a list predicates to the ChannelOptionMutation builder.
func (m *ChannelOptionMutation) Where(ps ...predicate.ChannelOption) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelOptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ChannelOption).
func (m *ChannelOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelOptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.order_id != nil {
		fields = append(fields, channeloption.FieldOrderID)
	}
	if m.channel_id != nil {
		fields = append(fields, channeloption.FieldChannelID)
	}
	if m.country_code != nil {
		fields = append(fields, channeloption.FieldCountryCode)
	}
	if m.created_at != nil {
		fields = append(fields, channeloption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channeloption.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channeloption.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channeloption.FieldOrderID:
		return m.OrderID()
	case channeloption.FieldChannelID:
		return m.ChannelID()
	case channeloption.FieldCountryCode:
		return m.CountryCode()
	case channeloption.FieldCreatedAt:
		return m.CreatedAt()
	case channeloption.FieldUpdatedAt:
		return m.UpdatedAt()
	case channeloption.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channeloption.FieldOrderID:
		return m.OldOrderID(ctx)
	case channeloption.FieldChannelID:
		return m.OldChannelID(ctx)
	case channeloption.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case channeloption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channeloption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channeloption.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channeloption.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case channeloption.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channeloption.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case channeloption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channeloption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channeloption.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelOptionMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, channeloption.FieldOrderID)
	}
	if m.addchannel_id != nil {
		fields = append(fields, channeloption.FieldChannelID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channeloption.FieldOrderID:
		return m.AddedOrderID()
	case channeloption.FieldChannelID:
		return m.AddedChannelID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channeloption.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case channeloption.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channeloption.FieldDeletedAt) {
		fields = append(fields, channeloption.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelOptionMutation) ClearField(name string) error {
	switch name {
	case channeloption.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelOptionMutation) ResetField(name string) error {
	switch name {
	case channeloption.FieldOrderID:
		m.ResetOrderID()
		return nil
	case channeloption.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channeloption.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case channeloption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channeloption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channeloption.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelOptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelOptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelOptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChannelOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelOptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChannelOption edge %s", name)
}

// ChannelRecommendMutation represents an operation that mutates the ChannelRecommend nodes in the graph.
type ChannelRecommendMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	country_code      *string
	channel_id        *int64
	addchannel_id     *int64
	is_recommended    *int8
	addis_recommended *int8
	status            *int8
	addstatus         *int8
	value             *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ChannelRecommend, error)
	predicates        []predicate.ChannelRecommend
}

var _ ent.Mutation = (*ChannelRecommendMutation)(nil)

// channelrecommendOption allows management of the mutation configuration using functional options.
type channelrecommendOption func(*ChannelRecommendMutation)

// newChannelRecommendMutation creates new mutation for the ChannelRecommend entity.
func newChannelRecommendMutation(c config, op Op, opts ...channelrecommendOption) *ChannelRecommendMutation {
	m := &ChannelRecommendMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelRecommend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelRecommendID sets the ID field of the mutation.
func withChannelRecommendID(id int64) channelrecommendOption {
	return func(m *ChannelRecommendMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelRecommend
		)
		m.oldValue = func(ctx context.Context) (*ChannelRecommend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelRecommend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelRecommend sets the old ChannelRecommend of the mutation.
func withChannelRecommend(node *ChannelRecommend) channelrecommendOption {
	return func(m *ChannelRecommendMutation) {
		m.oldValue = func(context.Context) (*ChannelRecommend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelRecommendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelRecommendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelRecommend entities.
func (m *ChannelRecommendMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelRecommendMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelRecommendMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelRecommend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelRecommendMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelRecommendMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelRecommendMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelRecommendMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelRecommendMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelRecommendMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelRecommendMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelRecommendMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelRecommendMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channelrecommend.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelRecommendMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channelrecommend.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelRecommendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channelrecommend.FieldDeletedAt)
}

// SetCountryCode sets the "country_code" field.
func (m *ChannelRecommendMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ChannelRecommendMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ChannelRecommendMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelRecommendMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelRecommendMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *ChannelRecommendMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *ChannelRecommendMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelRecommendMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetIsRecommended sets the "is_recommended" field.
func (m *ChannelRecommendMutation) SetIsRecommended(i int8) {
	m.is_recommended = &i
	m.addis_recommended = nil
}

// IsRecommended returns the value of the "is_recommended" field in the mutation.
func (m *ChannelRecommendMutation) IsRecommended() (r int8, exists bool) {
	v := m.is_recommended
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecommended returns the old "is_recommended" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldIsRecommended(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecommended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecommended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecommended: %w", err)
	}
	return oldValue.IsRecommended, nil
}

// AddIsRecommended adds i to the "is_recommended" field.
func (m *ChannelRecommendMutation) AddIsRecommended(i int8) {
	if m.addis_recommended != nil {
		*m.addis_recommended += i
	} else {
		m.addis_recommended = &i
	}
}

// AddedIsRecommended returns the value that was added to the "is_recommended" field in this mutation.
func (m *ChannelRecommendMutation) AddedIsRecommended() (r int8, exists bool) {
	v := m.addis_recommended
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsRecommended resets all changes to the "is_recommended" field.
func (m *ChannelRecommendMutation) ResetIsRecommended() {
	m.is_recommended = nil
	m.addis_recommended = nil
}

// SetStatus sets the "status" field.
func (m *ChannelRecommendMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelRecommendMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ChannelRecommendMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ChannelRecommendMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelRecommendMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetValue sets the "value" field.
func (m *ChannelRecommendMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ChannelRecommendMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ChannelRecommend entity.
// If the ChannelRecommend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelRecommendMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ChannelRecommendMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the ChannelRecommendMutation builder.
func (m *ChannelRecommendMutation) Where(ps ...predicate.ChannelRecommend) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelRecommendMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ChannelRecommend).
func (m *ChannelRecommendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelRecommendMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, channelrecommend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelrecommend.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channelrecommend.FieldDeletedAt)
	}
	if m.country_code != nil {
		fields = append(fields, channelrecommend.FieldCountryCode)
	}
	if m.channel_id != nil {
		fields = append(fields, channelrecommend.FieldChannelID)
	}
	if m.is_recommended != nil {
		fields = append(fields, channelrecommend.FieldIsRecommended)
	}
	if m.status != nil {
		fields = append(fields, channelrecommend.FieldStatus)
	}
	if m.value != nil {
		fields = append(fields, channelrecommend.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelRecommendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelrecommend.FieldCreatedAt:
		return m.CreatedAt()
	case channelrecommend.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelrecommend.FieldDeletedAt:
		return m.DeletedAt()
	case channelrecommend.FieldCountryCode:
		return m.CountryCode()
	case channelrecommend.FieldChannelID:
		return m.ChannelID()
	case channelrecommend.FieldIsRecommended:
		return m.IsRecommended()
	case channelrecommend.FieldStatus:
		return m.Status()
	case channelrecommend.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelRecommendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelrecommend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelrecommend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelrecommend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channelrecommend.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case channelrecommend.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelrecommend.FieldIsRecommended:
		return m.OldIsRecommended(ctx)
	case channelrecommend.FieldStatus:
		return m.OldStatus(ctx)
	case channelrecommend.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelRecommend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelRecommendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelrecommend.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelrecommend.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelrecommend.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channelrecommend.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case channelrecommend.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelrecommend.FieldIsRecommended:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecommended(v)
		return nil
	case channelrecommend.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channelrecommend.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelRecommend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelRecommendMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, channelrecommend.FieldChannelID)
	}
	if m.addis_recommended != nil {
		fields = append(fields, channelrecommend.FieldIsRecommended)
	}
	if m.addstatus != nil {
		fields = append(fields, channelrecommend.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelRecommendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelrecommend.FieldChannelID:
		return m.AddedChannelID()
	case channelrecommend.FieldIsRecommended:
		return m.AddedIsRecommended()
	case channelrecommend.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelRecommendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelrecommend.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	case channelrecommend.FieldIsRecommended:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsRecommended(v)
		return nil
	case channelrecommend.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelRecommend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelRecommendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelrecommend.FieldDeletedAt) {
		fields = append(fields, channelrecommend.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelRecommendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelRecommendMutation) ClearField(name string) error {
	switch name {
	case channelrecommend.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelRecommend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelRecommendMutation) ResetField(name string) error {
	switch name {
	case channelrecommend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelrecommend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelrecommend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channelrecommend.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case channelrecommend.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelrecommend.FieldIsRecommended:
		m.ResetIsRecommended()
		return nil
	case channelrecommend.FieldStatus:
		m.ResetStatus()
		return nil
	case channelrecommend.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown ChannelRecommend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelRecommendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelRecommendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelRecommendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelRecommendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelRecommendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelRecommendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelRecommendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChannelRecommend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelRecommendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChannelRecommend edge %s", name)
}

// ChannelVolumeFactorMutation represents an operation that mutates the ChannelVolumeFactor nodes in the graph.
type ChannelVolumeFactorMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	country_code     *string
	channel_id       *int64
	addchannel_id    *int64
	volume_factor    *int
	addvolume_factor *int
	status           *int8
	addstatus        *int8
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ChannelVolumeFactor, error)
	predicates       []predicate.ChannelVolumeFactor
}

var _ ent.Mutation = (*ChannelVolumeFactorMutation)(nil)

// channelvolumefactorOption allows management of the mutation configuration using functional options.
type channelvolumefactorOption func(*ChannelVolumeFactorMutation)

// newChannelVolumeFactorMutation creates new mutation for the ChannelVolumeFactor entity.
func newChannelVolumeFactorMutation(c config, op Op, opts ...channelvolumefactorOption) *ChannelVolumeFactorMutation {
	m := &ChannelVolumeFactorMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelVolumeFactor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelVolumeFactorID sets the ID field of the mutation.
func withChannelVolumeFactorID(id int64) channelvolumefactorOption {
	return func(m *ChannelVolumeFactorMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelVolumeFactor
		)
		m.oldValue = func(ctx context.Context) (*ChannelVolumeFactor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelVolumeFactor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelVolumeFactor sets the old ChannelVolumeFactor of the mutation.
func withChannelVolumeFactor(node *ChannelVolumeFactor) channelvolumefactorOption {
	return func(m *ChannelVolumeFactorMutation) {
		m.oldValue = func(context.Context) (*ChannelVolumeFactor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelVolumeFactorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelVolumeFactorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelVolumeFactor entities.
func (m *ChannelVolumeFactorMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelVolumeFactorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelVolumeFactorMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelVolumeFactor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelVolumeFactorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelVolumeFactorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelVolumeFactorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelVolumeFactorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelVolumeFactorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelVolumeFactorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelVolumeFactorMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelVolumeFactorMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelVolumeFactorMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channelvolumefactor.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelVolumeFactorMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channelvolumefactor.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelVolumeFactorMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channelvolumefactor.FieldDeletedAt)
}

// SetCountryCode sets the "country_code" field.
func (m *ChannelVolumeFactorMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ChannelVolumeFactorMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ChannelVolumeFactorMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetChannelID sets the "channel_id" field.
func (m *ChannelVolumeFactorMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *ChannelVolumeFactorMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *ChannelVolumeFactorMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *ChannelVolumeFactorMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *ChannelVolumeFactorMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetVolumeFactor sets the "volume_factor" field.
func (m *ChannelVolumeFactorMutation) SetVolumeFactor(i int) {
	m.volume_factor = &i
	m.addvolume_factor = nil
}

// VolumeFactor returns the value of the "volume_factor" field in the mutation.
func (m *ChannelVolumeFactorMutation) VolumeFactor() (r int, exists bool) {
	v := m.volume_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeFactor returns the old "volume_factor" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldVolumeFactor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeFactor: %w", err)
	}
	return oldValue.VolumeFactor, nil
}

// AddVolumeFactor adds i to the "volume_factor" field.
func (m *ChannelVolumeFactorMutation) AddVolumeFactor(i int) {
	if m.addvolume_factor != nil {
		*m.addvolume_factor += i
	} else {
		m.addvolume_factor = &i
	}
}

// AddedVolumeFactor returns the value that was added to the "volume_factor" field in this mutation.
func (m *ChannelVolumeFactorMutation) AddedVolumeFactor() (r int, exists bool) {
	v := m.addvolume_factor
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolumeFactor resets all changes to the "volume_factor" field.
func (m *ChannelVolumeFactorMutation) ResetVolumeFactor() {
	m.volume_factor = nil
	m.addvolume_factor = nil
}

// SetStatus sets the "status" field.
func (m *ChannelVolumeFactorMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelVolumeFactorMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChannelVolumeFactor entity.
// If the ChannelVolumeFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelVolumeFactorMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ChannelVolumeFactorMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ChannelVolumeFactorMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelVolumeFactorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the ChannelVolumeFactorMutation builder.
func (m *ChannelVolumeFactorMutation) Where(ps ...predicate.ChannelVolumeFactor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChannelVolumeFactorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ChannelVolumeFactor).
func (m *ChannelVolumeFactorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelVolumeFactorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, channelvolumefactor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelvolumefactor.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channelvolumefactor.FieldDeletedAt)
	}
	if m.country_code != nil {
		fields = append(fields, channelvolumefactor.FieldCountryCode)
	}
	if m.channel_id != nil {
		fields = append(fields, channelvolumefactor.FieldChannelID)
	}
	if m.volume_factor != nil {
		fields = append(fields, channelvolumefactor.FieldVolumeFactor)
	}
	if m.status != nil {
		fields = append(fields, channelvolumefactor.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelVolumeFactorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelvolumefactor.FieldCreatedAt:
		return m.CreatedAt()
	case channelvolumefactor.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelvolumefactor.FieldDeletedAt:
		return m.DeletedAt()
	case channelvolumefactor.FieldCountryCode:
		return m.CountryCode()
	case channelvolumefactor.FieldChannelID:
		return m.ChannelID()
	case channelvolumefactor.FieldVolumeFactor:
		return m.VolumeFactor()
	case channelvolumefactor.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelVolumeFactorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelvolumefactor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelvolumefactor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelvolumefactor.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channelvolumefactor.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case channelvolumefactor.FieldChannelID:
		return m.OldChannelID(ctx)
	case channelvolumefactor.FieldVolumeFactor:
		return m.OldVolumeFactor(ctx)
	case channelvolumefactor.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelVolumeFactor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelVolumeFactorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelvolumefactor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelvolumefactor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelvolumefactor.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channelvolumefactor.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case channelvolumefactor.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case channelvolumefactor.FieldVolumeFactor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeFactor(v)
		return nil
	case channelvolumefactor.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelVolumeFactor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelVolumeFactorMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, channelvolumefactor.FieldChannelID)
	}
	if m.addvolume_factor != nil {
		fields = append(fields, channelvolumefactor.FieldVolumeFactor)
	}
	if m.addstatus != nil {
		fields = append(fields, channelvolumefactor.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelVolumeFactorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channelvolumefactor.FieldChannelID:
		return m.AddedChannelID()
	case channelvolumefactor.FieldVolumeFactor:
		return m.AddedVolumeFactor()
	case channelvolumefactor.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelVolumeFactorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channelvolumefactor.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	case channelvolumefactor.FieldVolumeFactor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolumeFactor(v)
		return nil
	case channelvolumefactor.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelVolumeFactor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelVolumeFactorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelvolumefactor.FieldDeletedAt) {
		fields = append(fields, channelvolumefactor.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelVolumeFactorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelVolumeFactorMutation) ClearField(name string) error {
	switch name {
	case channelvolumefactor.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChannelVolumeFactor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelVolumeFactorMutation) ResetField(name string) error {
	switch name {
	case channelvolumefactor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelvolumefactor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelvolumefactor.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channelvolumefactor.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case channelvolumefactor.FieldChannelID:
		m.ResetChannelID()
		return nil
	case channelvolumefactor.FieldVolumeFactor:
		m.ResetVolumeFactor()
		return nil
	case channelvolumefactor.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ChannelVolumeFactor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelVolumeFactorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelVolumeFactorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelVolumeFactorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelVolumeFactorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelVolumeFactorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelVolumeFactorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelVolumeFactorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChannelVolumeFactor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelVolumeFactorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChannelVolumeFactor edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	cn_name       *string
	en_name       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Country, error)
	predicates    []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetCnName sets the "cn_name" field.
func (m *CountryMutation) SetCnName(s string) {
	m.cn_name = &s
}

// CnName returns the value of the "cn_name" field in the mutation.
func (m *CountryMutation) CnName() (r string, exists bool) {
	v := m.cn_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCnName returns the old "cn_name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCnName: %w", err)
	}
	return oldValue.CnName, nil
}

// ResetCnName resets all changes to the "cn_name" field.
func (m *CountryMutation) ResetCnName() {
	m.cn_name = nil
}

// SetEnName sets the "en_name" field.
func (m *CountryMutation) SetEnName(s string) {
	m.en_name = &s
}

// EnName returns the value of the "en_name" field in the mutation.
func (m *CountryMutation) EnName() (r string, exists bool) {
	v := m.en_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEnName returns the old "en_name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldEnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnName: %w", err)
	}
	return oldValue.EnName, nil
}

// ResetEnName resets all changes to the "en_name" field.
func (m *CountryMutation) ResetEnName() {
	m.en_name = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.cn_name != nil {
		fields = append(fields, country.FieldCnName)
	}
	if m.en_name != nil {
		fields = append(fields, country.FieldEnName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCode:
		return m.Code()
	case country.FieldCnName:
		return m.CnName()
	case country.FieldEnName:
		return m.EnName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldCnName:
		return m.OldCnName(ctx)
	case country.FieldEnName:
		return m.OldEnName(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldCnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCnName(v)
		return nil
	case country.FieldEnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnName(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldCnName:
		m.ResetCnName()
		return nil
	case country.FieldEnName:
		m.ResetEnName()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Country edge %s", name)
}

// CountryZoneMutation represents an operation that mutates the CountryZone nodes in the graph.
type CountryZoneMutation struct {
	config
	op             Op
	typ            string
	id             *int
	channel_id     *int64
	addchannel_id  *int64
	country_code   *string
	zip_code       *string
	start_zip_code *string
	end_zip_code   *string
	zone           *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CountryZone, error)
	predicates     []predicate.CountryZone
}

var _ ent.Mutation = (*CountryZoneMutation)(nil)

// countryzoneOption allows management of the mutation configuration using functional options.
type countryzoneOption func(*CountryZoneMutation)

// newCountryZoneMutation creates new mutation for the CountryZone entity.
func newCountryZoneMutation(c config, op Op, opts ...countryzoneOption) *CountryZoneMutation {
	m := &CountryZoneMutation{
		config:        c,
		op:            op,
		typ:           TypeCountryZone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryZoneID sets the ID field of the mutation.
func withCountryZoneID(id int) countryzoneOption {
	return func(m *CountryZoneMutation) {
		var (
			err   error
			once  sync.Once
			value *CountryZone
		)
		m.oldValue = func(ctx context.Context) (*CountryZone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CountryZone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountryZone sets the old CountryZone of the mutation.
func withCountryZone(node *CountryZone) countryzoneOption {
	return func(m *CountryZoneMutation) {
		m.oldValue = func(context.Context) (*CountryZone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryZoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryZoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryZoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryZoneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CountryZone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChannelID sets the "channel_id" field.
func (m *CountryZoneMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *CountryZoneMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the CountryZone entity.
// If the CountryZone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryZoneMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *CountryZoneMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *CountryZoneMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *CountryZoneMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetCountryCode sets the "country_code" field.
func (m *CountryZoneMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *CountryZoneMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the CountryZone entity.
// If the CountryZone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryZoneMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *CountryZoneMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetZipCode sets the "zip_code" field.
func (m *CountryZoneMutation) SetZipCode(s string) {
	m.zip_code = &s
}

// ZipCode returns the value of the "zip_code" field in the mutation.
func (m *CountryZoneMutation) ZipCode() (r string, exists bool) {
	v := m.zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "zip_code" field's value of the CountryZone entity.
// If the CountryZone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryZoneMutation) OldZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ResetZipCode resets all changes to the "zip_code" field.
func (m *CountryZoneMutation) ResetZipCode() {
	m.zip_code = nil
}

// SetStartZipCode sets the "start_zip_code" field.
func (m *CountryZoneMutation) SetStartZipCode(s string) {
	m.start_zip_code = &s
}

// StartZipCode returns the value of the "start_zip_code" field in the mutation.
func (m *CountryZoneMutation) StartZipCode() (r string, exists bool) {
	v := m.start_zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStartZipCode returns the old "start_zip_code" field's value of the CountryZone entity.
// If the CountryZone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryZoneMutation) OldStartZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartZipCode: %w", err)
	}
	return oldValue.StartZipCode, nil
}

// ResetStartZipCode resets all changes to the "start_zip_code" field.
func (m *CountryZoneMutation) ResetStartZipCode() {
	m.start_zip_code = nil
}

// SetEndZipCode sets the "end_zip_code" field.
func (m *CountryZoneMutation) SetEndZipCode(s string) {
	m.end_zip_code = &s
}

// EndZipCode returns the value of the "end_zip_code" field in the mutation.
func (m *CountryZoneMutation) EndZipCode() (r string, exists bool) {
	v := m.end_zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldEndZipCode returns the old "end_zip_code" field's value of the CountryZone entity.
// If the CountryZone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryZoneMutation) OldEndZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndZipCode: %w", err)
	}
	return oldValue.EndZipCode, nil
}

// ResetEndZipCode resets all changes to the "end_zip_code" field.
func (m *CountryZoneMutation) ResetEndZipCode() {
	m.end_zip_code = nil
}

// SetZone sets the "zone" field.
func (m *CountryZoneMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the value of the "zone" field in the mutation.
func (m *CountryZoneMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old "zone" field's value of the CountryZone entity.
// If the CountryZone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryZoneMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ResetZone resets all changes to the "zone" field.
func (m *CountryZoneMutation) ResetZone() {
	m.zone = nil
}

// Where appends a list predicates to the CountryZoneMutation builder.
func (m *CountryZoneMutation) Where(ps ...predicate.CountryZone) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CountryZoneMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CountryZone).
func (m *CountryZoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryZoneMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.channel_id != nil {
		fields = append(fields, countryzone.FieldChannelID)
	}
	if m.country_code != nil {
		fields = append(fields, countryzone.FieldCountryCode)
	}
	if m.zip_code != nil {
		fields = append(fields, countryzone.FieldZipCode)
	}
	if m.start_zip_code != nil {
		fields = append(fields, countryzone.FieldStartZipCode)
	}
	if m.end_zip_code != nil {
		fields = append(fields, countryzone.FieldEndZipCode)
	}
	if m.zone != nil {
		fields = append(fields, countryzone.FieldZone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryZoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case countryzone.FieldChannelID:
		return m.ChannelID()
	case countryzone.FieldCountryCode:
		return m.CountryCode()
	case countryzone.FieldZipCode:
		return m.ZipCode()
	case countryzone.FieldStartZipCode:
		return m.StartZipCode()
	case countryzone.FieldEndZipCode:
		return m.EndZipCode()
	case countryzone.FieldZone:
		return m.Zone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryZoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case countryzone.FieldChannelID:
		return m.OldChannelID(ctx)
	case countryzone.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case countryzone.FieldZipCode:
		return m.OldZipCode(ctx)
	case countryzone.FieldStartZipCode:
		return m.OldStartZipCode(ctx)
	case countryzone.FieldEndZipCode:
		return m.OldEndZipCode(ctx)
	case countryzone.FieldZone:
		return m.OldZone(ctx)
	}
	return nil, fmt.Errorf("unknown CountryZone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryZoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case countryzone.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case countryzone.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case countryzone.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case countryzone.FieldStartZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartZipCode(v)
		return nil
	case countryzone.FieldEndZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndZipCode(v)
		return nil
	case countryzone.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	}
	return fmt.Errorf("unknown CountryZone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryZoneMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, countryzone.FieldChannelID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryZoneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case countryzone.FieldChannelID:
		return m.AddedChannelID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryZoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case countryzone.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	}
	return fmt.Errorf("unknown CountryZone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryZoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryZoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryZoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CountryZone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryZoneMutation) ResetField(name string) error {
	switch name {
	case countryzone.FieldChannelID:
		m.ResetChannelID()
		return nil
	case countryzone.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case countryzone.FieldZipCode:
		m.ResetZipCode()
		return nil
	case countryzone.FieldStartZipCode:
		m.ResetStartZipCode()
		return nil
	case countryzone.FieldEndZipCode:
		m.ResetEndZipCode()
		return nil
	case countryzone.FieldZone:
		m.ResetZone()
		return nil
	}
	return fmt.Errorf("unknown CountryZone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryZoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryZoneMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryZoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryZoneMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryZoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryZoneMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryZoneMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CountryZone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryZoneMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CountryZone edge %s", name)
}

// CourierOrderMutation represents an operation that mutates the CourierOrder nodes in the graph.
type CourierOrderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	order_id             *int64
	addorder_id          *int64
	order_number         *string
	courier_platform     *string
	shipping_method_code *string
	shipping_method_name *string
	tracking_url         *string
	tracking_number      *string
	waybill_number       *string
	courier_order_number *string
	shipping_label_url   *string
	total_items_price    *float64
	addtotal_items_price *float64
	currency             *string
	package_count        *int
	addpackage_count     *int
	weight               *int
	addweight            *int
	receiver_address     *string
	sender_address       *string
	items                *string
	request_data         *string
	response_data        *string
	result_code          *string
	message              *string
	en_message           *string
	status               *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*CourierOrder, error)
	predicates           []predicate.CourierOrder
}

var _ ent.Mutation = (*CourierOrderMutation)(nil)

// courierorderOption allows management of the mutation configuration using functional options.
type courierorderOption func(*CourierOrderMutation)

// newCourierOrderMutation creates new mutation for the CourierOrder entity.
func newCourierOrderMutation(c config, op Op, opts ...courierorderOption) *CourierOrderMutation {
	m := &CourierOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeCourierOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourierOrderID sets the ID field of the mutation.
func withCourierOrderID(id int64) courierorderOption {
	return func(m *CourierOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *CourierOrder
		)
		m.oldValue = func(ctx context.Context) (*CourierOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CourierOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourierOrder sets the old CourierOrder of the mutation.
func withCourierOrder(node *CourierOrder) courierorderOption {
	return func(m *CourierOrderMutation) {
		m.oldValue = func(context.Context) (*CourierOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourierOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourierOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CourierOrder entities.
func (m *CourierOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourierOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourierOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CourierOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CourierOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourierOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourierOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourierOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourierOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourierOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CourierOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CourierOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CourierOrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[courierorder.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CourierOrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CourierOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, courierorder.FieldDeletedAt)
}

// SetOrderID sets the "order_id" field.
func (m *CourierOrderMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CourierOrderMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *CourierOrderMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *CourierOrderMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CourierOrderMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetOrderNumber sets the "order_number" field.
func (m *CourierOrderMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *CourierOrderMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *CourierOrderMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetCourierPlatform sets the "courier_platform" field.
func (m *CourierOrderMutation) SetCourierPlatform(s string) {
	m.courier_platform = &s
}

// CourierPlatform returns the value of the "courier_platform" field in the mutation.
func (m *CourierOrderMutation) CourierPlatform() (r string, exists bool) {
	v := m.courier_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierPlatform returns the old "courier_platform" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldCourierPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourierPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourierPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierPlatform: %w", err)
	}
	return oldValue.CourierPlatform, nil
}

// ResetCourierPlatform resets all changes to the "courier_platform" field.
func (m *CourierOrderMutation) ResetCourierPlatform() {
	m.courier_platform = nil
}

// SetShippingMethodCode sets the "shipping_method_code" field.
func (m *CourierOrderMutation) SetShippingMethodCode(s string) {
	m.shipping_method_code = &s
}

// ShippingMethodCode returns the value of the "shipping_method_code" field in the mutation.
func (m *CourierOrderMutation) ShippingMethodCode() (r string, exists bool) {
	v := m.shipping_method_code
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingMethodCode returns the old "shipping_method_code" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldShippingMethodCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingMethodCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingMethodCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingMethodCode: %w", err)
	}
	return oldValue.ShippingMethodCode, nil
}

// ResetShippingMethodCode resets all changes to the "shipping_method_code" field.
func (m *CourierOrderMutation) ResetShippingMethodCode() {
	m.shipping_method_code = nil
}

// SetShippingMethodName sets the "shipping_method_name" field.
func (m *CourierOrderMutation) SetShippingMethodName(s string) {
	m.shipping_method_name = &s
}

// ShippingMethodName returns the value of the "shipping_method_name" field in the mutation.
func (m *CourierOrderMutation) ShippingMethodName() (r string, exists bool) {
	v := m.shipping_method_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingMethodName returns the old "shipping_method_name" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldShippingMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingMethodName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingMethodName: %w", err)
	}
	return oldValue.ShippingMethodName, nil
}

// ResetShippingMethodName resets all changes to the "shipping_method_name" field.
func (m *CourierOrderMutation) ResetShippingMethodName() {
	m.shipping_method_name = nil
}

// SetTrackingURL sets the "tracking_url" field.
func (m *CourierOrderMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *CourierOrderMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *CourierOrderMutation) ResetTrackingURL() {
	m.tracking_url = nil
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *CourierOrderMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *CourierOrderMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *CourierOrderMutation) ResetTrackingNumber() {
	m.tracking_number = nil
}

// SetWaybillNumber sets the "waybill_number" field.
func (m *CourierOrderMutation) SetWaybillNumber(s string) {
	m.waybill_number = &s
}

// WaybillNumber returns the value of the "waybill_number" field in the mutation.
func (m *CourierOrderMutation) WaybillNumber() (r string, exists bool) {
	v := m.waybill_number
	if v == nil {
		return
	}
	return *v, true
}

// OldWaybillNumber returns the old "waybill_number" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldWaybillNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaybillNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaybillNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaybillNumber: %w", err)
	}
	return oldValue.WaybillNumber, nil
}

// ResetWaybillNumber resets all changes to the "waybill_number" field.
func (m *CourierOrderMutation) ResetWaybillNumber() {
	m.waybill_number = nil
}

// SetCourierOrderNumber sets the "courier_order_number" field.
func (m *CourierOrderMutation) SetCourierOrderNumber(s string) {
	m.courier_order_number = &s
}

// CourierOrderNumber returns the value of the "courier_order_number" field in the mutation.
func (m *CourierOrderMutation) CourierOrderNumber() (r string, exists bool) {
	v := m.courier_order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierOrderNumber returns the old "courier_order_number" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldCourierOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourierOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourierOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierOrderNumber: %w", err)
	}
	return oldValue.CourierOrderNumber, nil
}

// ResetCourierOrderNumber resets all changes to the "courier_order_number" field.
func (m *CourierOrderMutation) ResetCourierOrderNumber() {
	m.courier_order_number = nil
}

// SetShippingLabelURL sets the "shipping_label_url" field.
func (m *CourierOrderMutation) SetShippingLabelURL(s string) {
	m.shipping_label_url = &s
}

// ShippingLabelURL returns the value of the "shipping_label_url" field in the mutation.
func (m *CourierOrderMutation) ShippingLabelURL() (r string, exists bool) {
	v := m.shipping_label_url
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingLabelURL returns the old "shipping_label_url" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldShippingLabelURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingLabelURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingLabelURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingLabelURL: %w", err)
	}
	return oldValue.ShippingLabelURL, nil
}

// ResetShippingLabelURL resets all changes to the "shipping_label_url" field.
func (m *CourierOrderMutation) ResetShippingLabelURL() {
	m.shipping_label_url = nil
}

// SetTotalItemsPrice sets the "total_items_price" field.
func (m *CourierOrderMutation) SetTotalItemsPrice(f float64) {
	m.total_items_price = &f
	m.addtotal_items_price = nil
}

// TotalItemsPrice returns the value of the "total_items_price" field in the mutation.
func (m *CourierOrderMutation) TotalItemsPrice() (r float64, exists bool) {
	v := m.total_items_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalItemsPrice returns the old "total_items_price" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldTotalItemsPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalItemsPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalItemsPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalItemsPrice: %w", err)
	}
	return oldValue.TotalItemsPrice, nil
}

// AddTotalItemsPrice adds f to the "total_items_price" field.
func (m *CourierOrderMutation) AddTotalItemsPrice(f float64) {
	if m.addtotal_items_price != nil {
		*m.addtotal_items_price += f
	} else {
		m.addtotal_items_price = &f
	}
}

// AddedTotalItemsPrice returns the value that was added to the "total_items_price" field in this mutation.
func (m *CourierOrderMutation) AddedTotalItemsPrice() (r float64, exists bool) {
	v := m.addtotal_items_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalItemsPrice resets all changes to the "total_items_price" field.
func (m *CourierOrderMutation) ResetTotalItemsPrice() {
	m.total_items_price = nil
	m.addtotal_items_price = nil
}

// SetCurrency sets the "currency" field.
func (m *CourierOrderMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CourierOrderMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *CourierOrderMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[courierorder.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *CourierOrderMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CourierOrderMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, courierorder.FieldCurrency)
}

// SetPackageCount sets the "package_count" field.
func (m *CourierOrderMutation) SetPackageCount(i int) {
	m.package_count = &i
	m.addpackage_count = nil
}

// PackageCount returns the value of the "package_count" field in the mutation.
func (m *CourierOrderMutation) PackageCount() (r int, exists bool) {
	v := m.package_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageCount returns the old "package_count" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldPackageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageCount: %w", err)
	}
	return oldValue.PackageCount, nil
}

// AddPackageCount adds i to the "package_count" field.
func (m *CourierOrderMutation) AddPackageCount(i int) {
	if m.addpackage_count != nil {
		*m.addpackage_count += i
	} else {
		m.addpackage_count = &i
	}
}

// AddedPackageCount returns the value that was added to the "package_count" field in this mutation.
func (m *CourierOrderMutation) AddedPackageCount() (r int, exists bool) {
	v := m.addpackage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPackageCount resets all changes to the "package_count" field.
func (m *CourierOrderMutation) ResetPackageCount() {
	m.package_count = nil
	m.addpackage_count = nil
}

// SetWeight sets the "weight" field.
func (m *CourierOrderMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *CourierOrderMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *CourierOrderMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *CourierOrderMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *CourierOrderMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetReceiverAddress sets the "receiver_address" field.
func (m *CourierOrderMutation) SetReceiverAddress(s string) {
	m.receiver_address = &s
}

// ReceiverAddress returns the value of the "receiver_address" field in the mutation.
func (m *CourierOrderMutation) ReceiverAddress() (r string, exists bool) {
	v := m.receiver_address
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverAddress returns the old "receiver_address" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldReceiverAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverAddress: %w", err)
	}
	return oldValue.ReceiverAddress, nil
}

// ClearReceiverAddress clears the value of the "receiver_address" field.
func (m *CourierOrderMutation) ClearReceiverAddress() {
	m.receiver_address = nil
	m.clearedFields[courierorder.FieldReceiverAddress] = struct{}{}
}

// ReceiverAddressCleared returns if the "receiver_address" field was cleared in this mutation.
func (m *CourierOrderMutation) ReceiverAddressCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldReceiverAddress]
	return ok
}

// ResetReceiverAddress resets all changes to the "receiver_address" field.
func (m *CourierOrderMutation) ResetReceiverAddress() {
	m.receiver_address = nil
	delete(m.clearedFields, courierorder.FieldReceiverAddress)
}

// SetSenderAddress sets the "sender_address" field.
func (m *CourierOrderMutation) SetSenderAddress(s string) {
	m.sender_address = &s
}

// SenderAddress returns the value of the "sender_address" field in the mutation.
func (m *CourierOrderMutation) SenderAddress() (r string, exists bool) {
	v := m.sender_address
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderAddress returns the old "sender_address" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldSenderAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderAddress: %w", err)
	}
	return oldValue.SenderAddress, nil
}

// ClearSenderAddress clears the value of the "sender_address" field.
func (m *CourierOrderMutation) ClearSenderAddress() {
	m.sender_address = nil
	m.clearedFields[courierorder.FieldSenderAddress] = struct{}{}
}

// SenderAddressCleared returns if the "sender_address" field was cleared in this mutation.
func (m *CourierOrderMutation) SenderAddressCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldSenderAddress]
	return ok
}

// ResetSenderAddress resets all changes to the "sender_address" field.
func (m *CourierOrderMutation) ResetSenderAddress() {
	m.sender_address = nil
	delete(m.clearedFields, courierorder.FieldSenderAddress)
}

// SetItems sets the "items" field.
func (m *CourierOrderMutation) SetItems(s string) {
	m.items = &s
}

// Items returns the value of the "items" field in the mutation.
func (m *CourierOrderMutation) Items() (r string, exists bool) {
	v := m.items
	if v == nil {
		return
	}
	return *v, true
}

// OldItems returns the old "items" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldItems(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItems: %w", err)
	}
	return oldValue.Items, nil
}

// ClearItems clears the value of the "items" field.
func (m *CourierOrderMutation) ClearItems() {
	m.items = nil
	m.clearedFields[courierorder.FieldItems] = struct{}{}
}

// ItemsCleared returns if the "items" field was cleared in this mutation.
func (m *CourierOrderMutation) ItemsCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldItems]
	return ok
}

// ResetItems resets all changes to the "items" field.
func (m *CourierOrderMutation) ResetItems() {
	m.items = nil
	delete(m.clearedFields, courierorder.FieldItems)
}

// SetRequestData sets the "request_data" field.
func (m *CourierOrderMutation) SetRequestData(s string) {
	m.request_data = &s
}

// RequestData returns the value of the "request_data" field in the mutation.
func (m *CourierOrderMutation) RequestData() (r string, exists bool) {
	v := m.request_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestData returns the old "request_data" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldRequestData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestData: %w", err)
	}
	return oldValue.RequestData, nil
}

// ClearRequestData clears the value of the "request_data" field.
func (m *CourierOrderMutation) ClearRequestData() {
	m.request_data = nil
	m.clearedFields[courierorder.FieldRequestData] = struct{}{}
}

// RequestDataCleared returns if the "request_data" field was cleared in this mutation.
func (m *CourierOrderMutation) RequestDataCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldRequestData]
	return ok
}

// ResetRequestData resets all changes to the "request_data" field.
func (m *CourierOrderMutation) ResetRequestData() {
	m.request_data = nil
	delete(m.clearedFields, courierorder.FieldRequestData)
}

// SetResponseData sets the "response_data" field.
func (m *CourierOrderMutation) SetResponseData(s string) {
	m.response_data = &s
}

// ResponseData returns the value of the "response_data" field in the mutation.
func (m *CourierOrderMutation) ResponseData() (r string, exists bool) {
	v := m.response_data
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseData returns the old "response_data" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldResponseData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseData: %w", err)
	}
	return oldValue.ResponseData, nil
}

// ClearResponseData clears the value of the "response_data" field.
func (m *CourierOrderMutation) ClearResponseData() {
	m.response_data = nil
	m.clearedFields[courierorder.FieldResponseData] = struct{}{}
}

// ResponseDataCleared returns if the "response_data" field was cleared in this mutation.
func (m *CourierOrderMutation) ResponseDataCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldResponseData]
	return ok
}

// ResetResponseData resets all changes to the "response_data" field.
func (m *CourierOrderMutation) ResetResponseData() {
	m.response_data = nil
	delete(m.clearedFields, courierorder.FieldResponseData)
}

// SetResultCode sets the "result_code" field.
func (m *CourierOrderMutation) SetResultCode(s string) {
	m.result_code = &s
}

// ResultCode returns the value of the "result_code" field in the mutation.
func (m *CourierOrderMutation) ResultCode() (r string, exists bool) {
	v := m.result_code
	if v == nil {
		return
	}
	return *v, true
}

// OldResultCode returns the old "result_code" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldResultCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultCode: %w", err)
	}
	return oldValue.ResultCode, nil
}

// ClearResultCode clears the value of the "result_code" field.
func (m *CourierOrderMutation) ClearResultCode() {
	m.result_code = nil
	m.clearedFields[courierorder.FieldResultCode] = struct{}{}
}

// ResultCodeCleared returns if the "result_code" field was cleared in this mutation.
func (m *CourierOrderMutation) ResultCodeCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldResultCode]
	return ok
}

// ResetResultCode resets all changes to the "result_code" field.
func (m *CourierOrderMutation) ResetResultCode() {
	m.result_code = nil
	delete(m.clearedFields, courierorder.FieldResultCode)
}

// SetMessage sets the "message" field.
func (m *CourierOrderMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CourierOrderMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *CourierOrderMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[courierorder.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *CourierOrderMutation) MessageCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *CourierOrderMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, courierorder.FieldMessage)
}

// SetEnMessage sets the "en_message" field.
func (m *CourierOrderMutation) SetEnMessage(s string) {
	m.en_message = &s
}

// EnMessage returns the value of the "en_message" field in the mutation.
func (m *CourierOrderMutation) EnMessage() (r string, exists bool) {
	v := m.en_message
	if v == nil {
		return
	}
	return *v, true
}

// OldEnMessage returns the old "en_message" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldEnMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnMessage: %w", err)
	}
	return oldValue.EnMessage, nil
}

// ClearEnMessage clears the value of the "en_message" field.
func (m *CourierOrderMutation) ClearEnMessage() {
	m.en_message = nil
	m.clearedFields[courierorder.FieldEnMessage] = struct{}{}
}

// EnMessageCleared returns if the "en_message" field was cleared in this mutation.
func (m *CourierOrderMutation) EnMessageCleared() bool {
	_, ok := m.clearedFields[courierorder.FieldEnMessage]
	return ok
}

// ResetEnMessage resets all changes to the "en_message" field.
func (m *CourierOrderMutation) ResetEnMessage() {
	m.en_message = nil
	delete(m.clearedFields, courierorder.FieldEnMessage)
}

// SetStatus sets the "status" field.
func (m *CourierOrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CourierOrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CourierOrder entity.
// If the CourierOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourierOrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CourierOrderMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the CourierOrderMutation builder.
func (m *CourierOrderMutation) Where(ps ...predicate.CourierOrder) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CourierOrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CourierOrder).
func (m *CourierOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourierOrderMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, courierorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, courierorder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, courierorder.FieldDeletedAt)
	}
	if m.order_id != nil {
		fields = append(fields, courierorder.FieldOrderID)
	}
	if m.order_number != nil {
		fields = append(fields, courierorder.FieldOrderNumber)
	}
	if m.courier_platform != nil {
		fields = append(fields, courierorder.FieldCourierPlatform)
	}
	if m.shipping_method_code != nil {
		fields = append(fields, courierorder.FieldShippingMethodCode)
	}
	if m.shipping_method_name != nil {
		fields = append(fields, courierorder.FieldShippingMethodName)
	}
	if m.tracking_url != nil {
		fields = append(fields, courierorder.FieldTrackingURL)
	}
	if m.tracking_number != nil {
		fields = append(fields, courierorder.FieldTrackingNumber)
	}
	if m.waybill_number != nil {
		fields = append(fields, courierorder.FieldWaybillNumber)
	}
	if m.courier_order_number != nil {
		fields = append(fields, courierorder.FieldCourierOrderNumber)
	}
	if m.shipping_label_url != nil {
		fields = append(fields, courierorder.FieldShippingLabelURL)
	}
	if m.total_items_price != nil {
		fields = append(fields, courierorder.FieldTotalItemsPrice)
	}
	if m.currency != nil {
		fields = append(fields, courierorder.FieldCurrency)
	}
	if m.package_count != nil {
		fields = append(fields, courierorder.FieldPackageCount)
	}
	if m.weight != nil {
		fields = append(fields, courierorder.FieldWeight)
	}
	if m.receiver_address != nil {
		fields = append(fields, courierorder.FieldReceiverAddress)
	}
	if m.sender_address != nil {
		fields = append(fields, courierorder.FieldSenderAddress)
	}
	if m.items != nil {
		fields = append(fields, courierorder.FieldItems)
	}
	if m.request_data != nil {
		fields = append(fields, courierorder.FieldRequestData)
	}
	if m.response_data != nil {
		fields = append(fields, courierorder.FieldResponseData)
	}
	if m.result_code != nil {
		fields = append(fields, courierorder.FieldResultCode)
	}
	if m.message != nil {
		fields = append(fields, courierorder.FieldMessage)
	}
	if m.en_message != nil {
		fields = append(fields, courierorder.FieldEnMessage)
	}
	if m.status != nil {
		fields = append(fields, courierorder.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourierOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case courierorder.FieldCreatedAt:
		return m.CreatedAt()
	case courierorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case courierorder.FieldDeletedAt:
		return m.DeletedAt()
	case courierorder.FieldOrderID:
		return m.OrderID()
	case courierorder.FieldOrderNumber:
		return m.OrderNumber()
	case courierorder.FieldCourierPlatform:
		return m.CourierPlatform()
	case courierorder.FieldShippingMethodCode:
		return m.ShippingMethodCode()
	case courierorder.FieldShippingMethodName:
		return m.ShippingMethodName()
	case courierorder.FieldTrackingURL:
		return m.TrackingURL()
	case courierorder.FieldTrackingNumber:
		return m.TrackingNumber()
	case courierorder.FieldWaybillNumber:
		return m.WaybillNumber()
	case courierorder.FieldCourierOrderNumber:
		return m.CourierOrderNumber()
	case courierorder.FieldShippingLabelURL:
		return m.ShippingLabelURL()
	case courierorder.FieldTotalItemsPrice:
		return m.TotalItemsPrice()
	case courierorder.FieldCurrency:
		return m.Currency()
	case courierorder.FieldPackageCount:
		return m.PackageCount()
	case courierorder.FieldWeight:
		return m.Weight()
	case courierorder.FieldReceiverAddress:
		return m.ReceiverAddress()
	case courierorder.FieldSenderAddress:
		return m.SenderAddress()
	case courierorder.FieldItems:
		return m.Items()
	case courierorder.FieldRequestData:
		return m.RequestData()
	case courierorder.FieldResponseData:
		return m.ResponseData()
	case courierorder.FieldResultCode:
		return m.ResultCode()
	case courierorder.FieldMessage:
		return m.Message()
	case courierorder.FieldEnMessage:
		return m.EnMessage()
	case courierorder.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourierOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case courierorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case courierorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case courierorder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case courierorder.FieldOrderID:
		return m.OldOrderID(ctx)
	case courierorder.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case courierorder.FieldCourierPlatform:
		return m.OldCourierPlatform(ctx)
	case courierorder.FieldShippingMethodCode:
		return m.OldShippingMethodCode(ctx)
	case courierorder.FieldShippingMethodName:
		return m.OldShippingMethodName(ctx)
	case courierorder.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case courierorder.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case courierorder.FieldWaybillNumber:
		return m.OldWaybillNumber(ctx)
	case courierorder.FieldCourierOrderNumber:
		return m.OldCourierOrderNumber(ctx)
	case courierorder.FieldShippingLabelURL:
		return m.OldShippingLabelURL(ctx)
	case courierorder.FieldTotalItemsPrice:
		return m.OldTotalItemsPrice(ctx)
	case courierorder.FieldCurrency:
		return m.OldCurrency(ctx)
	case courierorder.FieldPackageCount:
		return m.OldPackageCount(ctx)
	case courierorder.FieldWeight:
		return m.OldWeight(ctx)
	case courierorder.FieldReceiverAddress:
		return m.OldReceiverAddress(ctx)
	case courierorder.FieldSenderAddress:
		return m.OldSenderAddress(ctx)
	case courierorder.FieldItems:
		return m.OldItems(ctx)
	case courierorder.FieldRequestData:
		return m.OldRequestData(ctx)
	case courierorder.FieldResponseData:
		return m.OldResponseData(ctx)
	case courierorder.FieldResultCode:
		return m.OldResultCode(ctx)
	case courierorder.FieldMessage:
		return m.OldMessage(ctx)
	case courierorder.FieldEnMessage:
		return m.OldEnMessage(ctx)
	case courierorder.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CourierOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourierOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case courierorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case courierorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case courierorder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case courierorder.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case courierorder.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case courierorder.FieldCourierPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierPlatform(v)
		return nil
	case courierorder.FieldShippingMethodCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingMethodCode(v)
		return nil
	case courierorder.FieldShippingMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingMethodName(v)
		return nil
	case courierorder.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case courierorder.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case courierorder.FieldWaybillNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaybillNumber(v)
		return nil
	case courierorder.FieldCourierOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierOrderNumber(v)
		return nil
	case courierorder.FieldShippingLabelURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingLabelURL(v)
		return nil
	case courierorder.FieldTotalItemsPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalItemsPrice(v)
		return nil
	case courierorder.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case courierorder.FieldPackageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageCount(v)
		return nil
	case courierorder.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case courierorder.FieldReceiverAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverAddress(v)
		return nil
	case courierorder.FieldSenderAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderAddress(v)
		return nil
	case courierorder.FieldItems:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItems(v)
		return nil
	case courierorder.FieldRequestData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestData(v)
		return nil
	case courierorder.FieldResponseData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseData(v)
		return nil
	case courierorder.FieldResultCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultCode(v)
		return nil
	case courierorder.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case courierorder.FieldEnMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnMessage(v)
		return nil
	case courierorder.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CourierOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourierOrderMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, courierorder.FieldOrderID)
	}
	if m.addtotal_items_price != nil {
		fields = append(fields, courierorder.FieldTotalItemsPrice)
	}
	if m.addpackage_count != nil {
		fields = append(fields, courierorder.FieldPackageCount)
	}
	if m.addweight != nil {
		fields = append(fields, courierorder.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourierOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case courierorder.FieldOrderID:
		return m.AddedOrderID()
	case courierorder.FieldTotalItemsPrice:
		return m.AddedTotalItemsPrice()
	case courierorder.FieldPackageCount:
		return m.AddedPackageCount()
	case courierorder.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourierOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case courierorder.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case courierorder.FieldTotalItemsPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalItemsPrice(v)
		return nil
	case courierorder.FieldPackageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPackageCount(v)
		return nil
	case courierorder.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown CourierOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourierOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(courierorder.FieldDeletedAt) {
		fields = append(fields, courierorder.FieldDeletedAt)
	}
	if m.FieldCleared(courierorder.FieldCurrency) {
		fields = append(fields, courierorder.FieldCurrency)
	}
	if m.FieldCleared(courierorder.FieldReceiverAddress) {
		fields = append(fields, courierorder.FieldReceiverAddress)
	}
	if m.FieldCleared(courierorder.FieldSenderAddress) {
		fields = append(fields, courierorder.FieldSenderAddress)
	}
	if m.FieldCleared(courierorder.FieldItems) {
		fields = append(fields, courierorder.FieldItems)
	}
	if m.FieldCleared(courierorder.FieldRequestData) {
		fields = append(fields, courierorder.FieldRequestData)
	}
	if m.FieldCleared(courierorder.FieldResponseData) {
		fields = append(fields, courierorder.FieldResponseData)
	}
	if m.FieldCleared(courierorder.FieldResultCode) {
		fields = append(fields, courierorder.FieldResultCode)
	}
	if m.FieldCleared(courierorder.FieldMessage) {
		fields = append(fields, courierorder.FieldMessage)
	}
	if m.FieldCleared(courierorder.FieldEnMessage) {
		fields = append(fields, courierorder.FieldEnMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourierOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourierOrderMutation) ClearField(name string) error {
	switch name {
	case courierorder.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case courierorder.FieldCurrency:
		m.ClearCurrency()
		return nil
	case courierorder.FieldReceiverAddress:
		m.ClearReceiverAddress()
		return nil
	case courierorder.FieldSenderAddress:
		m.ClearSenderAddress()
		return nil
	case courierorder.FieldItems:
		m.ClearItems()
		return nil
	case courierorder.FieldRequestData:
		m.ClearRequestData()
		return nil
	case courierorder.FieldResponseData:
		m.ClearResponseData()
		return nil
	case courierorder.FieldResultCode:
		m.ClearResultCode()
		return nil
	case courierorder.FieldMessage:
		m.ClearMessage()
		return nil
	case courierorder.FieldEnMessage:
		m.ClearEnMessage()
		return nil
	}
	return fmt.Errorf("unknown CourierOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourierOrderMutation) ResetField(name string) error {
	switch name {
	case courierorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case courierorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case courierorder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case courierorder.FieldOrderID:
		m.ResetOrderID()
		return nil
	case courierorder.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case courierorder.FieldCourierPlatform:
		m.ResetCourierPlatform()
		return nil
	case courierorder.FieldShippingMethodCode:
		m.ResetShippingMethodCode()
		return nil
	case courierorder.FieldShippingMethodName:
		m.ResetShippingMethodName()
		return nil
	case courierorder.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case courierorder.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case courierorder.FieldWaybillNumber:
		m.ResetWaybillNumber()
		return nil
	case courierorder.FieldCourierOrderNumber:
		m.ResetCourierOrderNumber()
		return nil
	case courierorder.FieldShippingLabelURL:
		m.ResetShippingLabelURL()
		return nil
	case courierorder.FieldTotalItemsPrice:
		m.ResetTotalItemsPrice()
		return nil
	case courierorder.FieldCurrency:
		m.ResetCurrency()
		return nil
	case courierorder.FieldPackageCount:
		m.ResetPackageCount()
		return nil
	case courierorder.FieldWeight:
		m.ResetWeight()
		return nil
	case courierorder.FieldReceiverAddress:
		m.ResetReceiverAddress()
		return nil
	case courierorder.FieldSenderAddress:
		m.ResetSenderAddress()
		return nil
	case courierorder.FieldItems:
		m.ResetItems()
		return nil
	case courierorder.FieldRequestData:
		m.ResetRequestData()
		return nil
	case courierorder.FieldResponseData:
		m.ResetResponseData()
		return nil
	case courierorder.FieldResultCode:
		m.ResetResultCode()
		return nil
	case courierorder.FieldMessage:
		m.ResetMessage()
		return nil
	case courierorder.FieldEnMessage:
		m.ResetEnMessage()
		return nil
	case courierorder.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CourierOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourierOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourierOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourierOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourierOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourierOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourierOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourierOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CourierOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourierOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CourierOrder edge %s", name)
}

// CustomerConfigMutation represents an operation that mutates the CustomerConfig nodes in the graph.
type CustomerConfigMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	channel_id           *int64
	addchannel_id        *int64
	exclude_country_code *string
	status               *int8
	addstatus            *int8
	clearedFields        map[string]struct{}
	tenant               *int64
	clearedtenant        bool
	done                 bool
	oldValue             func(context.Context) (*CustomerConfig, error)
	predicates           []predicate.CustomerConfig
}

var _ ent.Mutation = (*CustomerConfigMutation)(nil)

// customerconfigOption allows management of the mutation configuration using functional options.
type customerconfigOption func(*CustomerConfigMutation)

// newCustomerConfigMutation creates new mutation for the CustomerConfig entity.
func newCustomerConfigMutation(c config, op Op, opts ...customerconfigOption) *CustomerConfigMutation {
	m := &CustomerConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerConfigID sets the ID field of the mutation.
func withCustomerConfigID(id int64) customerconfigOption {
	return func(m *CustomerConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerConfig
		)
		m.oldValue = func(ctx context.Context) (*CustomerConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerConfig sets the old CustomerConfig of the mutation.
func withCustomerConfig(node *CustomerConfig) customerconfigOption {
	return func(m *CustomerConfigMutation) {
		m.oldValue = func(context.Context) (*CustomerConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomerConfig entities.
func (m *CustomerConfigMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerConfig entity.
// If the CustomerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerConfig entity.
// If the CustomerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CustomerConfigMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CustomerConfigMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CustomerConfig entity.
// If the CustomerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerConfigMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CustomerConfigMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[customerconfig.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CustomerConfigMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[customerconfig.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CustomerConfigMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, customerconfig.FieldDeletedAt)
}

// SetChannelID sets the "channel_id" field.
func (m *CustomerConfigMutation) SetChannelID(i int64) {
	m.channel_id = &i
	m.addchannel_id = nil
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *CustomerConfigMutation) ChannelID() (r int64, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the CustomerConfig entity.
// If the CustomerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerConfigMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// AddChannelID adds i to the "channel_id" field.
func (m *CustomerConfigMutation) AddChannelID(i int64) {
	if m.addchannel_id != nil {
		*m.addchannel_id += i
	} else {
		m.addchannel_id = &i
	}
}

// AddedChannelID returns the value that was added to the "channel_id" field in this mutation.
func (m *CustomerConfigMutation) AddedChannelID() (r int64, exists bool) {
	v := m.addchannel_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *CustomerConfigMutation) ResetChannelID() {
	m.channel_id = nil
	m.addchannel_id = nil
}

// SetExcludeCountryCode sets the "exclude_country_code" field.
func (m *CustomerConfigMutation) SetExcludeCountryCode(s string) {
	m.exclude_country_code = &s
}

// ExcludeCountryCode returns the value of the "exclude_country_code" field in the mutation.
func (m *CustomerConfigMutation) ExcludeCountryCode() (r string, exists bool) {
	v := m.exclude_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldExcludeCountryCode returns the old "exclude_country_code" field's value of the CustomerConfig entity.
// If the CustomerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerConfigMutation) OldExcludeCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcludeCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcludeCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcludeCountryCode: %w", err)
	}
	return oldValue.ExcludeCountryCode, nil
}

// ResetExcludeCountryCode resets all changes to the "exclude_country_code" field.
func (m *CustomerConfigMutation) ResetExcludeCountryCode() {
	m.exclude_country_code = nil
}

// SetStatus sets the "status" field.
func (m *CustomerConfigMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CustomerConfigMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CustomerConfig entity.
// If the CustomerConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerConfigMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CustomerConfigMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CustomerConfigMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CustomerConfigMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *CustomerConfigMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CustomerConfigMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CustomerConfigMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *CustomerConfigMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CustomerConfigMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CustomerConfigMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the CustomerConfigMutation builder.
func (m *CustomerConfigMutation) Where(ps ...predicate.CustomerConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CustomerConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CustomerConfig).
func (m *CustomerConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerConfigMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, customerconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customerconfig.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, customerconfig.FieldDeletedAt)
	}
	if m.channel_id != nil {
		fields = append(fields, customerconfig.FieldChannelID)
	}
	if m.exclude_country_code != nil {
		fields = append(fields, customerconfig.FieldExcludeCountryCode)
	}
	if m.status != nil {
		fields = append(fields, customerconfig.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customerconfig.FieldCreatedAt:
		return m.CreatedAt()
	case customerconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case customerconfig.FieldDeletedAt:
		return m.DeletedAt()
	case customerconfig.FieldChannelID:
		return m.ChannelID()
	case customerconfig.FieldExcludeCountryCode:
		return m.ExcludeCountryCode()
	case customerconfig.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customerconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customerconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customerconfig.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case customerconfig.FieldChannelID:
		return m.OldChannelID(ctx)
	case customerconfig.FieldExcludeCountryCode:
		return m.OldExcludeCountryCode(ctx)
	case customerconfig.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customerconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customerconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customerconfig.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case customerconfig.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case customerconfig.FieldExcludeCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcludeCountryCode(v)
		return nil
	case customerconfig.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerConfigMutation) AddedFields() []string {
	var fields []string
	if m.addchannel_id != nil {
		fields = append(fields, customerconfig.FieldChannelID)
	}
	if m.addstatus != nil {
		fields = append(fields, customerconfig.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customerconfig.FieldChannelID:
		return m.AddedChannelID()
	case customerconfig.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customerconfig.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelID(v)
		return nil
	case customerconfig.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customerconfig.FieldDeletedAt) {
		fields = append(fields, customerconfig.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerConfigMutation) ClearField(name string) error {
	switch name {
	case customerconfig.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CustomerConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerConfigMutation) ResetField(name string) error {
	switch name {
	case customerconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customerconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customerconfig.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case customerconfig.FieldChannelID:
		m.ResetChannelID()
		return nil
	case customerconfig.FieldExcludeCountryCode:
		m.ResetExcludeCountryCode()
		return nil
	case customerconfig.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CustomerConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, customerconfig.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customerconfig.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, customerconfig.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case customerconfig.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerConfigMutation) ClearEdge(name string) error {
	switch name {
	case customerconfig.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown CustomerConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerConfigMutation) ResetEdge(name string) error {
	switch name {
	case customerconfig.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown CustomerConfig edge %s", name)
}

// InboundMutation represents an operation that mutates the Inbound nodes in the graph.
type InboundMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	customer_order_id    *string
	customer_code        *string
	tracking_number      *string
	warehouse_id         *int64
	addwarehouse_id      *int64
	description          *string
	estimated_arrival_at *time.Time
	shipped_at           *time.Time
	status               *int8
	addstatus            *int8
	_type                *int8
	add_type             *int8
	is_pickup            *int8
	addis_pickup         *int8
	shipping_mark_url    *string
	pickup_order_id      *int64
	addpickup_order_id   *int64
	carrier_name         *string
	order_number         *string
	clearedFields        map[string]struct{}
	tenant               *int64
	clearedtenant        bool
	inbound_items        map[int64]struct{}
	removedinbound_items map[int64]struct{}
	clearedinbound_items bool
	done                 bool
	oldValue             func(context.Context) (*Inbound, error)
	predicates           []predicate.Inbound
}

var _ ent.Mutation = (*InboundMutation)(nil)

// inboundOption allows management of the mutation configuration using functional options.
type inboundOption func(*InboundMutation)

// newInboundMutation creates new mutation for the Inbound entity.
func newInboundMutation(c config, op Op, opts ...inboundOption) *InboundMutation {
	m := &InboundMutation{
		config:        c,
		op:            op,
		typ:           TypeInbound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInboundID sets the ID field of the mutation.
func withInboundID(id int64) inboundOption {
	return func(m *InboundMutation) {
		var (
			err   error
			once  sync.Once
			value *Inbound
		)
		m.oldValue = func(ctx context.Context) (*Inbound, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inbound.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInbound sets the old Inbound of the mutation.
func withInbound(node *Inbound) inboundOption {
	return func(m *InboundMutation) {
		m.oldValue = func(context.Context) (*Inbound, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InboundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InboundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inbound entities.
func (m *InboundMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InboundMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InboundMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inbound.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InboundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InboundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InboundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InboundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InboundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InboundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InboundMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InboundMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InboundMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inbound.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InboundMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inbound.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InboundMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inbound.FieldDeletedAt)
}

// SetCustomerOrderID sets the "customer_order_id" field.
func (m *InboundMutation) SetCustomerOrderID(s string) {
	m.customer_order_id = &s
}

// CustomerOrderID returns the value of the "customer_order_id" field in the mutation.
func (m *InboundMutation) CustomerOrderID() (r string, exists bool) {
	v := m.customer_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerOrderID returns the old "customer_order_id" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldCustomerOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerOrderID: %w", err)
	}
	return oldValue.CustomerOrderID, nil
}

// ResetCustomerOrderID resets all changes to the "customer_order_id" field.
func (m *InboundMutation) ResetCustomerOrderID() {
	m.customer_order_id = nil
}

// SetCustomerCode sets the "customer_code" field.
func (m *InboundMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *InboundMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldCustomerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *InboundMutation) ResetCustomerCode() {
	m.customer_code = nil
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *InboundMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *InboundMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *InboundMutation) ResetTrackingNumber() {
	m.tracking_number = nil
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *InboundMutation) SetWarehouseID(i int64) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *InboundMutation) WarehouseID() (r int64, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldWarehouseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *InboundMutation) AddWarehouseID(i int64) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *InboundMutation) AddedWarehouseID() (r int64, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *InboundMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
}

// SetDescription sets the "description" field.
func (m *InboundMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InboundMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InboundMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[inbound.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InboundMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[inbound.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InboundMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, inbound.FieldDescription)
}

// SetEstimatedArrivalAt sets the "estimated_arrival_at" field.
func (m *InboundMutation) SetEstimatedArrivalAt(t time.Time) {
	m.estimated_arrival_at = &t
}

// EstimatedArrivalAt returns the value of the "estimated_arrival_at" field in the mutation.
func (m *InboundMutation) EstimatedArrivalAt() (r time.Time, exists bool) {
	v := m.estimated_arrival_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedArrivalAt returns the old "estimated_arrival_at" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldEstimatedArrivalAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedArrivalAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedArrivalAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedArrivalAt: %w", err)
	}
	return oldValue.EstimatedArrivalAt, nil
}

// ClearEstimatedArrivalAt clears the value of the "estimated_arrival_at" field.
func (m *InboundMutation) ClearEstimatedArrivalAt() {
	m.estimated_arrival_at = nil
	m.clearedFields[inbound.FieldEstimatedArrivalAt] = struct{}{}
}

// EstimatedArrivalAtCleared returns if the "estimated_arrival_at" field was cleared in this mutation.
func (m *InboundMutation) EstimatedArrivalAtCleared() bool {
	_, ok := m.clearedFields[inbound.FieldEstimatedArrivalAt]
	return ok
}

// ResetEstimatedArrivalAt resets all changes to the "estimated_arrival_at" field.
func (m *InboundMutation) ResetEstimatedArrivalAt() {
	m.estimated_arrival_at = nil
	delete(m.clearedFields, inbound.FieldEstimatedArrivalAt)
}

// SetShippedAt sets the "shipped_at" field.
func (m *InboundMutation) SetShippedAt(t time.Time) {
	m.shipped_at = &t
}

// ShippedAt returns the value of the "shipped_at" field in the mutation.
func (m *InboundMutation) ShippedAt() (r time.Time, exists bool) {
	v := m.shipped_at
	if v == nil {
		return
	}
	return *v, true
}

// OldShippedAt returns the old "shipped_at" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldShippedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippedAt: %w", err)
	}
	return oldValue.ShippedAt, nil
}

// ClearShippedAt clears the value of the "shipped_at" field.
func (m *InboundMutation) ClearShippedAt() {
	m.shipped_at = nil
	m.clearedFields[inbound.FieldShippedAt] = struct{}{}
}

// ShippedAtCleared returns if the "shipped_at" field was cleared in this mutation.
func (m *InboundMutation) ShippedAtCleared() bool {
	_, ok := m.clearedFields[inbound.FieldShippedAt]
	return ok
}

// ResetShippedAt resets all changes to the "shipped_at" field.
func (m *InboundMutation) ResetShippedAt() {
	m.shipped_at = nil
	delete(m.clearedFields, inbound.FieldShippedAt)
}

// SetStatus sets the "status" field.
func (m *InboundMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *InboundMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *InboundMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *InboundMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *InboundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetType sets the "type" field.
func (m *InboundMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *InboundMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *InboundMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *InboundMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *InboundMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetIsPickup sets the "is_pickup" field.
func (m *InboundMutation) SetIsPickup(i int8) {
	m.is_pickup = &i
	m.addis_pickup = nil
}

// IsPickup returns the value of the "is_pickup" field in the mutation.
func (m *InboundMutation) IsPickup() (r int8, exists bool) {
	v := m.is_pickup
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPickup returns the old "is_pickup" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldIsPickup(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPickup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPickup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPickup: %w", err)
	}
	return oldValue.IsPickup, nil
}

// AddIsPickup adds i to the "is_pickup" field.
func (m *InboundMutation) AddIsPickup(i int8) {
	if m.addis_pickup != nil {
		*m.addis_pickup += i
	} else {
		m.addis_pickup = &i
	}
}

// AddedIsPickup returns the value that was added to the "is_pickup" field in this mutation.
func (m *InboundMutation) AddedIsPickup() (r int8, exists bool) {
	v := m.addis_pickup
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsPickup resets all changes to the "is_pickup" field.
func (m *InboundMutation) ResetIsPickup() {
	m.is_pickup = nil
	m.addis_pickup = nil
}

// SetShippingMarkURL sets the "shipping_mark_url" field.
func (m *InboundMutation) SetShippingMarkURL(s string) {
	m.shipping_mark_url = &s
}

// ShippingMarkURL returns the value of the "shipping_mark_url" field in the mutation.
func (m *InboundMutation) ShippingMarkURL() (r string, exists bool) {
	v := m.shipping_mark_url
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingMarkURL returns the old "shipping_mark_url" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldShippingMarkURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingMarkURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingMarkURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingMarkURL: %w", err)
	}
	return oldValue.ShippingMarkURL, nil
}

// ClearShippingMarkURL clears the value of the "shipping_mark_url" field.
func (m *InboundMutation) ClearShippingMarkURL() {
	m.shipping_mark_url = nil
	m.clearedFields[inbound.FieldShippingMarkURL] = struct{}{}
}

// ShippingMarkURLCleared returns if the "shipping_mark_url" field was cleared in this mutation.
func (m *InboundMutation) ShippingMarkURLCleared() bool {
	_, ok := m.clearedFields[inbound.FieldShippingMarkURL]
	return ok
}

// ResetShippingMarkURL resets all changes to the "shipping_mark_url" field.
func (m *InboundMutation) ResetShippingMarkURL() {
	m.shipping_mark_url = nil
	delete(m.clearedFields, inbound.FieldShippingMarkURL)
}

// SetPickupOrderID sets the "pickup_order_id" field.
func (m *InboundMutation) SetPickupOrderID(i int64) {
	m.pickup_order_id = &i
	m.addpickup_order_id = nil
}

// PickupOrderID returns the value of the "pickup_order_id" field in the mutation.
func (m *InboundMutation) PickupOrderID() (r int64, exists bool) {
	v := m.pickup_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupOrderID returns the old "pickup_order_id" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldPickupOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupOrderID: %w", err)
	}
	return oldValue.PickupOrderID, nil
}

// AddPickupOrderID adds i to the "pickup_order_id" field.
func (m *InboundMutation) AddPickupOrderID(i int64) {
	if m.addpickup_order_id != nil {
		*m.addpickup_order_id += i
	} else {
		m.addpickup_order_id = &i
	}
}

// AddedPickupOrderID returns the value that was added to the "pickup_order_id" field in this mutation.
func (m *InboundMutation) AddedPickupOrderID() (r int64, exists bool) {
	v := m.addpickup_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPickupOrderID resets all changes to the "pickup_order_id" field.
func (m *InboundMutation) ResetPickupOrderID() {
	m.pickup_order_id = nil
	m.addpickup_order_id = nil
}

// SetCarrierName sets the "carrier_name" field.
func (m *InboundMutation) SetCarrierName(s string) {
	m.carrier_name = &s
}

// CarrierName returns the value of the "carrier_name" field in the mutation.
func (m *InboundMutation) CarrierName() (r string, exists bool) {
	v := m.carrier_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCarrierName returns the old "carrier_name" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldCarrierName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarrierName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarrierName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarrierName: %w", err)
	}
	return oldValue.CarrierName, nil
}

// ResetCarrierName resets all changes to the "carrier_name" field.
func (m *InboundMutation) ResetCarrierName() {
	m.carrier_name = nil
}

// SetOrderNumber sets the "order_number" field.
func (m *InboundMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *InboundMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the Inbound entity.
// If the Inbound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *InboundMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InboundMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InboundMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InboundMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InboundMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InboundMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InboundMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddInboundItemIDs adds the "inbound_items" edge to the InboundItem entity by ids.
func (m *InboundMutation) AddInboundItemIDs(ids ...int64) {
	if m.inbound_items == nil {
		m.inbound_items = make(map[int64]struct{})
	}
	for i := range ids {
		m.inbound_items[ids[i]] = struct{}{}
	}
}

// ClearInboundItems clears the "inbound_items" edge to the InboundItem entity.
func (m *InboundMutation) ClearInboundItems() {
	m.clearedinbound_items = true
}

// InboundItemsCleared reports if the "inbound_items" edge to the InboundItem entity was cleared.
func (m *InboundMutation) InboundItemsCleared() bool {
	return m.clearedinbound_items
}

// RemoveInboundItemIDs removes the "inbound_items" edge to the InboundItem entity by IDs.
func (m *InboundMutation) RemoveInboundItemIDs(ids ...int64) {
	if m.removedinbound_items == nil {
		m.removedinbound_items = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.inbound_items, ids[i])
		m.removedinbound_items[ids[i]] = struct{}{}
	}
}

// RemovedInboundItems returns the removed IDs of the "inbound_items" edge to the InboundItem entity.
func (m *InboundMutation) RemovedInboundItemsIDs() (ids []int64) {
	for id := range m.removedinbound_items {
		ids = append(ids, id)
	}
	return
}

// InboundItemsIDs returns the "inbound_items" edge IDs in the mutation.
func (m *InboundMutation) InboundItemsIDs() (ids []int64) {
	for id := range m.inbound_items {
		ids = append(ids, id)
	}
	return
}

// ResetInboundItems resets all changes to the "inbound_items" edge.
func (m *InboundMutation) ResetInboundItems() {
	m.inbound_items = nil
	m.clearedinbound_items = false
	m.removedinbound_items = nil
}

// Where appends a list predicates to the InboundMutation builder.
func (m *InboundMutation) Where(ps ...predicate.Inbound) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InboundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inbound).
func (m *InboundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InboundMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, inbound.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inbound.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inbound.FieldDeletedAt)
	}
	if m.customer_order_id != nil {
		fields = append(fields, inbound.FieldCustomerOrderID)
	}
	if m.customer_code != nil {
		fields = append(fields, inbound.FieldCustomerCode)
	}
	if m.tracking_number != nil {
		fields = append(fields, inbound.FieldTrackingNumber)
	}
	if m.warehouse_id != nil {
		fields = append(fields, inbound.FieldWarehouseID)
	}
	if m.description != nil {
		fields = append(fields, inbound.FieldDescription)
	}
	if m.estimated_arrival_at != nil {
		fields = append(fields, inbound.FieldEstimatedArrivalAt)
	}
	if m.shipped_at != nil {
		fields = append(fields, inbound.FieldShippedAt)
	}
	if m.status != nil {
		fields = append(fields, inbound.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, inbound.FieldType)
	}
	if m.is_pickup != nil {
		fields = append(fields, inbound.FieldIsPickup)
	}
	if m.shipping_mark_url != nil {
		fields = append(fields, inbound.FieldShippingMarkURL)
	}
	if m.pickup_order_id != nil {
		fields = append(fields, inbound.FieldPickupOrderID)
	}
	if m.carrier_name != nil {
		fields = append(fields, inbound.FieldCarrierName)
	}
	if m.order_number != nil {
		fields = append(fields, inbound.FieldOrderNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InboundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inbound.FieldCreatedAt:
		return m.CreatedAt()
	case inbound.FieldUpdatedAt:
		return m.UpdatedAt()
	case inbound.FieldDeletedAt:
		return m.DeletedAt()
	case inbound.FieldCustomerOrderID:
		return m.CustomerOrderID()
	case inbound.FieldCustomerCode:
		return m.CustomerCode()
	case inbound.FieldTrackingNumber:
		return m.TrackingNumber()
	case inbound.FieldWarehouseID:
		return m.WarehouseID()
	case inbound.FieldDescription:
		return m.Description()
	case inbound.FieldEstimatedArrivalAt:
		return m.EstimatedArrivalAt()
	case inbound.FieldShippedAt:
		return m.ShippedAt()
	case inbound.FieldStatus:
		return m.Status()
	case inbound.FieldType:
		return m.GetType()
	case inbound.FieldIsPickup:
		return m.IsPickup()
	case inbound.FieldShippingMarkURL:
		return m.ShippingMarkURL()
	case inbound.FieldPickupOrderID:
		return m.PickupOrderID()
	case inbound.FieldCarrierName:
		return m.CarrierName()
	case inbound.FieldOrderNumber:
		return m.OrderNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InboundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inbound.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inbound.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inbound.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inbound.FieldCustomerOrderID:
		return m.OldCustomerOrderID(ctx)
	case inbound.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	case inbound.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case inbound.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case inbound.FieldDescription:
		return m.OldDescription(ctx)
	case inbound.FieldEstimatedArrivalAt:
		return m.OldEstimatedArrivalAt(ctx)
	case inbound.FieldShippedAt:
		return m.OldShippedAt(ctx)
	case inbound.FieldStatus:
		return m.OldStatus(ctx)
	case inbound.FieldType:
		return m.OldType(ctx)
	case inbound.FieldIsPickup:
		return m.OldIsPickup(ctx)
	case inbound.FieldShippingMarkURL:
		return m.OldShippingMarkURL(ctx)
	case inbound.FieldPickupOrderID:
		return m.OldPickupOrderID(ctx)
	case inbound.FieldCarrierName:
		return m.OldCarrierName(ctx)
	case inbound.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Inbound field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InboundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inbound.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inbound.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inbound.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inbound.FieldCustomerOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerOrderID(v)
		return nil
	case inbound.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	case inbound.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case inbound.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case inbound.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case inbound.FieldEstimatedArrivalAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedArrivalAt(v)
		return nil
	case inbound.FieldShippedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippedAt(v)
		return nil
	case inbound.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inbound.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case inbound.FieldIsPickup:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPickup(v)
		return nil
	case inbound.FieldShippingMarkURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingMarkURL(v)
		return nil
	case inbound.FieldPickupOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupOrderID(v)
		return nil
	case inbound.FieldCarrierName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarrierName(v)
		return nil
	case inbound.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Inbound field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InboundMutation) AddedFields() []string {
	var fields []string
	if m.addwarehouse_id != nil {
		fields = append(fields, inbound.FieldWarehouseID)
	}
	if m.addstatus != nil {
		fields = append(fields, inbound.FieldStatus)
	}
	if m.add_type != nil {
		fields = append(fields, inbound.FieldType)
	}
	if m.addis_pickup != nil {
		fields = append(fields, inbound.FieldIsPickup)
	}
	if m.addpickup_order_id != nil {
		fields = append(fields, inbound.FieldPickupOrderID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InboundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inbound.FieldWarehouseID:
		return m.AddedWarehouseID()
	case inbound.FieldStatus:
		return m.AddedStatus()
	case inbound.FieldType:
		return m.AddedType()
	case inbound.FieldIsPickup:
		return m.AddedIsPickup()
	case inbound.FieldPickupOrderID:
		return m.AddedPickupOrderID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InboundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inbound.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case inbound.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case inbound.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case inbound.FieldIsPickup:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsPickup(v)
		return nil
	case inbound.FieldPickupOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPickupOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown Inbound numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InboundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inbound.FieldDeletedAt) {
		fields = append(fields, inbound.FieldDeletedAt)
	}
	if m.FieldCleared(inbound.FieldDescription) {
		fields = append(fields, inbound.FieldDescription)
	}
	if m.FieldCleared(inbound.FieldEstimatedArrivalAt) {
		fields = append(fields, inbound.FieldEstimatedArrivalAt)
	}
	if m.FieldCleared(inbound.FieldShippedAt) {
		fields = append(fields, inbound.FieldShippedAt)
	}
	if m.FieldCleared(inbound.FieldShippingMarkURL) {
		fields = append(fields, inbound.FieldShippingMarkURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InboundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InboundMutation) ClearField(name string) error {
	switch name {
	case inbound.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case inbound.FieldDescription:
		m.ClearDescription()
		return nil
	case inbound.FieldEstimatedArrivalAt:
		m.ClearEstimatedArrivalAt()
		return nil
	case inbound.FieldShippedAt:
		m.ClearShippedAt()
		return nil
	case inbound.FieldShippingMarkURL:
		m.ClearShippingMarkURL()
		return nil
	}
	return fmt.Errorf("unknown Inbound nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InboundMutation) ResetField(name string) error {
	switch name {
	case inbound.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inbound.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inbound.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inbound.FieldCustomerOrderID:
		m.ResetCustomerOrderID()
		return nil
	case inbound.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	case inbound.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case inbound.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case inbound.FieldDescription:
		m.ResetDescription()
		return nil
	case inbound.FieldEstimatedArrivalAt:
		m.ResetEstimatedArrivalAt()
		return nil
	case inbound.FieldShippedAt:
		m.ResetShippedAt()
		return nil
	case inbound.FieldStatus:
		m.ResetStatus()
		return nil
	case inbound.FieldType:
		m.ResetType()
		return nil
	case inbound.FieldIsPickup:
		m.ResetIsPickup()
		return nil
	case inbound.FieldShippingMarkURL:
		m.ResetShippingMarkURL()
		return nil
	case inbound.FieldPickupOrderID:
		m.ResetPickupOrderID()
		return nil
	case inbound.FieldCarrierName:
		m.ResetCarrierName()
		return nil
	case inbound.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	}
	return fmt.Errorf("unknown Inbound field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InboundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, inbound.EdgeTenant)
	}
	if m.inbound_items != nil {
		edges = append(edges, inbound.EdgeInboundItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InboundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inbound.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case inbound.EdgeInboundItems:
		ids := make([]ent.Value, 0, len(m.inbound_items))
		for id := range m.inbound_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InboundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinbound_items != nil {
		edges = append(edges, inbound.EdgeInboundItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InboundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inbound.EdgeInboundItems:
		ids := make([]ent.Value, 0, len(m.removedinbound_items))
		for id := range m.removedinbound_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InboundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, inbound.EdgeTenant)
	}
	if m.clearedinbound_items {
		edges = append(edges, inbound.EdgeInboundItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InboundMutation) EdgeCleared(name string) bool {
	switch name {
	case inbound.EdgeTenant:
		return m.clearedtenant
	case inbound.EdgeInboundItems:
		return m.clearedinbound_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InboundMutation) ClearEdge(name string) error {
	switch name {
	case inbound.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Inbound unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InboundMutation) ResetEdge(name string) error {
	switch name {
	case inbound.EdgeTenant:
		m.ResetTenant()
		return nil
	case inbound.EdgeInboundItems:
		m.ResetInboundItems()
		return nil
	}
	return fmt.Errorf("unknown Inbound edge %s", name)
}

// InboundItemMutation represents an operation that mutates the InboundItem nodes in the graph.
type InboundItemMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	product_id      *int64
	addproduct_id   *int64
	product_name    *string
	sku             *string
	barcode         *string
	qty             *int
	addqty          *int
	status          *int8
	addstatus       *int8
	customer_code   *string
	clearedFields   map[string]struct{}
	tenant          *int64
	clearedtenant   bool
	inbounds        *int64
	clearedinbounds bool
	done            bool
	oldValue        func(context.Context) (*InboundItem, error)
	predicates      []predicate.InboundItem
}

var _ ent.Mutation = (*InboundItemMutation)(nil)

// inbounditemOption allows management of the mutation configuration using functional options.
type inbounditemOption func(*InboundItemMutation)

// newInboundItemMutation creates new mutation for the InboundItem entity.
func newInboundItemMutation(c config, op Op, opts ...inbounditemOption) *InboundItemMutation {
	m := &InboundItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInboundItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInboundItemID sets the ID field of the mutation.
func withInboundItemID(id int64) inbounditemOption {
	return func(m *InboundItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InboundItem
		)
		m.oldValue = func(ctx context.Context) (*InboundItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InboundItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInboundItem sets the old InboundItem of the mutation.
func withInboundItem(node *InboundItem) inbounditemOption {
	return func(m *InboundItemMutation) {
		m.oldValue = func(context.Context) (*InboundItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InboundItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InboundItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InboundItem entities.
func (m *InboundItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InboundItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InboundItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InboundItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InboundItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InboundItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InboundItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InboundItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InboundItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InboundItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InboundItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InboundItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InboundItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inbounditem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InboundItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inbounditem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InboundItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inbounditem.FieldDeletedAt)
}

// SetInboundID sets the "inbound_id" field.
func (m *InboundItemMutation) SetInboundID(i int64) {
	m.inbounds = &i
}

// InboundID returns the value of the "inbound_id" field in the mutation.
func (m *InboundItemMutation) InboundID() (r int64, exists bool) {
	v := m.inbounds
	if v == nil {
		return
	}
	return *v, true
}

// OldInboundID returns the old "inbound_id" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldInboundID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInboundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInboundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInboundID: %w", err)
	}
	return oldValue.InboundID, nil
}

// ClearInboundID clears the value of the "inbound_id" field.
func (m *InboundItemMutation) ClearInboundID() {
	m.inbounds = nil
	m.clearedFields[inbounditem.FieldInboundID] = struct{}{}
}

// InboundIDCleared returns if the "inbound_id" field was cleared in this mutation.
func (m *InboundItemMutation) InboundIDCleared() bool {
	_, ok := m.clearedFields[inbounditem.FieldInboundID]
	return ok
}

// ResetInboundID resets all changes to the "inbound_id" field.
func (m *InboundItemMutation) ResetInboundID() {
	m.inbounds = nil
	delete(m.clearedFields, inbounditem.FieldInboundID)
}

// SetProductID sets the "product_id" field.
func (m *InboundItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *InboundItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *InboundItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *InboundItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *InboundItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetProductName sets the "product_name" field.
func (m *InboundItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *InboundItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *InboundItemMutation) ResetProductName() {
	m.product_name = nil
}

// SetSku sets the "sku" field.
func (m *InboundItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *InboundItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *InboundItemMutation) ResetSku() {
	m.sku = nil
}

// SetBarcode sets the "barcode" field.
func (m *InboundItemMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *InboundItemMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *InboundItemMutation) ResetBarcode() {
	m.barcode = nil
}

// SetQty sets the "qty" field.
func (m *InboundItemMutation) SetQty(i int) {
	m.qty = &i
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *InboundItemMutation) Qty() (r int, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds i to the "qty" field.
func (m *InboundItemMutation) AddQty(i int) {
	if m.addqty != nil {
		*m.addqty += i
	} else {
		m.addqty = &i
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *InboundItemMutation) AddedQty() (r int, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *InboundItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetStatus sets the "status" field.
func (m *InboundItemMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *InboundItemMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *InboundItemMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *InboundItemMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *InboundItemMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCustomerCode sets the "customer_code" field.
func (m *InboundItemMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *InboundItemMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the InboundItem entity.
// If the InboundItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InboundItemMutation) OldCustomerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *InboundItemMutation) ResetCustomerCode() {
	m.customer_code = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InboundItemMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InboundItemMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InboundItemMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InboundItemMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InboundItemMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InboundItemMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetInboundsID sets the "inbounds" edge to the Inbound entity by id.
func (m *InboundItemMutation) SetInboundsID(id int64) {
	m.inbounds = &id
}

// ClearInbounds clears the "inbounds" edge to the Inbound entity.
func (m *InboundItemMutation) ClearInbounds() {
	m.clearedinbounds = true
}

// InboundsCleared reports if the "inbounds" edge to the Inbound entity was cleared.
func (m *InboundItemMutation) InboundsCleared() bool {
	return m.InboundIDCleared() || m.clearedinbounds
}

// InboundsID returns the "inbounds" edge ID in the mutation.
func (m *InboundItemMutation) InboundsID() (id int64, exists bool) {
	if m.inbounds != nil {
		return *m.inbounds, true
	}
	return
}

// InboundsIDs returns the "inbounds" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InboundsID instead. It exists only for internal usage by the builders.
func (m *InboundItemMutation) InboundsIDs() (ids []int64) {
	if id := m.inbounds; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInbounds resets all changes to the "inbounds" edge.
func (m *InboundItemMutation) ResetInbounds() {
	m.inbounds = nil
	m.clearedinbounds = false
}

// Where appends a list predicates to the InboundItemMutation builder.
func (m *InboundItemMutation) Where(ps ...predicate.InboundItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InboundItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InboundItem).
func (m *InboundItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InboundItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, inbounditem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inbounditem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inbounditem.FieldDeletedAt)
	}
	if m.inbounds != nil {
		fields = append(fields, inbounditem.FieldInboundID)
	}
	if m.product_id != nil {
		fields = append(fields, inbounditem.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, inbounditem.FieldProductName)
	}
	if m.sku != nil {
		fields = append(fields, inbounditem.FieldSku)
	}
	if m.barcode != nil {
		fields = append(fields, inbounditem.FieldBarcode)
	}
	if m.qty != nil {
		fields = append(fields, inbounditem.FieldQty)
	}
	if m.status != nil {
		fields = append(fields, inbounditem.FieldStatus)
	}
	if m.customer_code != nil {
		fields = append(fields, inbounditem.FieldCustomerCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InboundItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inbounditem.FieldCreatedAt:
		return m.CreatedAt()
	case inbounditem.FieldUpdatedAt:
		return m.UpdatedAt()
	case inbounditem.FieldDeletedAt:
		return m.DeletedAt()
	case inbounditem.FieldInboundID:
		return m.InboundID()
	case inbounditem.FieldProductID:
		return m.ProductID()
	case inbounditem.FieldProductName:
		return m.ProductName()
	case inbounditem.FieldSku:
		return m.Sku()
	case inbounditem.FieldBarcode:
		return m.Barcode()
	case inbounditem.FieldQty:
		return m.Qty()
	case inbounditem.FieldStatus:
		return m.Status()
	case inbounditem.FieldCustomerCode:
		return m.CustomerCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InboundItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inbounditem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inbounditem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inbounditem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inbounditem.FieldInboundID:
		return m.OldInboundID(ctx)
	case inbounditem.FieldProductID:
		return m.OldProductID(ctx)
	case inbounditem.FieldProductName:
		return m.OldProductName(ctx)
	case inbounditem.FieldSku:
		return m.OldSku(ctx)
	case inbounditem.FieldBarcode:
		return m.OldBarcode(ctx)
	case inbounditem.FieldQty:
		return m.OldQty(ctx)
	case inbounditem.FieldStatus:
		return m.OldStatus(ctx)
	case inbounditem.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	}
	return nil, fmt.Errorf("unknown InboundItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InboundItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inbounditem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inbounditem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inbounditem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inbounditem.FieldInboundID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInboundID(v)
		return nil
	case inbounditem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case inbounditem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case inbounditem.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case inbounditem.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case inbounditem.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case inbounditem.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inbounditem.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	}
	return fmt.Errorf("unknown InboundItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InboundItemMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, inbounditem.FieldProductID)
	}
	if m.addqty != nil {
		fields = append(fields, inbounditem.FieldQty)
	}
	if m.addstatus != nil {
		fields = append(fields, inbounditem.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InboundItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inbounditem.FieldProductID:
		return m.AddedProductID()
	case inbounditem.FieldQty:
		return m.AddedQty()
	case inbounditem.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InboundItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inbounditem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case inbounditem.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case inbounditem.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown InboundItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InboundItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inbounditem.FieldDeletedAt) {
		fields = append(fields, inbounditem.FieldDeletedAt)
	}
	if m.FieldCleared(inbounditem.FieldInboundID) {
		fields = append(fields, inbounditem.FieldInboundID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InboundItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InboundItemMutation) ClearField(name string) error {
	switch name {
	case inbounditem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case inbounditem.FieldInboundID:
		m.ClearInboundID()
		return nil
	}
	return fmt.Errorf("unknown InboundItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InboundItemMutation) ResetField(name string) error {
	switch name {
	case inbounditem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inbounditem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inbounditem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inbounditem.FieldInboundID:
		m.ResetInboundID()
		return nil
	case inbounditem.FieldProductID:
		m.ResetProductID()
		return nil
	case inbounditem.FieldProductName:
		m.ResetProductName()
		return nil
	case inbounditem.FieldSku:
		m.ResetSku()
		return nil
	case inbounditem.FieldBarcode:
		m.ResetBarcode()
		return nil
	case inbounditem.FieldQty:
		m.ResetQty()
		return nil
	case inbounditem.FieldStatus:
		m.ResetStatus()
		return nil
	case inbounditem.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	}
	return fmt.Errorf("unknown InboundItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InboundItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, inbounditem.EdgeTenant)
	}
	if m.inbounds != nil {
		edges = append(edges, inbounditem.EdgeInbounds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InboundItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inbounditem.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case inbounditem.EdgeInbounds:
		if id := m.inbounds; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InboundItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InboundItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InboundItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, inbounditem.EdgeTenant)
	}
	if m.clearedinbounds {
		edges = append(edges, inbounditem.EdgeInbounds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InboundItemMutation) EdgeCleared(name string) bool {
	switch name {
	case inbounditem.EdgeTenant:
		return m.clearedtenant
	case inbounditem.EdgeInbounds:
		return m.clearedinbounds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InboundItemMutation) ClearEdge(name string) error {
	switch name {
	case inbounditem.EdgeTenant:
		m.ClearTenant()
		return nil
	case inbounditem.EdgeInbounds:
		m.ClearInbounds()
		return nil
	}
	return fmt.Errorf("unknown InboundItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InboundItemMutation) ResetEdge(name string) error {
	switch name {
	case inbounditem.EdgeTenant:
		m.ResetTenant()
		return nil
	case inbounditem.EdgeInbounds:
		m.ResetInbounds()
		return nil
	}
	return fmt.Errorf("unknown InboundItem edge %s", name)
}

// InventoryMutation represents an operation that mutates the Inventory nodes in the graph.
type InventoryMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int64
	created_at                        *time.Time
	updated_at                        *time.Time
	deleted_at                        *time.Time
	warehouse_id                      *int64
	addwarehouse_id                   *int64
	storage_qty                       *int32
	addstorage_qty                    *int32
	available_qty                     *int32
	addavailable_qty                  *int32
	prepare_ship_qty                  *int32
	addprepare_ship_qty               *int32
	prepare_shelve_qty                *int32
	addprepare_shelve_qty             *int32
	quicktron_storage_qty             *int32
	addquicktron_storage_qty          *int32
	quicktron_available_qty           *int32
	addquicktron_available_qty        *int32
	quicktron_prepare_outbound_qty    *int32
	addquicktron_prepare_outbound_qty *int32
	quicktron_prepare_shelve_qty      *int32
	addquicktron_prepare_shelve_qty   *int32
	normal_storage_qty                *int32
	addnormal_storage_qty             *int32
	normal_available_qty              *int32
	addnormal_available_qty           *int32
	normal_prepare_outbound_qty       *int32
	addnormal_prepare_outbound_qty    *int32
	normal_prepare_shelve_qty         *int32
	addnormal_prepare_shelve_qty      *int32
	status                            *int8
	addstatus                         *int8
	clearedFields                     map[string]struct{}
	tenant                            *int64
	clearedtenant                     bool
	products                          *int64
	clearedproducts                   bool
	done                              bool
	oldValue                          func(context.Context) (*Inventory, error)
	predicates                        []predicate.Inventory
}

var _ ent.Mutation = (*InventoryMutation)(nil)

// inventoryOption allows management of the mutation configuration using functional options.
type inventoryOption func(*InventoryMutation)

// newInventoryMutation creates new mutation for the Inventory entity.
func newInventoryMutation(c config, op Op, opts ...inventoryOption) *InventoryMutation {
	m := &InventoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInventory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryID sets the ID field of the mutation.
func withInventoryID(id int64) inventoryOption {
	return func(m *InventoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Inventory
		)
		m.oldValue = func(ctx context.Context) (*Inventory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inventory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventory sets the old Inventory of the mutation.
func withInventory(node *Inventory) inventoryOption {
	return func(m *InventoryMutation) {
		m.oldValue = func(context.Context) (*Inventory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inventory entities.
func (m *InventoryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inventory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InventoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InventoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InventoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InventoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InventoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InventoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inventory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InventoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inventory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InventoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inventory.FieldDeletedAt)
}

// SetProductID sets the "product_id" field.
func (m *InventoryMutation) SetProductID(i int64) {
	m.products = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *InventoryMutation) ProductID() (r int64, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *InventoryMutation) ClearProductID() {
	m.products = nil
	m.clearedFields[inventory.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *InventoryMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[inventory.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *InventoryMutation) ResetProductID() {
	m.products = nil
	delete(m.clearedFields, inventory.FieldProductID)
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *InventoryMutation) SetWarehouseID(i int64) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *InventoryMutation) WarehouseID() (r int64, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldWarehouseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *InventoryMutation) AddWarehouseID(i int64) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *InventoryMutation) AddedWarehouseID() (r int64, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *InventoryMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
}

// SetStorageQty sets the "storage_qty" field.
func (m *InventoryMutation) SetStorageQty(i int32) {
	m.storage_qty = &i
	m.addstorage_qty = nil
}

// StorageQty returns the value of the "storage_qty" field in the mutation.
func (m *InventoryMutation) StorageQty() (r int32, exists bool) {
	v := m.storage_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageQty returns the old "storage_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldStorageQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageQty: %w", err)
	}
	return oldValue.StorageQty, nil
}

// AddStorageQty adds i to the "storage_qty" field.
func (m *InventoryMutation) AddStorageQty(i int32) {
	if m.addstorage_qty != nil {
		*m.addstorage_qty += i
	} else {
		m.addstorage_qty = &i
	}
}

// AddedStorageQty returns the value that was added to the "storage_qty" field in this mutation.
func (m *InventoryMutation) AddedStorageQty() (r int32, exists bool) {
	v := m.addstorage_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetStorageQty resets all changes to the "storage_qty" field.
func (m *InventoryMutation) ResetStorageQty() {
	m.storage_qty = nil
	m.addstorage_qty = nil
}

// SetAvailableQty sets the "available_qty" field.
func (m *InventoryMutation) SetAvailableQty(i int32) {
	m.available_qty = &i
	m.addavailable_qty = nil
}

// AvailableQty returns the value of the "available_qty" field in the mutation.
func (m *InventoryMutation) AvailableQty() (r int32, exists bool) {
	v := m.available_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableQty returns the old "available_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldAvailableQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableQty: %w", err)
	}
	return oldValue.AvailableQty, nil
}

// AddAvailableQty adds i to the "available_qty" field.
func (m *InventoryMutation) AddAvailableQty(i int32) {
	if m.addavailable_qty != nil {
		*m.addavailable_qty += i
	} else {
		m.addavailable_qty = &i
	}
}

// AddedAvailableQty returns the value that was added to the "available_qty" field in this mutation.
func (m *InventoryMutation) AddedAvailableQty() (r int32, exists bool) {
	v := m.addavailable_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableQty resets all changes to the "available_qty" field.
func (m *InventoryMutation) ResetAvailableQty() {
	m.available_qty = nil
	m.addavailable_qty = nil
}

// SetPrepareShipQty sets the "prepare_ship_qty" field.
func (m *InventoryMutation) SetPrepareShipQty(i int32) {
	m.prepare_ship_qty = &i
	m.addprepare_ship_qty = nil
}

// PrepareShipQty returns the value of the "prepare_ship_qty" field in the mutation.
func (m *InventoryMutation) PrepareShipQty() (r int32, exists bool) {
	v := m.prepare_ship_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepareShipQty returns the old "prepare_ship_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldPrepareShipQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepareShipQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepareShipQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepareShipQty: %w", err)
	}
	return oldValue.PrepareShipQty, nil
}

// AddPrepareShipQty adds i to the "prepare_ship_qty" field.
func (m *InventoryMutation) AddPrepareShipQty(i int32) {
	if m.addprepare_ship_qty != nil {
		*m.addprepare_ship_qty += i
	} else {
		m.addprepare_ship_qty = &i
	}
}

// AddedPrepareShipQty returns the value that was added to the "prepare_ship_qty" field in this mutation.
func (m *InventoryMutation) AddedPrepareShipQty() (r int32, exists bool) {
	v := m.addprepare_ship_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrepareShipQty resets all changes to the "prepare_ship_qty" field.
func (m *InventoryMutation) ResetPrepareShipQty() {
	m.prepare_ship_qty = nil
	m.addprepare_ship_qty = nil
}

// SetPrepareShelveQty sets the "prepare_shelve_qty" field.
func (m *InventoryMutation) SetPrepareShelveQty(i int32) {
	m.prepare_shelve_qty = &i
	m.addprepare_shelve_qty = nil
}

// PrepareShelveQty returns the value of the "prepare_shelve_qty" field in the mutation.
func (m *InventoryMutation) PrepareShelveQty() (r int32, exists bool) {
	v := m.prepare_shelve_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepareShelveQty returns the old "prepare_shelve_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldPrepareShelveQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepareShelveQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepareShelveQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepareShelveQty: %w", err)
	}
	return oldValue.PrepareShelveQty, nil
}

// AddPrepareShelveQty adds i to the "prepare_shelve_qty" field.
func (m *InventoryMutation) AddPrepareShelveQty(i int32) {
	if m.addprepare_shelve_qty != nil {
		*m.addprepare_shelve_qty += i
	} else {
		m.addprepare_shelve_qty = &i
	}
}

// AddedPrepareShelveQty returns the value that was added to the "prepare_shelve_qty" field in this mutation.
func (m *InventoryMutation) AddedPrepareShelveQty() (r int32, exists bool) {
	v := m.addprepare_shelve_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrepareShelveQty resets all changes to the "prepare_shelve_qty" field.
func (m *InventoryMutation) ResetPrepareShelveQty() {
	m.prepare_shelve_qty = nil
	m.addprepare_shelve_qty = nil
}

// SetQuicktronStorageQty sets the "quicktron_storage_qty" field.
func (m *InventoryMutation) SetQuicktronStorageQty(i int32) {
	m.quicktron_storage_qty = &i
	m.addquicktron_storage_qty = nil
}

// QuicktronStorageQty returns the value of the "quicktron_storage_qty" field in the mutation.
func (m *InventoryMutation) QuicktronStorageQty() (r int32, exists bool) {
	v := m.quicktron_storage_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQuicktronStorageQty returns the old "quicktron_storage_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldQuicktronStorageQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuicktronStorageQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuicktronStorageQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuicktronStorageQty: %w", err)
	}
	return oldValue.QuicktronStorageQty, nil
}

// AddQuicktronStorageQty adds i to the "quicktron_storage_qty" field.
func (m *InventoryMutation) AddQuicktronStorageQty(i int32) {
	if m.addquicktron_storage_qty != nil {
		*m.addquicktron_storage_qty += i
	} else {
		m.addquicktron_storage_qty = &i
	}
}

// AddedQuicktronStorageQty returns the value that was added to the "quicktron_storage_qty" field in this mutation.
func (m *InventoryMutation) AddedQuicktronStorageQty() (r int32, exists bool) {
	v := m.addquicktron_storage_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuicktronStorageQty resets all changes to the "quicktron_storage_qty" field.
func (m *InventoryMutation) ResetQuicktronStorageQty() {
	m.quicktron_storage_qty = nil
	m.addquicktron_storage_qty = nil
}

// SetQuicktronAvailableQty sets the "quicktron_available_qty" field.
func (m *InventoryMutation) SetQuicktronAvailableQty(i int32) {
	m.quicktron_available_qty = &i
	m.addquicktron_available_qty = nil
}

// QuicktronAvailableQty returns the value of the "quicktron_available_qty" field in the mutation.
func (m *InventoryMutation) QuicktronAvailableQty() (r int32, exists bool) {
	v := m.quicktron_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQuicktronAvailableQty returns the old "quicktron_available_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldQuicktronAvailableQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuicktronAvailableQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuicktronAvailableQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuicktronAvailableQty: %w", err)
	}
	return oldValue.QuicktronAvailableQty, nil
}

// AddQuicktronAvailableQty adds i to the "quicktron_available_qty" field.
func (m *InventoryMutation) AddQuicktronAvailableQty(i int32) {
	if m.addquicktron_available_qty != nil {
		*m.addquicktron_available_qty += i
	} else {
		m.addquicktron_available_qty = &i
	}
}

// AddedQuicktronAvailableQty returns the value that was added to the "quicktron_available_qty" field in this mutation.
func (m *InventoryMutation) AddedQuicktronAvailableQty() (r int32, exists bool) {
	v := m.addquicktron_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuicktronAvailableQty resets all changes to the "quicktron_available_qty" field.
func (m *InventoryMutation) ResetQuicktronAvailableQty() {
	m.quicktron_available_qty = nil
	m.addquicktron_available_qty = nil
}

// SetQuicktronPrepareOutboundQty sets the "quicktron_prepare_outbound_qty" field.
func (m *InventoryMutation) SetQuicktronPrepareOutboundQty(i int32) {
	m.quicktron_prepare_outbound_qty = &i
	m.addquicktron_prepare_outbound_qty = nil
}

// QuicktronPrepareOutboundQty returns the value of the "quicktron_prepare_outbound_qty" field in the mutation.
func (m *InventoryMutation) QuicktronPrepareOutboundQty() (r int32, exists bool) {
	v := m.quicktron_prepare_outbound_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQuicktronPrepareOutboundQty returns the old "quicktron_prepare_outbound_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldQuicktronPrepareOutboundQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuicktronPrepareOutboundQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuicktronPrepareOutboundQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuicktronPrepareOutboundQty: %w", err)
	}
	return oldValue.QuicktronPrepareOutboundQty, nil
}

// AddQuicktronPrepareOutboundQty adds i to the "quicktron_prepare_outbound_qty" field.
func (m *InventoryMutation) AddQuicktronPrepareOutboundQty(i int32) {
	if m.addquicktron_prepare_outbound_qty != nil {
		*m.addquicktron_prepare_outbound_qty += i
	} else {
		m.addquicktron_prepare_outbound_qty = &i
	}
}

// AddedQuicktronPrepareOutboundQty returns the value that was added to the "quicktron_prepare_outbound_qty" field in this mutation.
func (m *InventoryMutation) AddedQuicktronPrepareOutboundQty() (r int32, exists bool) {
	v := m.addquicktron_prepare_outbound_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuicktronPrepareOutboundQty resets all changes to the "quicktron_prepare_outbound_qty" field.
func (m *InventoryMutation) ResetQuicktronPrepareOutboundQty() {
	m.quicktron_prepare_outbound_qty = nil
	m.addquicktron_prepare_outbound_qty = nil
}

// SetQuicktronPrepareShelveQty sets the "quicktron_prepare_shelve_qty" field.
func (m *InventoryMutation) SetQuicktronPrepareShelveQty(i int32) {
	m.quicktron_prepare_shelve_qty = &i
	m.addquicktron_prepare_shelve_qty = nil
}

// QuicktronPrepareShelveQty returns the value of the "quicktron_prepare_shelve_qty" field in the mutation.
func (m *InventoryMutation) QuicktronPrepareShelveQty() (r int32, exists bool) {
	v := m.quicktron_prepare_shelve_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQuicktronPrepareShelveQty returns the old "quicktron_prepare_shelve_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldQuicktronPrepareShelveQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuicktronPrepareShelveQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuicktronPrepareShelveQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuicktronPrepareShelveQty: %w", err)
	}
	return oldValue.QuicktronPrepareShelveQty, nil
}

// AddQuicktronPrepareShelveQty adds i to the "quicktron_prepare_shelve_qty" field.
func (m *InventoryMutation) AddQuicktronPrepareShelveQty(i int32) {
	if m.addquicktron_prepare_shelve_qty != nil {
		*m.addquicktron_prepare_shelve_qty += i
	} else {
		m.addquicktron_prepare_shelve_qty = &i
	}
}

// AddedQuicktronPrepareShelveQty returns the value that was added to the "quicktron_prepare_shelve_qty" field in this mutation.
func (m *InventoryMutation) AddedQuicktronPrepareShelveQty() (r int32, exists bool) {
	v := m.addquicktron_prepare_shelve_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuicktronPrepareShelveQty resets all changes to the "quicktron_prepare_shelve_qty" field.
func (m *InventoryMutation) ResetQuicktronPrepareShelveQty() {
	m.quicktron_prepare_shelve_qty = nil
	m.addquicktron_prepare_shelve_qty = nil
}

// SetNormalStorageQty sets the "normal_storage_qty" field.
func (m *InventoryMutation) SetNormalStorageQty(i int32) {
	m.normal_storage_qty = &i
	m.addnormal_storage_qty = nil
}

// NormalStorageQty returns the value of the "normal_storage_qty" field in the mutation.
func (m *InventoryMutation) NormalStorageQty() (r int32, exists bool) {
	v := m.normal_storage_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalStorageQty returns the old "normal_storage_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldNormalStorageQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalStorageQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalStorageQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalStorageQty: %w", err)
	}
	return oldValue.NormalStorageQty, nil
}

// AddNormalStorageQty adds i to the "normal_storage_qty" field.
func (m *InventoryMutation) AddNormalStorageQty(i int32) {
	if m.addnormal_storage_qty != nil {
		*m.addnormal_storage_qty += i
	} else {
		m.addnormal_storage_qty = &i
	}
}

// AddedNormalStorageQty returns the value that was added to the "normal_storage_qty" field in this mutation.
func (m *InventoryMutation) AddedNormalStorageQty() (r int32, exists bool) {
	v := m.addnormal_storage_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalStorageQty resets all changes to the "normal_storage_qty" field.
func (m *InventoryMutation) ResetNormalStorageQty() {
	m.normal_storage_qty = nil
	m.addnormal_storage_qty = nil
}

// SetNormalAvailableQty sets the "normal_available_qty" field.
func (m *InventoryMutation) SetNormalAvailableQty(i int32) {
	m.normal_available_qty = &i
	m.addnormal_available_qty = nil
}

// NormalAvailableQty returns the value of the "normal_available_qty" field in the mutation.
func (m *InventoryMutation) NormalAvailableQty() (r int32, exists bool) {
	v := m.normal_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalAvailableQty returns the old "normal_available_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldNormalAvailableQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalAvailableQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalAvailableQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalAvailableQty: %w", err)
	}
	return oldValue.NormalAvailableQty, nil
}

// AddNormalAvailableQty adds i to the "normal_available_qty" field.
func (m *InventoryMutation) AddNormalAvailableQty(i int32) {
	if m.addnormal_available_qty != nil {
		*m.addnormal_available_qty += i
	} else {
		m.addnormal_available_qty = &i
	}
}

// AddedNormalAvailableQty returns the value that was added to the "normal_available_qty" field in this mutation.
func (m *InventoryMutation) AddedNormalAvailableQty() (r int32, exists bool) {
	v := m.addnormal_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalAvailableQty resets all changes to the "normal_available_qty" field.
func (m *InventoryMutation) ResetNormalAvailableQty() {
	m.normal_available_qty = nil
	m.addnormal_available_qty = nil
}

// SetNormalPrepareOutboundQty sets the "normal_prepare_outbound_qty" field.
func (m *InventoryMutation) SetNormalPrepareOutboundQty(i int32) {
	m.normal_prepare_outbound_qty = &i
	m.addnormal_prepare_outbound_qty = nil
}

// NormalPrepareOutboundQty returns the value of the "normal_prepare_outbound_qty" field in the mutation.
func (m *InventoryMutation) NormalPrepareOutboundQty() (r int32, exists bool) {
	v := m.normal_prepare_outbound_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalPrepareOutboundQty returns the old "normal_prepare_outbound_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldNormalPrepareOutboundQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalPrepareOutboundQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalPrepareOutboundQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalPrepareOutboundQty: %w", err)
	}
	return oldValue.NormalPrepareOutboundQty, nil
}

// AddNormalPrepareOutboundQty adds i to the "normal_prepare_outbound_qty" field.
func (m *InventoryMutation) AddNormalPrepareOutboundQty(i int32) {
	if m.addnormal_prepare_outbound_qty != nil {
		*m.addnormal_prepare_outbound_qty += i
	} else {
		m.addnormal_prepare_outbound_qty = &i
	}
}

// AddedNormalPrepareOutboundQty returns the value that was added to the "normal_prepare_outbound_qty" field in this mutation.
func (m *InventoryMutation) AddedNormalPrepareOutboundQty() (r int32, exists bool) {
	v := m.addnormal_prepare_outbound_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalPrepareOutboundQty resets all changes to the "normal_prepare_outbound_qty" field.
func (m *InventoryMutation) ResetNormalPrepareOutboundQty() {
	m.normal_prepare_outbound_qty = nil
	m.addnormal_prepare_outbound_qty = nil
}

// SetNormalPrepareShelveQty sets the "normal_prepare_shelve_qty" field.
func (m *InventoryMutation) SetNormalPrepareShelveQty(i int32) {
	m.normal_prepare_shelve_qty = &i
	m.addnormal_prepare_shelve_qty = nil
}

// NormalPrepareShelveQty returns the value of the "normal_prepare_shelve_qty" field in the mutation.
func (m *InventoryMutation) NormalPrepareShelveQty() (r int32, exists bool) {
	v := m.normal_prepare_shelve_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalPrepareShelveQty returns the old "normal_prepare_shelve_qty" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldNormalPrepareShelveQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalPrepareShelveQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalPrepareShelveQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalPrepareShelveQty: %w", err)
	}
	return oldValue.NormalPrepareShelveQty, nil
}

// AddNormalPrepareShelveQty adds i to the "normal_prepare_shelve_qty" field.
func (m *InventoryMutation) AddNormalPrepareShelveQty(i int32) {
	if m.addnormal_prepare_shelve_qty != nil {
		*m.addnormal_prepare_shelve_qty += i
	} else {
		m.addnormal_prepare_shelve_qty = &i
	}
}

// AddedNormalPrepareShelveQty returns the value that was added to the "normal_prepare_shelve_qty" field in this mutation.
func (m *InventoryMutation) AddedNormalPrepareShelveQty() (r int32, exists bool) {
	v := m.addnormal_prepare_shelve_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetNormalPrepareShelveQty resets all changes to the "normal_prepare_shelve_qty" field.
func (m *InventoryMutation) ResetNormalPrepareShelveQty() {
	m.normal_prepare_shelve_qty = nil
	m.addnormal_prepare_shelve_qty = nil
}

// SetStatus sets the "status" field.
func (m *InventoryMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *InventoryMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *InventoryMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *InventoryMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *InventoryMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *InventoryMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InventoryMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InventoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *InventoryMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InventoryMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InventoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductsID sets the "products" edge to the Product entity by id.
func (m *InventoryMutation) SetProductsID(id int64) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *InventoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *InventoryMutation) ProductsCleared() bool {
	return m.ProductIDCleared() || m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *InventoryMutation) ProductsID() (id int64, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *InventoryMutation) ProductsIDs() (ids []int64) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *InventoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// Where appends a list predicates to the InventoryMutation builder.
func (m *InventoryMutation) Where(ps ...predicate.Inventory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InventoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inventory).
func (m *InventoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, inventory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inventory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.products != nil {
		fields = append(fields, inventory.FieldProductID)
	}
	if m.warehouse_id != nil {
		fields = append(fields, inventory.FieldWarehouseID)
	}
	if m.storage_qty != nil {
		fields = append(fields, inventory.FieldStorageQty)
	}
	if m.available_qty != nil {
		fields = append(fields, inventory.FieldAvailableQty)
	}
	if m.prepare_ship_qty != nil {
		fields = append(fields, inventory.FieldPrepareShipQty)
	}
	if m.prepare_shelve_qty != nil {
		fields = append(fields, inventory.FieldPrepareShelveQty)
	}
	if m.quicktron_storage_qty != nil {
		fields = append(fields, inventory.FieldQuicktronStorageQty)
	}
	if m.quicktron_available_qty != nil {
		fields = append(fields, inventory.FieldQuicktronAvailableQty)
	}
	if m.quicktron_prepare_outbound_qty != nil {
		fields = append(fields, inventory.FieldQuicktronPrepareOutboundQty)
	}
	if m.quicktron_prepare_shelve_qty != nil {
		fields = append(fields, inventory.FieldQuicktronPrepareShelveQty)
	}
	if m.normal_storage_qty != nil {
		fields = append(fields, inventory.FieldNormalStorageQty)
	}
	if m.normal_available_qty != nil {
		fields = append(fields, inventory.FieldNormalAvailableQty)
	}
	if m.normal_prepare_outbound_qty != nil {
		fields = append(fields, inventory.FieldNormalPrepareOutboundQty)
	}
	if m.normal_prepare_shelve_qty != nil {
		fields = append(fields, inventory.FieldNormalPrepareShelveQty)
	}
	if m.status != nil {
		fields = append(fields, inventory.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.CreatedAt()
	case inventory.FieldUpdatedAt:
		return m.UpdatedAt()
	case inventory.FieldDeletedAt:
		return m.DeletedAt()
	case inventory.FieldProductID:
		return m.ProductID()
	case inventory.FieldWarehouseID:
		return m.WarehouseID()
	case inventory.FieldStorageQty:
		return m.StorageQty()
	case inventory.FieldAvailableQty:
		return m.AvailableQty()
	case inventory.FieldPrepareShipQty:
		return m.PrepareShipQty()
	case inventory.FieldPrepareShelveQty:
		return m.PrepareShelveQty()
	case inventory.FieldQuicktronStorageQty:
		return m.QuicktronStorageQty()
	case inventory.FieldQuicktronAvailableQty:
		return m.QuicktronAvailableQty()
	case inventory.FieldQuicktronPrepareOutboundQty:
		return m.QuicktronPrepareOutboundQty()
	case inventory.FieldQuicktronPrepareShelveQty:
		return m.QuicktronPrepareShelveQty()
	case inventory.FieldNormalStorageQty:
		return m.NormalStorageQty()
	case inventory.FieldNormalAvailableQty:
		return m.NormalAvailableQty()
	case inventory.FieldNormalPrepareOutboundQty:
		return m.NormalPrepareOutboundQty()
	case inventory.FieldNormalPrepareShelveQty:
		return m.NormalPrepareShelveQty()
	case inventory.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inventory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inventory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inventory.FieldProductID:
		return m.OldProductID(ctx)
	case inventory.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case inventory.FieldStorageQty:
		return m.OldStorageQty(ctx)
	case inventory.FieldAvailableQty:
		return m.OldAvailableQty(ctx)
	case inventory.FieldPrepareShipQty:
		return m.OldPrepareShipQty(ctx)
	case inventory.FieldPrepareShelveQty:
		return m.OldPrepareShelveQty(ctx)
	case inventory.FieldQuicktronStorageQty:
		return m.OldQuicktronStorageQty(ctx)
	case inventory.FieldQuicktronAvailableQty:
		return m.OldQuicktronAvailableQty(ctx)
	case inventory.FieldQuicktronPrepareOutboundQty:
		return m.OldQuicktronPrepareOutboundQty(ctx)
	case inventory.FieldQuicktronPrepareShelveQty:
		return m.OldQuicktronPrepareShelveQty(ctx)
	case inventory.FieldNormalStorageQty:
		return m.OldNormalStorageQty(ctx)
	case inventory.FieldNormalAvailableQty:
		return m.OldNormalAvailableQty(ctx)
	case inventory.FieldNormalPrepareOutboundQty:
		return m.OldNormalPrepareOutboundQty(ctx)
	case inventory.FieldNormalPrepareShelveQty:
		return m.OldNormalPrepareShelveQty(ctx)
	case inventory.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Inventory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inventory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inventory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inventory.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case inventory.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case inventory.FieldStorageQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageQty(v)
		return nil
	case inventory.FieldAvailableQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableQty(v)
		return nil
	case inventory.FieldPrepareShipQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepareShipQty(v)
		return nil
	case inventory.FieldPrepareShelveQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepareShelveQty(v)
		return nil
	case inventory.FieldQuicktronStorageQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuicktronStorageQty(v)
		return nil
	case inventory.FieldQuicktronAvailableQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuicktronAvailableQty(v)
		return nil
	case inventory.FieldQuicktronPrepareOutboundQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuicktronPrepareOutboundQty(v)
		return nil
	case inventory.FieldQuicktronPrepareShelveQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuicktronPrepareShelveQty(v)
		return nil
	case inventory.FieldNormalStorageQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalStorageQty(v)
		return nil
	case inventory.FieldNormalAvailableQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalAvailableQty(v)
		return nil
	case inventory.FieldNormalPrepareOutboundQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalPrepareOutboundQty(v)
		return nil
	case inventory.FieldNormalPrepareShelveQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalPrepareShelveQty(v)
		return nil
	case inventory.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryMutation) AddedFields() []string {
	var fields []string
	if m.addwarehouse_id != nil {
		fields = append(fields, inventory.FieldWarehouseID)
	}
	if m.addstorage_qty != nil {
		fields = append(fields, inventory.FieldStorageQty)
	}
	if m.addavailable_qty != nil {
		fields = append(fields, inventory.FieldAvailableQty)
	}
	if m.addprepare_ship_qty != nil {
		fields = append(fields, inventory.FieldPrepareShipQty)
	}
	if m.addprepare_shelve_qty != nil {
		fields = append(fields, inventory.FieldPrepareShelveQty)
	}
	if m.addquicktron_storage_qty != nil {
		fields = append(fields, inventory.FieldQuicktronStorageQty)
	}
	if m.addquicktron_available_qty != nil {
		fields = append(fields, inventory.FieldQuicktronAvailableQty)
	}
	if m.addquicktron_prepare_outbound_qty != nil {
		fields = append(fields, inventory.FieldQuicktronPrepareOutboundQty)
	}
	if m.addquicktron_prepare_shelve_qty != nil {
		fields = append(fields, inventory.FieldQuicktronPrepareShelveQty)
	}
	if m.addnormal_storage_qty != nil {
		fields = append(fields, inventory.FieldNormalStorageQty)
	}
	if m.addnormal_available_qty != nil {
		fields = append(fields, inventory.FieldNormalAvailableQty)
	}
	if m.addnormal_prepare_outbound_qty != nil {
		fields = append(fields, inventory.FieldNormalPrepareOutboundQty)
	}
	if m.addnormal_prepare_shelve_qty != nil {
		fields = append(fields, inventory.FieldNormalPrepareShelveQty)
	}
	if m.addstatus != nil {
		fields = append(fields, inventory.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventory.FieldWarehouseID:
		return m.AddedWarehouseID()
	case inventory.FieldStorageQty:
		return m.AddedStorageQty()
	case inventory.FieldAvailableQty:
		return m.AddedAvailableQty()
	case inventory.FieldPrepareShipQty:
		return m.AddedPrepareShipQty()
	case inventory.FieldPrepareShelveQty:
		return m.AddedPrepareShelveQty()
	case inventory.FieldQuicktronStorageQty:
		return m.AddedQuicktronStorageQty()
	case inventory.FieldQuicktronAvailableQty:
		return m.AddedQuicktronAvailableQty()
	case inventory.FieldQuicktronPrepareOutboundQty:
		return m.AddedQuicktronPrepareOutboundQty()
	case inventory.FieldQuicktronPrepareShelveQty:
		return m.AddedQuicktronPrepareShelveQty()
	case inventory.FieldNormalStorageQty:
		return m.AddedNormalStorageQty()
	case inventory.FieldNormalAvailableQty:
		return m.AddedNormalAvailableQty()
	case inventory.FieldNormalPrepareOutboundQty:
		return m.AddedNormalPrepareOutboundQty()
	case inventory.FieldNormalPrepareShelveQty:
		return m.AddedNormalPrepareShelveQty()
	case inventory.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventory.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case inventory.FieldStorageQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageQty(v)
		return nil
	case inventory.FieldAvailableQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableQty(v)
		return nil
	case inventory.FieldPrepareShipQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrepareShipQty(v)
		return nil
	case inventory.FieldPrepareShelveQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrepareShelveQty(v)
		return nil
	case inventory.FieldQuicktronStorageQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuicktronStorageQty(v)
		return nil
	case inventory.FieldQuicktronAvailableQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuicktronAvailableQty(v)
		return nil
	case inventory.FieldQuicktronPrepareOutboundQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuicktronPrepareOutboundQty(v)
		return nil
	case inventory.FieldQuicktronPrepareShelveQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuicktronPrepareShelveQty(v)
		return nil
	case inventory.FieldNormalStorageQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalStorageQty(v)
		return nil
	case inventory.FieldNormalAvailableQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalAvailableQty(v)
		return nil
	case inventory.FieldNormalPrepareOutboundQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalPrepareOutboundQty(v)
		return nil
	case inventory.FieldNormalPrepareShelveQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNormalPrepareShelveQty(v)
		return nil
	case inventory.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Inventory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventory.FieldDeletedAt) {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.FieldCleared(inventory.FieldProductID) {
		fields = append(fields, inventory.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryMutation) ClearField(name string) error {
	switch name {
	case inventory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case inventory.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown Inventory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryMutation) ResetField(name string) error {
	switch name {
	case inventory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inventory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inventory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inventory.FieldProductID:
		m.ResetProductID()
		return nil
	case inventory.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case inventory.FieldStorageQty:
		m.ResetStorageQty()
		return nil
	case inventory.FieldAvailableQty:
		m.ResetAvailableQty()
		return nil
	case inventory.FieldPrepareShipQty:
		m.ResetPrepareShipQty()
		return nil
	case inventory.FieldPrepareShelveQty:
		m.ResetPrepareShelveQty()
		return nil
	case inventory.FieldQuicktronStorageQty:
		m.ResetQuicktronStorageQty()
		return nil
	case inventory.FieldQuicktronAvailableQty:
		m.ResetQuicktronAvailableQty()
		return nil
	case inventory.FieldQuicktronPrepareOutboundQty:
		m.ResetQuicktronPrepareOutboundQty()
		return nil
	case inventory.FieldQuicktronPrepareShelveQty:
		m.ResetQuicktronPrepareShelveQty()
		return nil
	case inventory.FieldNormalStorageQty:
		m.ResetNormalStorageQty()
		return nil
	case inventory.FieldNormalAvailableQty:
		m.ResetNormalAvailableQty()
		return nil
	case inventory.FieldNormalPrepareOutboundQty:
		m.ResetNormalPrepareOutboundQty()
		return nil
	case inventory.FieldNormalPrepareShelveQty:
		m.ResetNormalPrepareShelveQty()
		return nil
	case inventory.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, inventory.EdgeTenant)
	}
	if m.products != nil {
		edges = append(edges, inventory.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case inventory.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, inventory.EdgeTenant)
	}
	if m.clearedproducts {
		edges = append(edges, inventory.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryMutation) EdgeCleared(name string) bool {
	switch name {
	case inventory.EdgeTenant:
		return m.clearedtenant
	case inventory.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryMutation) ClearEdge(name string) error {
	switch name {
	case inventory.EdgeTenant:
		m.ClearTenant()
		return nil
	case inventory.EdgeProducts:
		m.ClearProducts()
		return nil
	}
	return fmt.Errorf("unknown Inventory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryMutation) ResetEdge(name string) error {
	switch name {
	case inventory.EdgeTenant:
		m.ResetTenant()
		return nil
	case inventory.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Inventory edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	order_number                    *string
	mode                            *int8
	addmode                         *int8
	_type                           *int8
	add_type                        *int8
	offline                         *bool
	customer_code                   *string
	prepay_tariff                   *bool
	ioss_number                     *string
	ioss_country_code               *string
	ioss_number_type                *int8
	addioss_number_type             *int8
	uk_vat_number                   *string
	inbound_order_number            *string
	status                          *int8
	addstatus                       *int8
	sqs_status                      *bool
	hold_status                     *bool
	payment_status                  *int8
	addpayment_status               *int8
	cancel_request                  *int8
	addcancel_request               *int8
	platform                        *string
	platform_order_id               *string
	platform_order_no               *string
	platform_order_status_url       *string
	platform_status                 *string
	paid_status                     *string
	fulfillment_pushed              *bool
	fulfillment_status              *string
	platform_created_at             *time.Time
	location_id                     *string
	tags                            *string
	note                            *string
	cancel_reason                   *string
	cancelled_at                    *time.Time
	closed_at                       *time.Time
	contact_email                   *string
	contact_phone                   *string
	shipping_name                   *string
	shipping_first_name             *string
	shipping_last_name              *string
	shipping_company                *string
	shipping_country                *string
	shipping_country_code           *string
	shipping_province               *string
	shipping_province_code          *string
	shipping_city                   *string
	shipping_address1               *string
	shipping_address2               *string
	shipping_zip_code               *string
	shipping_phone                  *string
	shipping_certificate_type       *string
	shipping_certificate_code       *string
	shipping_credentials_period     *string
	remark                          *string
	prefer_shipped_type             *int8
	addprefer_shipped_type          *int8
	prefer_channel_id               *int64
	addprefer_channel_id            *int64
	channel_options                 *string
	channel_cost_id                 *int64
	addchannel_cost_id              *int64
	ship_type                       *int8
	addship_type                    *int8
	tracking_company                *string
	tracking_number                 *string
	tracking_url                    *string
	waybill_number                  *string
	courier_order_number            *string
	nss_courier_order_number        *string
	nss_tracking_number             *string
	nss_tracking_url                *string
	shipping_label_url              *string
	shipping_label_path             *string
	label_data_path                 *string
	package_id                      *string
	ship_date                       *time.Time
	request_shipping_at             *time.Time
	unshelf_requested_time          *time.Time
	container_code                  *string
	basket_number                   *string
	print_times                     *int
	addprint_times                  *int
	sorting_tracking_number         *string
	sorting_port                    *int32
	addsorting_port                 *int32
	sorting_length                  *int
	addsorting_length               *int
	sorting_width                   *int
	addsorting_width                *int
	sorting_height                  *int
	addsorting_height               *int
	sorting_weight                  *int
	addsorting_weight               *int
	estimated_weight                *int
	addestimated_weight             *int
	checkout_actual_weight          *int
	addcheckout_actual_weight       *int
	volume_weight                   *int
	addvolume_weight                *int
	courier_weight                  *int
	addcourier_weight               *int
	declared_value_in_usd           *float64
	adddeclared_value_in_usd        *float64
	declared_value_in_eur           *float64
	adddeclared_value_in_eur        *float64
	total_items_price               *float64
	addtotal_items_price            *float64
	currency                        *string
	delivery_cost                   *float64
	adddelivery_cost                *float64
	misc_fee                        *float64
	addmisc_fee                     *float64
	fuel_fee                        *float64
	addfuel_fee                     *float64
	registration_fee                *float64
	addregistration_fee             *float64
	processing_fee                  *float64
	addprocessing_fee               *float64
	package_fee                     *float64
	addpackage_fee                  *float64
	handling_fee                    *float64
	addhandling_fee                 *float64
	vat                             *float64
	addvat                          *float64
	estimated_cost                  *float64
	addestimated_cost               *float64
	estimated_currency              *string
	receivables_amount              *float64
	addreceivables_amount           *float64
	receivables_currency            *string
	not_accept_platform_update      *bool
	not_accept_platform_update_item *bool
	jd_pushed_status                *string
	clearedFields                   map[string]struct{}
	tenant                          *int64
	clearedtenant                   bool
	order_items                     map[int64]struct{}
	removedorder_items              map[int64]struct{}
	clearedorder_items              bool
	order_hold_reasons              map[int64]struct{}
	removedorder_hold_reasons       map[int64]struct{}
	clearedorder_hold_reasons       bool
	order_taxations                 map[int64]struct{}
	removedorder_taxations          map[int64]struct{}
	clearedorder_taxations          bool
	stores                          *int64
	clearedstores                   bool
	warehouses                      *int64
	clearedwarehouses               bool
	channels                        *int64
	clearedchannels                 bool
	track_mappings                  map[int64]struct{}
	removedtrack_mappings           map[int64]struct{}
	clearedtrack_mappings           bool
	done                            bool
	oldValue                        func(context.Context) (*Order, error)
	predicates                      []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[order.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, order.FieldDeletedAt)
}

// SetOrderNumber sets the "order_number" field.
func (m *OrderMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *OrderMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *OrderMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetMode sets the "mode" field.
func (m *OrderMutation) SetMode(i int8) {
	m.mode = &i
	m.addmode = nil
}

// Mode returns the value of the "mode" field in the mutation.
func (m *OrderMutation) Mode() (r int8, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMode(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// AddMode adds i to the "mode" field.
func (m *OrderMutation) AddMode(i int8) {
	if m.addmode != nil {
		*m.addmode += i
	} else {
		m.addmode = &i
	}
}

// AddedMode returns the value that was added to the "mode" field in this mutation.
func (m *OrderMutation) AddedMode() (r int8, exists bool) {
	v := m.addmode
	if v == nil {
		return
	}
	return *v, true
}

// ResetMode resets all changes to the "mode" field.
func (m *OrderMutation) ResetMode() {
	m.mode = nil
	m.addmode = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *OrderMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetOffline sets the "offline" field.
func (m *OrderMutation) SetOffline(b bool) {
	m.offline = &b
}

// Offline returns the value of the "offline" field in the mutation.
func (m *OrderMutation) Offline() (r bool, exists bool) {
	v := m.offline
	if v == nil {
		return
	}
	return *v, true
}

// OldOffline returns the old "offline" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOffline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOffline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOffline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOffline: %w", err)
	}
	return oldValue.Offline, nil
}

// ResetOffline resets all changes to the "offline" field.
func (m *OrderMutation) ResetOffline() {
	m.offline = nil
}

// SetStoreID sets the "store_id" field.
func (m *OrderMutation) SetStoreID(i int64) {
	m.stores = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *OrderMutation) StoreID() (r int64, exists bool) {
	v := m.stores
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStoreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *OrderMutation) ClearStoreID() {
	m.stores = nil
	m.clearedFields[order.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *OrderMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[order.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *OrderMutation) ResetStoreID() {
	m.stores = nil
	delete(m.clearedFields, order.FieldStoreID)
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *OrderMutation) SetWarehouseID(i int64) {
	m.warehouses = &i
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *OrderMutation) WarehouseID() (r int64, exists bool) {
	v := m.warehouses
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldWarehouseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// ClearWarehouseID clears the value of the "warehouse_id" field.
func (m *OrderMutation) ClearWarehouseID() {
	m.warehouses = nil
	m.clearedFields[order.FieldWarehouseID] = struct{}{}
}

// WarehouseIDCleared returns if the "warehouse_id" field was cleared in this mutation.
func (m *OrderMutation) WarehouseIDCleared() bool {
	_, ok := m.clearedFields[order.FieldWarehouseID]
	return ok
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *OrderMutation) ResetWarehouseID() {
	m.warehouses = nil
	delete(m.clearedFields, order.FieldWarehouseID)
}

// SetCustomerCode sets the "customer_code" field.
func (m *OrderMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *OrderMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCustomerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *OrderMutation) ResetCustomerCode() {
	m.customer_code = nil
}

// SetPrepayTariff sets the "prepay_tariff" field.
func (m *OrderMutation) SetPrepayTariff(b bool) {
	m.prepay_tariff = &b
}

// PrepayTariff returns the value of the "prepay_tariff" field in the mutation.
func (m *OrderMutation) PrepayTariff() (r bool, exists bool) {
	v := m.prepay_tariff
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepayTariff returns the old "prepay_tariff" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPrepayTariff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepayTariff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepayTariff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepayTariff: %w", err)
	}
	return oldValue.PrepayTariff, nil
}

// ResetPrepayTariff resets all changes to the "prepay_tariff" field.
func (m *OrderMutation) ResetPrepayTariff() {
	m.prepay_tariff = nil
}

// SetIossNumber sets the "ioss_number" field.
func (m *OrderMutation) SetIossNumber(s string) {
	m.ioss_number = &s
}

// IossNumber returns the value of the "ioss_number" field in the mutation.
func (m *OrderMutation) IossNumber() (r string, exists bool) {
	v := m.ioss_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIossNumber returns the old "ioss_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIossNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossNumber: %w", err)
	}
	return oldValue.IossNumber, nil
}

// ResetIossNumber resets all changes to the "ioss_number" field.
func (m *OrderMutation) ResetIossNumber() {
	m.ioss_number = nil
}

// SetIossCountryCode sets the "ioss_country_code" field.
func (m *OrderMutation) SetIossCountryCode(s string) {
	m.ioss_country_code = &s
}

// IossCountryCode returns the value of the "ioss_country_code" field in the mutation.
func (m *OrderMutation) IossCountryCode() (r string, exists bool) {
	v := m.ioss_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIossCountryCode returns the old "ioss_country_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIossCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossCountryCode: %w", err)
	}
	return oldValue.IossCountryCode, nil
}

// ResetIossCountryCode resets all changes to the "ioss_country_code" field.
func (m *OrderMutation) ResetIossCountryCode() {
	m.ioss_country_code = nil
}

// SetIossNumberType sets the "ioss_number_type" field.
func (m *OrderMutation) SetIossNumberType(i int8) {
	m.ioss_number_type = &i
	m.addioss_number_type = nil
}

// IossNumberType returns the value of the "ioss_number_type" field in the mutation.
func (m *OrderMutation) IossNumberType() (r int8, exists bool) {
	v := m.ioss_number_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIossNumberType returns the old "ioss_number_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldIossNumberType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossNumberType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossNumberType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossNumberType: %w", err)
	}
	return oldValue.IossNumberType, nil
}

// AddIossNumberType adds i to the "ioss_number_type" field.
func (m *OrderMutation) AddIossNumberType(i int8) {
	if m.addioss_number_type != nil {
		*m.addioss_number_type += i
	} else {
		m.addioss_number_type = &i
	}
}

// AddedIossNumberType returns the value that was added to the "ioss_number_type" field in this mutation.
func (m *OrderMutation) AddedIossNumberType() (r int8, exists bool) {
	v := m.addioss_number_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetIossNumberType resets all changes to the "ioss_number_type" field.
func (m *OrderMutation) ResetIossNumberType() {
	m.ioss_number_type = nil
	m.addioss_number_type = nil
}

// SetUkVatNumber sets the "uk_vat_number" field.
func (m *OrderMutation) SetUkVatNumber(s string) {
	m.uk_vat_number = &s
}

// UkVatNumber returns the value of the "uk_vat_number" field in the mutation.
func (m *OrderMutation) UkVatNumber() (r string, exists bool) {
	v := m.uk_vat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldUkVatNumber returns the old "uk_vat_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUkVatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUkVatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUkVatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUkVatNumber: %w", err)
	}
	return oldValue.UkVatNumber, nil
}

// ResetUkVatNumber resets all changes to the "uk_vat_number" field.
func (m *OrderMutation) ResetUkVatNumber() {
	m.uk_vat_number = nil
}

// SetInboundOrderNumber sets the "inbound_order_number" field.
func (m *OrderMutation) SetInboundOrderNumber(s string) {
	m.inbound_order_number = &s
}

// InboundOrderNumber returns the value of the "inbound_order_number" field in the mutation.
func (m *OrderMutation) InboundOrderNumber() (r string, exists bool) {
	v := m.inbound_order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldInboundOrderNumber returns the old "inbound_order_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldInboundOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInboundOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInboundOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInboundOrderNumber: %w", err)
	}
	return oldValue.InboundOrderNumber, nil
}

// ResetInboundOrderNumber resets all changes to the "inbound_order_number" field.
func (m *OrderMutation) ResetInboundOrderNumber() {
	m.inbound_order_number = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSqsStatus sets the "sqs_status" field.
func (m *OrderMutation) SetSqsStatus(b bool) {
	m.sqs_status = &b
}

// SqsStatus returns the value of the "sqs_status" field in the mutation.
func (m *OrderMutation) SqsStatus() (r bool, exists bool) {
	v := m.sqs_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSqsStatus returns the old "sqs_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSqsStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSqsStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSqsStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSqsStatus: %w", err)
	}
	return oldValue.SqsStatus, nil
}

// ClearSqsStatus clears the value of the "sqs_status" field.
func (m *OrderMutation) ClearSqsStatus() {
	m.sqs_status = nil
	m.clearedFields[order.FieldSqsStatus] = struct{}{}
}

// SqsStatusCleared returns if the "sqs_status" field was cleared in this mutation.
func (m *OrderMutation) SqsStatusCleared() bool {
	_, ok := m.clearedFields[order.FieldSqsStatus]
	return ok
}

// ResetSqsStatus resets all changes to the "sqs_status" field.
func (m *OrderMutation) ResetSqsStatus() {
	m.sqs_status = nil
	delete(m.clearedFields, order.FieldSqsStatus)
}

// SetHoldStatus sets the "hold_status" field.
func (m *OrderMutation) SetHoldStatus(b bool) {
	m.hold_status = &b
}

// HoldStatus returns the value of the "hold_status" field in the mutation.
func (m *OrderMutation) HoldStatus() (r bool, exists bool) {
	v := m.hold_status
	if v == nil {
		return
	}
	return *v, true
}

// OldHoldStatus returns the old "hold_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldHoldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoldStatus: %w", err)
	}
	return oldValue.HoldStatus, nil
}

// ClearHoldStatus clears the value of the "hold_status" field.
func (m *OrderMutation) ClearHoldStatus() {
	m.hold_status = nil
	m.clearedFields[order.FieldHoldStatus] = struct{}{}
}

// HoldStatusCleared returns if the "hold_status" field was cleared in this mutation.
func (m *OrderMutation) HoldStatusCleared() bool {
	_, ok := m.clearedFields[order.FieldHoldStatus]
	return ok
}

// ResetHoldStatus resets all changes to the "hold_status" field.
func (m *OrderMutation) ResetHoldStatus() {
	m.hold_status = nil
	delete(m.clearedFields, order.FieldHoldStatus)
}

// SetPaymentStatus sets the "payment_status" field.
func (m *OrderMutation) SetPaymentStatus(i int8) {
	m.payment_status = &i
	m.addpayment_status = nil
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *OrderMutation) PaymentStatus() (r int8, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaymentStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// AddPaymentStatus adds i to the "payment_status" field.
func (m *OrderMutation) AddPaymentStatus(i int8) {
	if m.addpayment_status != nil {
		*m.addpayment_status += i
	} else {
		m.addpayment_status = &i
	}
}

// AddedPaymentStatus returns the value that was added to the "payment_status" field in this mutation.
func (m *OrderMutation) AddedPaymentStatus() (r int8, exists bool) {
	v := m.addpayment_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentStatus clears the value of the "payment_status" field.
func (m *OrderMutation) ClearPaymentStatus() {
	m.payment_status = nil
	m.addpayment_status = nil
	m.clearedFields[order.FieldPaymentStatus] = struct{}{}
}

// PaymentStatusCleared returns if the "payment_status" field was cleared in this mutation.
func (m *OrderMutation) PaymentStatusCleared() bool {
	_, ok := m.clearedFields[order.FieldPaymentStatus]
	return ok
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *OrderMutation) ResetPaymentStatus() {
	m.payment_status = nil
	m.addpayment_status = nil
	delete(m.clearedFields, order.FieldPaymentStatus)
}

// SetCancelRequest sets the "cancel_request" field.
func (m *OrderMutation) SetCancelRequest(i int8) {
	m.cancel_request = &i
	m.addcancel_request = nil
}

// CancelRequest returns the value of the "cancel_request" field in the mutation.
func (m *OrderMutation) CancelRequest() (r int8, exists bool) {
	v := m.cancel_request
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelRequest returns the old "cancel_request" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCancelRequest(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelRequest: %w", err)
	}
	return oldValue.CancelRequest, nil
}

// AddCancelRequest adds i to the "cancel_request" field.
func (m *OrderMutation) AddCancelRequest(i int8) {
	if m.addcancel_request != nil {
		*m.addcancel_request += i
	} else {
		m.addcancel_request = &i
	}
}

// AddedCancelRequest returns the value that was added to the "cancel_request" field in this mutation.
func (m *OrderMutation) AddedCancelRequest() (r int8, exists bool) {
	v := m.addcancel_request
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelRequest clears the value of the "cancel_request" field.
func (m *OrderMutation) ClearCancelRequest() {
	m.cancel_request = nil
	m.addcancel_request = nil
	m.clearedFields[order.FieldCancelRequest] = struct{}{}
}

// CancelRequestCleared returns if the "cancel_request" field was cleared in this mutation.
func (m *OrderMutation) CancelRequestCleared() bool {
	_, ok := m.clearedFields[order.FieldCancelRequest]
	return ok
}

// ResetCancelRequest resets all changes to the "cancel_request" field.
func (m *OrderMutation) ResetCancelRequest() {
	m.cancel_request = nil
	m.addcancel_request = nil
	delete(m.clearedFields, order.FieldCancelRequest)
}

// SetPlatform sets the "platform" field.
func (m *OrderMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *OrderMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *OrderMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformOrderID sets the "platform_order_id" field.
func (m *OrderMutation) SetPlatformOrderID(s string) {
	m.platform_order_id = &s
}

// PlatformOrderID returns the value of the "platform_order_id" field in the mutation.
func (m *OrderMutation) PlatformOrderID() (r string, exists bool) {
	v := m.platform_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformOrderID returns the old "platform_order_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlatformOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformOrderID: %w", err)
	}
	return oldValue.PlatformOrderID, nil
}

// ClearPlatformOrderID clears the value of the "platform_order_id" field.
func (m *OrderMutation) ClearPlatformOrderID() {
	m.platform_order_id = nil
	m.clearedFields[order.FieldPlatformOrderID] = struct{}{}
}

// PlatformOrderIDCleared returns if the "platform_order_id" field was cleared in this mutation.
func (m *OrderMutation) PlatformOrderIDCleared() bool {
	_, ok := m.clearedFields[order.FieldPlatformOrderID]
	return ok
}

// ResetPlatformOrderID resets all changes to the "platform_order_id" field.
func (m *OrderMutation) ResetPlatformOrderID() {
	m.platform_order_id = nil
	delete(m.clearedFields, order.FieldPlatformOrderID)
}

// SetPlatformOrderNo sets the "platform_order_no" field.
func (m *OrderMutation) SetPlatformOrderNo(s string) {
	m.platform_order_no = &s
}

// PlatformOrderNo returns the value of the "platform_order_no" field in the mutation.
func (m *OrderMutation) PlatformOrderNo() (r string, exists bool) {
	v := m.platform_order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformOrderNo returns the old "platform_order_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlatformOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformOrderNo: %w", err)
	}
	return oldValue.PlatformOrderNo, nil
}

// ClearPlatformOrderNo clears the value of the "platform_order_no" field.
func (m *OrderMutation) ClearPlatformOrderNo() {
	m.platform_order_no = nil
	m.clearedFields[order.FieldPlatformOrderNo] = struct{}{}
}

// PlatformOrderNoCleared returns if the "platform_order_no" field was cleared in this mutation.
func (m *OrderMutation) PlatformOrderNoCleared() bool {
	_, ok := m.clearedFields[order.FieldPlatformOrderNo]
	return ok
}

// ResetPlatformOrderNo resets all changes to the "platform_order_no" field.
func (m *OrderMutation) ResetPlatformOrderNo() {
	m.platform_order_no = nil
	delete(m.clearedFields, order.FieldPlatformOrderNo)
}

// SetPlatformOrderStatusURL sets the "platform_order_status_url" field.
func (m *OrderMutation) SetPlatformOrderStatusURL(s string) {
	m.platform_order_status_url = &s
}

// PlatformOrderStatusURL returns the value of the "platform_order_status_url" field in the mutation.
func (m *OrderMutation) PlatformOrderStatusURL() (r string, exists bool) {
	v := m.platform_order_status_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformOrderStatusURL returns the old "platform_order_status_url" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlatformOrderStatusURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformOrderStatusURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformOrderStatusURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformOrderStatusURL: %w", err)
	}
	return oldValue.PlatformOrderStatusURL, nil
}

// ClearPlatformOrderStatusURL clears the value of the "platform_order_status_url" field.
func (m *OrderMutation) ClearPlatformOrderStatusURL() {
	m.platform_order_status_url = nil
	m.clearedFields[order.FieldPlatformOrderStatusURL] = struct{}{}
}

// PlatformOrderStatusURLCleared returns if the "platform_order_status_url" field was cleared in this mutation.
func (m *OrderMutation) PlatformOrderStatusURLCleared() bool {
	_, ok := m.clearedFields[order.FieldPlatformOrderStatusURL]
	return ok
}

// ResetPlatformOrderStatusURL resets all changes to the "platform_order_status_url" field.
func (m *OrderMutation) ResetPlatformOrderStatusURL() {
	m.platform_order_status_url = nil
	delete(m.clearedFields, order.FieldPlatformOrderStatusURL)
}

// SetPlatformStatus sets the "platform_status" field.
func (m *OrderMutation) SetPlatformStatus(s string) {
	m.platform_status = &s
}

// PlatformStatus returns the value of the "platform_status" field in the mutation.
func (m *OrderMutation) PlatformStatus() (r string, exists bool) {
	v := m.platform_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformStatus returns the old "platform_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlatformStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformStatus: %w", err)
	}
	return oldValue.PlatformStatus, nil
}

// ClearPlatformStatus clears the value of the "platform_status" field.
func (m *OrderMutation) ClearPlatformStatus() {
	m.platform_status = nil
	m.clearedFields[order.FieldPlatformStatus] = struct{}{}
}

// PlatformStatusCleared returns if the "platform_status" field was cleared in this mutation.
func (m *OrderMutation) PlatformStatusCleared() bool {
	_, ok := m.clearedFields[order.FieldPlatformStatus]
	return ok
}

// ResetPlatformStatus resets all changes to the "platform_status" field.
func (m *OrderMutation) ResetPlatformStatus() {
	m.platform_status = nil
	delete(m.clearedFields, order.FieldPlatformStatus)
}

// SetPaidStatus sets the "paid_status" field.
func (m *OrderMutation) SetPaidStatus(s string) {
	m.paid_status = &s
}

// PaidStatus returns the value of the "paid_status" field in the mutation.
func (m *OrderMutation) PaidStatus() (r string, exists bool) {
	v := m.paid_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidStatus returns the old "paid_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaidStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidStatus: %w", err)
	}
	return oldValue.PaidStatus, nil
}

// ClearPaidStatus clears the value of the "paid_status" field.
func (m *OrderMutation) ClearPaidStatus() {
	m.paid_status = nil
	m.clearedFields[order.FieldPaidStatus] = struct{}{}
}

// PaidStatusCleared returns if the "paid_status" field was cleared in this mutation.
func (m *OrderMutation) PaidStatusCleared() bool {
	_, ok := m.clearedFields[order.FieldPaidStatus]
	return ok
}

// ResetPaidStatus resets all changes to the "paid_status" field.
func (m *OrderMutation) ResetPaidStatus() {
	m.paid_status = nil
	delete(m.clearedFields, order.FieldPaidStatus)
}

// SetFulfillmentPushed sets the "fulfillment_pushed" field.
func (m *OrderMutation) SetFulfillmentPushed(b bool) {
	m.fulfillment_pushed = &b
}

// FulfillmentPushed returns the value of the "fulfillment_pushed" field in the mutation.
func (m *OrderMutation) FulfillmentPushed() (r bool, exists bool) {
	v := m.fulfillment_pushed
	if v == nil {
		return
	}
	return *v, true
}

// OldFulfillmentPushed returns the old "fulfillment_pushed" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFulfillmentPushed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFulfillmentPushed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFulfillmentPushed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFulfillmentPushed: %w", err)
	}
	return oldValue.FulfillmentPushed, nil
}

// ClearFulfillmentPushed clears the value of the "fulfillment_pushed" field.
func (m *OrderMutation) ClearFulfillmentPushed() {
	m.fulfillment_pushed = nil
	m.clearedFields[order.FieldFulfillmentPushed] = struct{}{}
}

// FulfillmentPushedCleared returns if the "fulfillment_pushed" field was cleared in this mutation.
func (m *OrderMutation) FulfillmentPushedCleared() bool {
	_, ok := m.clearedFields[order.FieldFulfillmentPushed]
	return ok
}

// ResetFulfillmentPushed resets all changes to the "fulfillment_pushed" field.
func (m *OrderMutation) ResetFulfillmentPushed() {
	m.fulfillment_pushed = nil
	delete(m.clearedFields, order.FieldFulfillmentPushed)
}

// SetFulfillmentStatus sets the "fulfillment_status" field.
func (m *OrderMutation) SetFulfillmentStatus(s string) {
	m.fulfillment_status = &s
}

// FulfillmentStatus returns the value of the "fulfillment_status" field in the mutation.
func (m *OrderMutation) FulfillmentStatus() (r string, exists bool) {
	v := m.fulfillment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFulfillmentStatus returns the old "fulfillment_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFulfillmentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFulfillmentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFulfillmentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFulfillmentStatus: %w", err)
	}
	return oldValue.FulfillmentStatus, nil
}

// ClearFulfillmentStatus clears the value of the "fulfillment_status" field.
func (m *OrderMutation) ClearFulfillmentStatus() {
	m.fulfillment_status = nil
	m.clearedFields[order.FieldFulfillmentStatus] = struct{}{}
}

// FulfillmentStatusCleared returns if the "fulfillment_status" field was cleared in this mutation.
func (m *OrderMutation) FulfillmentStatusCleared() bool {
	_, ok := m.clearedFields[order.FieldFulfillmentStatus]
	return ok
}

// ResetFulfillmentStatus resets all changes to the "fulfillment_status" field.
func (m *OrderMutation) ResetFulfillmentStatus() {
	m.fulfillment_status = nil
	delete(m.clearedFields, order.FieldFulfillmentStatus)
}

// SetPlatformCreatedAt sets the "platform_created_at" field.
func (m *OrderMutation) SetPlatformCreatedAt(t time.Time) {
	m.platform_created_at = &t
}

// PlatformCreatedAt returns the value of the "platform_created_at" field in the mutation.
func (m *OrderMutation) PlatformCreatedAt() (r time.Time, exists bool) {
	v := m.platform_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformCreatedAt returns the old "platform_created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlatformCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformCreatedAt: %w", err)
	}
	return oldValue.PlatformCreatedAt, nil
}

// ClearPlatformCreatedAt clears the value of the "platform_created_at" field.
func (m *OrderMutation) ClearPlatformCreatedAt() {
	m.platform_created_at = nil
	m.clearedFields[order.FieldPlatformCreatedAt] = struct{}{}
}

// PlatformCreatedAtCleared returns if the "platform_created_at" field was cleared in this mutation.
func (m *OrderMutation) PlatformCreatedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldPlatformCreatedAt]
	return ok
}

// ResetPlatformCreatedAt resets all changes to the "platform_created_at" field.
func (m *OrderMutation) ResetPlatformCreatedAt() {
	m.platform_created_at = nil
	delete(m.clearedFields, order.FieldPlatformCreatedAt)
}

// SetLocationID sets the "location_id" field.
func (m *OrderMutation) SetLocationID(s string) {
	m.location_id = &s
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *OrderMutation) LocationID() (r string, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldLocationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *OrderMutation) ClearLocationID() {
	m.location_id = nil
	m.clearedFields[order.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *OrderMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[order.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *OrderMutation) ResetLocationID() {
	m.location_id = nil
	delete(m.clearedFields, order.FieldLocationID)
}

// SetTags sets the "tags" field.
func (m *OrderMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *OrderMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTags(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *OrderMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[order.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *OrderMutation) TagsCleared() bool {
	_, ok := m.clearedFields[order.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *OrderMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, order.FieldTags)
}

// SetNote sets the "note" field.
func (m *OrderMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OrderMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OrderMutation) ClearNote() {
	m.note = nil
	m.clearedFields[order.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OrderMutation) NoteCleared() bool {
	_, ok := m.clearedFields[order.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OrderMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, order.FieldNote)
}

// SetCancelReason sets the "cancel_reason" field.
func (m *OrderMutation) SetCancelReason(s string) {
	m.cancel_reason = &s
}

// CancelReason returns the value of the "cancel_reason" field in the mutation.
func (m *OrderMutation) CancelReason() (r string, exists bool) {
	v := m.cancel_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelReason returns the old "cancel_reason" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCancelReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelReason: %w", err)
	}
	return oldValue.CancelReason, nil
}

// ClearCancelReason clears the value of the "cancel_reason" field.
func (m *OrderMutation) ClearCancelReason() {
	m.cancel_reason = nil
	m.clearedFields[order.FieldCancelReason] = struct{}{}
}

// CancelReasonCleared returns if the "cancel_reason" field was cleared in this mutation.
func (m *OrderMutation) CancelReasonCleared() bool {
	_, ok := m.clearedFields[order.FieldCancelReason]
	return ok
}

// ResetCancelReason resets all changes to the "cancel_reason" field.
func (m *OrderMutation) ResetCancelReason() {
	m.cancel_reason = nil
	delete(m.clearedFields, order.FieldCancelReason)
}

// SetCancelledAt sets the "cancelled_at" field.
func (m *OrderMutation) SetCancelledAt(t time.Time) {
	m.cancelled_at = &t
}

// CancelledAt returns the value of the "cancelled_at" field in the mutation.
func (m *OrderMutation) CancelledAt() (r time.Time, exists bool) {
	v := m.cancelled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelledAt returns the old "cancelled_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCancelledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelledAt: %w", err)
	}
	return oldValue.CancelledAt, nil
}

// ClearCancelledAt clears the value of the "cancelled_at" field.
func (m *OrderMutation) ClearCancelledAt() {
	m.cancelled_at = nil
	m.clearedFields[order.FieldCancelledAt] = struct{}{}
}

// CancelledAtCleared returns if the "cancelled_at" field was cleared in this mutation.
func (m *OrderMutation) CancelledAtCleared() bool {
	_, ok := m.clearedFields[order.FieldCancelledAt]
	return ok
}

// ResetCancelledAt resets all changes to the "cancelled_at" field.
func (m *OrderMutation) ResetCancelledAt() {
	m.cancelled_at = nil
	delete(m.clearedFields, order.FieldCancelledAt)
}

// SetClosedAt sets the "closed_at" field.
func (m *OrderMutation) SetClosedAt(t time.Time) {
	m.closed_at = &t
}

// ClosedAt returns the value of the "closed_at" field in the mutation.
func (m *OrderMutation) ClosedAt() (r time.Time, exists bool) {
	v := m.closed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldClosedAt returns the old "closed_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldClosedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosedAt: %w", err)
	}
	return oldValue.ClosedAt, nil
}

// ClearClosedAt clears the value of the "closed_at" field.
func (m *OrderMutation) ClearClosedAt() {
	m.closed_at = nil
	m.clearedFields[order.FieldClosedAt] = struct{}{}
}

// ClosedAtCleared returns if the "closed_at" field was cleared in this mutation.
func (m *OrderMutation) ClosedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldClosedAt]
	return ok
}

// ResetClosedAt resets all changes to the "closed_at" field.
func (m *OrderMutation) ResetClosedAt() {
	m.closed_at = nil
	delete(m.clearedFields, order.FieldClosedAt)
}

// SetContactEmail sets the "contact_email" field.
func (m *OrderMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *OrderMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *OrderMutation) ResetContactEmail() {
	m.contact_email = nil
}

// SetContactPhone sets the "contact_phone" field.
func (m *OrderMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *OrderMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *OrderMutation) ResetContactPhone() {
	m.contact_phone = nil
}

// SetShippingName sets the "shipping_name" field.
func (m *OrderMutation) SetShippingName(s string) {
	m.shipping_name = &s
}

// ShippingName returns the value of the "shipping_name" field in the mutation.
func (m *OrderMutation) ShippingName() (r string, exists bool) {
	v := m.shipping_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingName returns the old "shipping_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingName: %w", err)
	}
	return oldValue.ShippingName, nil
}

// ResetShippingName resets all changes to the "shipping_name" field.
func (m *OrderMutation) ResetShippingName() {
	m.shipping_name = nil
}

// SetShippingFirstName sets the "shipping_first_name" field.
func (m *OrderMutation) SetShippingFirstName(s string) {
	m.shipping_first_name = &s
}

// ShippingFirstName returns the value of the "shipping_first_name" field in the mutation.
func (m *OrderMutation) ShippingFirstName() (r string, exists bool) {
	v := m.shipping_first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFirstName returns the old "shipping_first_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFirstName: %w", err)
	}
	return oldValue.ShippingFirstName, nil
}

// ResetShippingFirstName resets all changes to the "shipping_first_name" field.
func (m *OrderMutation) ResetShippingFirstName() {
	m.shipping_first_name = nil
}

// SetShippingLastName sets the "shipping_last_name" field.
func (m *OrderMutation) SetShippingLastName(s string) {
	m.shipping_last_name = &s
}

// ShippingLastName returns the value of the "shipping_last_name" field in the mutation.
func (m *OrderMutation) ShippingLastName() (r string, exists bool) {
	v := m.shipping_last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingLastName returns the old "shipping_last_name" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingLastName: %w", err)
	}
	return oldValue.ShippingLastName, nil
}

// ResetShippingLastName resets all changes to the "shipping_last_name" field.
func (m *OrderMutation) ResetShippingLastName() {
	m.shipping_last_name = nil
}

// SetShippingCompany sets the "shipping_company" field.
func (m *OrderMutation) SetShippingCompany(s string) {
	m.shipping_company = &s
}

// ShippingCompany returns the value of the "shipping_company" field in the mutation.
func (m *OrderMutation) ShippingCompany() (r string, exists bool) {
	v := m.shipping_company
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCompany returns the old "shipping_company" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCompany: %w", err)
	}
	return oldValue.ShippingCompany, nil
}

// ResetShippingCompany resets all changes to the "shipping_company" field.
func (m *OrderMutation) ResetShippingCompany() {
	m.shipping_company = nil
}

// SetShippingCountry sets the "shipping_country" field.
func (m *OrderMutation) SetShippingCountry(s string) {
	m.shipping_country = &s
}

// ShippingCountry returns the value of the "shipping_country" field in the mutation.
func (m *OrderMutation) ShippingCountry() (r string, exists bool) {
	v := m.shipping_country
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCountry returns the old "shipping_country" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCountry: %w", err)
	}
	return oldValue.ShippingCountry, nil
}

// ResetShippingCountry resets all changes to the "shipping_country" field.
func (m *OrderMutation) ResetShippingCountry() {
	m.shipping_country = nil
}

// SetShippingCountryCode sets the "shipping_country_code" field.
func (m *OrderMutation) SetShippingCountryCode(s string) {
	m.shipping_country_code = &s
}

// ShippingCountryCode returns the value of the "shipping_country_code" field in the mutation.
func (m *OrderMutation) ShippingCountryCode() (r string, exists bool) {
	v := m.shipping_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCountryCode returns the old "shipping_country_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCountryCode: %w", err)
	}
	return oldValue.ShippingCountryCode, nil
}

// ResetShippingCountryCode resets all changes to the "shipping_country_code" field.
func (m *OrderMutation) ResetShippingCountryCode() {
	m.shipping_country_code = nil
}

// SetShippingProvince sets the "shipping_province" field.
func (m *OrderMutation) SetShippingProvince(s string) {
	m.shipping_province = &s
}

// ShippingProvince returns the value of the "shipping_province" field in the mutation.
func (m *OrderMutation) ShippingProvince() (r string, exists bool) {
	v := m.shipping_province
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingProvince returns the old "shipping_province" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingProvince: %w", err)
	}
	return oldValue.ShippingProvince, nil
}

// ResetShippingProvince resets all changes to the "shipping_province" field.
func (m *OrderMutation) ResetShippingProvince() {
	m.shipping_province = nil
}

// SetShippingProvinceCode sets the "shipping_province_code" field.
func (m *OrderMutation) SetShippingProvinceCode(s string) {
	m.shipping_province_code = &s
}

// ShippingProvinceCode returns the value of the "shipping_province_code" field in the mutation.
func (m *OrderMutation) ShippingProvinceCode() (r string, exists bool) {
	v := m.shipping_province_code
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingProvinceCode returns the old "shipping_province_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingProvinceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingProvinceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingProvinceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingProvinceCode: %w", err)
	}
	return oldValue.ShippingProvinceCode, nil
}

// ResetShippingProvinceCode resets all changes to the "shipping_province_code" field.
func (m *OrderMutation) ResetShippingProvinceCode() {
	m.shipping_province_code = nil
}

// SetShippingCity sets the "shipping_city" field.
func (m *OrderMutation) SetShippingCity(s string) {
	m.shipping_city = &s
}

// ShippingCity returns the value of the "shipping_city" field in the mutation.
func (m *OrderMutation) ShippingCity() (r string, exists bool) {
	v := m.shipping_city
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCity returns the old "shipping_city" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCity: %w", err)
	}
	return oldValue.ShippingCity, nil
}

// ResetShippingCity resets all changes to the "shipping_city" field.
func (m *OrderMutation) ResetShippingCity() {
	m.shipping_city = nil
}

// SetShippingAddress1 sets the "shipping_address1" field.
func (m *OrderMutation) SetShippingAddress1(s string) {
	m.shipping_address1 = &s
}

// ShippingAddress1 returns the value of the "shipping_address1" field in the mutation.
func (m *OrderMutation) ShippingAddress1() (r string, exists bool) {
	v := m.shipping_address1
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingAddress1 returns the old "shipping_address1" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingAddress1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingAddress1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingAddress1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingAddress1: %w", err)
	}
	return oldValue.ShippingAddress1, nil
}

// ResetShippingAddress1 resets all changes to the "shipping_address1" field.
func (m *OrderMutation) ResetShippingAddress1() {
	m.shipping_address1 = nil
}

// SetShippingAddress2 sets the "shipping_address2" field.
func (m *OrderMutation) SetShippingAddress2(s string) {
	m.shipping_address2 = &s
}

// ShippingAddress2 returns the value of the "shipping_address2" field in the mutation.
func (m *OrderMutation) ShippingAddress2() (r string, exists bool) {
	v := m.shipping_address2
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingAddress2 returns the old "shipping_address2" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingAddress2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingAddress2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingAddress2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingAddress2: %w", err)
	}
	return oldValue.ShippingAddress2, nil
}

// ResetShippingAddress2 resets all changes to the "shipping_address2" field.
func (m *OrderMutation) ResetShippingAddress2() {
	m.shipping_address2 = nil
}

// SetShippingZipCode sets the "shipping_zip_code" field.
func (m *OrderMutation) SetShippingZipCode(s string) {
	m.shipping_zip_code = &s
}

// ShippingZipCode returns the value of the "shipping_zip_code" field in the mutation.
func (m *OrderMutation) ShippingZipCode() (r string, exists bool) {
	v := m.shipping_zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingZipCode returns the old "shipping_zip_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingZipCode: %w", err)
	}
	return oldValue.ShippingZipCode, nil
}

// ResetShippingZipCode resets all changes to the "shipping_zip_code" field.
func (m *OrderMutation) ResetShippingZipCode() {
	m.shipping_zip_code = nil
}

// SetShippingPhone sets the "shipping_phone" field.
func (m *OrderMutation) SetShippingPhone(s string) {
	m.shipping_phone = &s
}

// ShippingPhone returns the value of the "shipping_phone" field in the mutation.
func (m *OrderMutation) ShippingPhone() (r string, exists bool) {
	v := m.shipping_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingPhone returns the old "shipping_phone" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingPhone: %w", err)
	}
	return oldValue.ShippingPhone, nil
}

// ResetShippingPhone resets all changes to the "shipping_phone" field.
func (m *OrderMutation) ResetShippingPhone() {
	m.shipping_phone = nil
}

// SetShippingCertificateType sets the "shipping_certificate_type" field.
func (m *OrderMutation) SetShippingCertificateType(s string) {
	m.shipping_certificate_type = &s
}

// ShippingCertificateType returns the value of the "shipping_certificate_type" field in the mutation.
func (m *OrderMutation) ShippingCertificateType() (r string, exists bool) {
	v := m.shipping_certificate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCertificateType returns the old "shipping_certificate_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCertificateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCertificateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCertificateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCertificateType: %w", err)
	}
	return oldValue.ShippingCertificateType, nil
}

// ClearShippingCertificateType clears the value of the "shipping_certificate_type" field.
func (m *OrderMutation) ClearShippingCertificateType() {
	m.shipping_certificate_type = nil
	m.clearedFields[order.FieldShippingCertificateType] = struct{}{}
}

// ShippingCertificateTypeCleared returns if the "shipping_certificate_type" field was cleared in this mutation.
func (m *OrderMutation) ShippingCertificateTypeCleared() bool {
	_, ok := m.clearedFields[order.FieldShippingCertificateType]
	return ok
}

// ResetShippingCertificateType resets all changes to the "shipping_certificate_type" field.
func (m *OrderMutation) ResetShippingCertificateType() {
	m.shipping_certificate_type = nil
	delete(m.clearedFields, order.FieldShippingCertificateType)
}

// SetShippingCertificateCode sets the "shipping_certificate_code" field.
func (m *OrderMutation) SetShippingCertificateCode(s string) {
	m.shipping_certificate_code = &s
}

// ShippingCertificateCode returns the value of the "shipping_certificate_code" field in the mutation.
func (m *OrderMutation) ShippingCertificateCode() (r string, exists bool) {
	v := m.shipping_certificate_code
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCertificateCode returns the old "shipping_certificate_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCertificateCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCertificateCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCertificateCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCertificateCode: %w", err)
	}
	return oldValue.ShippingCertificateCode, nil
}

// ClearShippingCertificateCode clears the value of the "shipping_certificate_code" field.
func (m *OrderMutation) ClearShippingCertificateCode() {
	m.shipping_certificate_code = nil
	m.clearedFields[order.FieldShippingCertificateCode] = struct{}{}
}

// ShippingCertificateCodeCleared returns if the "shipping_certificate_code" field was cleared in this mutation.
func (m *OrderMutation) ShippingCertificateCodeCleared() bool {
	_, ok := m.clearedFields[order.FieldShippingCertificateCode]
	return ok
}

// ResetShippingCertificateCode resets all changes to the "shipping_certificate_code" field.
func (m *OrderMutation) ResetShippingCertificateCode() {
	m.shipping_certificate_code = nil
	delete(m.clearedFields, order.FieldShippingCertificateCode)
}

// SetShippingCredentialsPeriod sets the "shipping_credentials_period" field.
func (m *OrderMutation) SetShippingCredentialsPeriod(s string) {
	m.shipping_credentials_period = &s
}

// ShippingCredentialsPeriod returns the value of the "shipping_credentials_period" field in the mutation.
func (m *OrderMutation) ShippingCredentialsPeriod() (r string, exists bool) {
	v := m.shipping_credentials_period
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCredentialsPeriod returns the old "shipping_credentials_period" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingCredentialsPeriod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingCredentialsPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingCredentialsPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCredentialsPeriod: %w", err)
	}
	return oldValue.ShippingCredentialsPeriod, nil
}

// ClearShippingCredentialsPeriod clears the value of the "shipping_credentials_period" field.
func (m *OrderMutation) ClearShippingCredentialsPeriod() {
	m.shipping_credentials_period = nil
	m.clearedFields[order.FieldShippingCredentialsPeriod] = struct{}{}
}

// ShippingCredentialsPeriodCleared returns if the "shipping_credentials_period" field was cleared in this mutation.
func (m *OrderMutation) ShippingCredentialsPeriodCleared() bool {
	_, ok := m.clearedFields[order.FieldShippingCredentialsPeriod]
	return ok
}

// ResetShippingCredentialsPeriod resets all changes to the "shipping_credentials_period" field.
func (m *OrderMutation) ResetShippingCredentialsPeriod() {
	m.shipping_credentials_period = nil
	delete(m.clearedFields, order.FieldShippingCredentialsPeriod)
}

// SetRemark sets the "remark" field.
func (m *OrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[order.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[order.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, order.FieldRemark)
}

// SetPreferShippedType sets the "prefer_shipped_type" field.
func (m *OrderMutation) SetPreferShippedType(i int8) {
	m.prefer_shipped_type = &i
	m.addprefer_shipped_type = nil
}

// PreferShippedType returns the value of the "prefer_shipped_type" field in the mutation.
func (m *OrderMutation) PreferShippedType() (r int8, exists bool) {
	v := m.prefer_shipped_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferShippedType returns the old "prefer_shipped_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPreferShippedType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferShippedType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferShippedType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferShippedType: %w", err)
	}
	return oldValue.PreferShippedType, nil
}

// AddPreferShippedType adds i to the "prefer_shipped_type" field.
func (m *OrderMutation) AddPreferShippedType(i int8) {
	if m.addprefer_shipped_type != nil {
		*m.addprefer_shipped_type += i
	} else {
		m.addprefer_shipped_type = &i
	}
}

// AddedPreferShippedType returns the value that was added to the "prefer_shipped_type" field in this mutation.
func (m *OrderMutation) AddedPreferShippedType() (r int8, exists bool) {
	v := m.addprefer_shipped_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreferShippedType clears the value of the "prefer_shipped_type" field.
func (m *OrderMutation) ClearPreferShippedType() {
	m.prefer_shipped_type = nil
	m.addprefer_shipped_type = nil
	m.clearedFields[order.FieldPreferShippedType] = struct{}{}
}

// PreferShippedTypeCleared returns if the "prefer_shipped_type" field was cleared in this mutation.
func (m *OrderMutation) PreferShippedTypeCleared() bool {
	_, ok := m.clearedFields[order.FieldPreferShippedType]
	return ok
}

// ResetPreferShippedType resets all changes to the "prefer_shipped_type" field.
func (m *OrderMutation) ResetPreferShippedType() {
	m.prefer_shipped_type = nil
	m.addprefer_shipped_type = nil
	delete(m.clearedFields, order.FieldPreferShippedType)
}

// SetPreferChannelID sets the "prefer_channel_id" field.
func (m *OrderMutation) SetPreferChannelID(i int64) {
	m.prefer_channel_id = &i
	m.addprefer_channel_id = nil
}

// PreferChannelID returns the value of the "prefer_channel_id" field in the mutation.
func (m *OrderMutation) PreferChannelID() (r int64, exists bool) {
	v := m.prefer_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferChannelID returns the old "prefer_channel_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPreferChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferChannelID: %w", err)
	}
	return oldValue.PreferChannelID, nil
}

// AddPreferChannelID adds i to the "prefer_channel_id" field.
func (m *OrderMutation) AddPreferChannelID(i int64) {
	if m.addprefer_channel_id != nil {
		*m.addprefer_channel_id += i
	} else {
		m.addprefer_channel_id = &i
	}
}

// AddedPreferChannelID returns the value that was added to the "prefer_channel_id" field in this mutation.
func (m *OrderMutation) AddedPreferChannelID() (r int64, exists bool) {
	v := m.addprefer_channel_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreferChannelID clears the value of the "prefer_channel_id" field.
func (m *OrderMutation) ClearPreferChannelID() {
	m.prefer_channel_id = nil
	m.addprefer_channel_id = nil
	m.clearedFields[order.FieldPreferChannelID] = struct{}{}
}

// PreferChannelIDCleared returns if the "prefer_channel_id" field was cleared in this mutation.
func (m *OrderMutation) PreferChannelIDCleared() bool {
	_, ok := m.clearedFields[order.FieldPreferChannelID]
	return ok
}

// ResetPreferChannelID resets all changes to the "prefer_channel_id" field.
func (m *OrderMutation) ResetPreferChannelID() {
	m.prefer_channel_id = nil
	m.addprefer_channel_id = nil
	delete(m.clearedFields, order.FieldPreferChannelID)
}

// SetChannelOptions sets the "channel_options" field.
func (m *OrderMutation) SetChannelOptions(s string) {
	m.channel_options = &s
}

// ChannelOptions returns the value of the "channel_options" field in the mutation.
func (m *OrderMutation) ChannelOptions() (r string, exists bool) {
	v := m.channel_options
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelOptions returns the old "channel_options" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelOptions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelOptions: %w", err)
	}
	return oldValue.ChannelOptions, nil
}

// ClearChannelOptions clears the value of the "channel_options" field.
func (m *OrderMutation) ClearChannelOptions() {
	m.channel_options = nil
	m.clearedFields[order.FieldChannelOptions] = struct{}{}
}

// ChannelOptionsCleared returns if the "channel_options" field was cleared in this mutation.
func (m *OrderMutation) ChannelOptionsCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelOptions]
	return ok
}

// ResetChannelOptions resets all changes to the "channel_options" field.
func (m *OrderMutation) ResetChannelOptions() {
	m.channel_options = nil
	delete(m.clearedFields, order.FieldChannelOptions)
}

// SetChannelID sets the "channel_id" field.
func (m *OrderMutation) SetChannelID(i int64) {
	m.channels = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *OrderMutation) ChannelID() (r int64, exists bool) {
	v := m.channels
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *OrderMutation) ClearChannelID() {
	m.channels = nil
	m.clearedFields[order.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *OrderMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *OrderMutation) ResetChannelID() {
	m.channels = nil
	delete(m.clearedFields, order.FieldChannelID)
}

// SetChannelCostID sets the "channel_cost_id" field.
func (m *OrderMutation) SetChannelCostID(i int64) {
	m.channel_cost_id = &i
	m.addchannel_cost_id = nil
}

// ChannelCostID returns the value of the "channel_cost_id" field in the mutation.
func (m *OrderMutation) ChannelCostID() (r int64, exists bool) {
	v := m.channel_cost_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelCostID returns the old "channel_cost_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannelCostID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelCostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelCostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelCostID: %w", err)
	}
	return oldValue.ChannelCostID, nil
}

// AddChannelCostID adds i to the "channel_cost_id" field.
func (m *OrderMutation) AddChannelCostID(i int64) {
	if m.addchannel_cost_id != nil {
		*m.addchannel_cost_id += i
	} else {
		m.addchannel_cost_id = &i
	}
}

// AddedChannelCostID returns the value that was added to the "channel_cost_id" field in this mutation.
func (m *OrderMutation) AddedChannelCostID() (r int64, exists bool) {
	v := m.addchannel_cost_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearChannelCostID clears the value of the "channel_cost_id" field.
func (m *OrderMutation) ClearChannelCostID() {
	m.channel_cost_id = nil
	m.addchannel_cost_id = nil
	m.clearedFields[order.FieldChannelCostID] = struct{}{}
}

// ChannelCostIDCleared returns if the "channel_cost_id" field was cleared in this mutation.
func (m *OrderMutation) ChannelCostIDCleared() bool {
	_, ok := m.clearedFields[order.FieldChannelCostID]
	return ok
}

// ResetChannelCostID resets all changes to the "channel_cost_id" field.
func (m *OrderMutation) ResetChannelCostID() {
	m.channel_cost_id = nil
	m.addchannel_cost_id = nil
	delete(m.clearedFields, order.FieldChannelCostID)
}

// SetShipType sets the "ship_type" field.
func (m *OrderMutation) SetShipType(i int8) {
	m.ship_type = &i
	m.addship_type = nil
}

// ShipType returns the value of the "ship_type" field in the mutation.
func (m *OrderMutation) ShipType() (r int8, exists bool) {
	v := m.ship_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShipType returns the old "ship_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShipType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipType: %w", err)
	}
	return oldValue.ShipType, nil
}

// AddShipType adds i to the "ship_type" field.
func (m *OrderMutation) AddShipType(i int8) {
	if m.addship_type != nil {
		*m.addship_type += i
	} else {
		m.addship_type = &i
	}
}

// AddedShipType returns the value that was added to the "ship_type" field in this mutation.
func (m *OrderMutation) AddedShipType() (r int8, exists bool) {
	v := m.addship_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipType clears the value of the "ship_type" field.
func (m *OrderMutation) ClearShipType() {
	m.ship_type = nil
	m.addship_type = nil
	m.clearedFields[order.FieldShipType] = struct{}{}
}

// ShipTypeCleared returns if the "ship_type" field was cleared in this mutation.
func (m *OrderMutation) ShipTypeCleared() bool {
	_, ok := m.clearedFields[order.FieldShipType]
	return ok
}

// ResetShipType resets all changes to the "ship_type" field.
func (m *OrderMutation) ResetShipType() {
	m.ship_type = nil
	m.addship_type = nil
	delete(m.clearedFields, order.FieldShipType)
}

// SetTrackingCompany sets the "tracking_company" field.
func (m *OrderMutation) SetTrackingCompany(s string) {
	m.tracking_company = &s
}

// TrackingCompany returns the value of the "tracking_company" field in the mutation.
func (m *OrderMutation) TrackingCompany() (r string, exists bool) {
	v := m.tracking_company
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingCompany returns the old "tracking_company" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTrackingCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingCompany: %w", err)
	}
	return oldValue.TrackingCompany, nil
}

// ClearTrackingCompany clears the value of the "tracking_company" field.
func (m *OrderMutation) ClearTrackingCompany() {
	m.tracking_company = nil
	m.clearedFields[order.FieldTrackingCompany] = struct{}{}
}

// TrackingCompanyCleared returns if the "tracking_company" field was cleared in this mutation.
func (m *OrderMutation) TrackingCompanyCleared() bool {
	_, ok := m.clearedFields[order.FieldTrackingCompany]
	return ok
}

// ResetTrackingCompany resets all changes to the "tracking_company" field.
func (m *OrderMutation) ResetTrackingCompany() {
	m.tracking_company = nil
	delete(m.clearedFields, order.FieldTrackingCompany)
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *OrderMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *OrderMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ClearTrackingNumber clears the value of the "tracking_number" field.
func (m *OrderMutation) ClearTrackingNumber() {
	m.tracking_number = nil
	m.clearedFields[order.FieldTrackingNumber] = struct{}{}
}

// TrackingNumberCleared returns if the "tracking_number" field was cleared in this mutation.
func (m *OrderMutation) TrackingNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldTrackingNumber]
	return ok
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *OrderMutation) ResetTrackingNumber() {
	m.tracking_number = nil
	delete(m.clearedFields, order.FieldTrackingNumber)
}

// SetTrackingURL sets the "tracking_url" field.
func (m *OrderMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *OrderMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ClearTrackingURL clears the value of the "tracking_url" field.
func (m *OrderMutation) ClearTrackingURL() {
	m.tracking_url = nil
	m.clearedFields[order.FieldTrackingURL] = struct{}{}
}

// TrackingURLCleared returns if the "tracking_url" field was cleared in this mutation.
func (m *OrderMutation) TrackingURLCleared() bool {
	_, ok := m.clearedFields[order.FieldTrackingURL]
	return ok
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *OrderMutation) ResetTrackingURL() {
	m.tracking_url = nil
	delete(m.clearedFields, order.FieldTrackingURL)
}

// SetWaybillNumber sets the "waybill_number" field.
func (m *OrderMutation) SetWaybillNumber(s string) {
	m.waybill_number = &s
}

// WaybillNumber returns the value of the "waybill_number" field in the mutation.
func (m *OrderMutation) WaybillNumber() (r string, exists bool) {
	v := m.waybill_number
	if v == nil {
		return
	}
	return *v, true
}

// OldWaybillNumber returns the old "waybill_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldWaybillNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWaybillNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWaybillNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWaybillNumber: %w", err)
	}
	return oldValue.WaybillNumber, nil
}

// ClearWaybillNumber clears the value of the "waybill_number" field.
func (m *OrderMutation) ClearWaybillNumber() {
	m.waybill_number = nil
	m.clearedFields[order.FieldWaybillNumber] = struct{}{}
}

// WaybillNumberCleared returns if the "waybill_number" field was cleared in this mutation.
func (m *OrderMutation) WaybillNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldWaybillNumber]
	return ok
}

// ResetWaybillNumber resets all changes to the "waybill_number" field.
func (m *OrderMutation) ResetWaybillNumber() {
	m.waybill_number = nil
	delete(m.clearedFields, order.FieldWaybillNumber)
}

// SetCourierOrderNumber sets the "courier_order_number" field.
func (m *OrderMutation) SetCourierOrderNumber(s string) {
	m.courier_order_number = &s
}

// CourierOrderNumber returns the value of the "courier_order_number" field in the mutation.
func (m *OrderMutation) CourierOrderNumber() (r string, exists bool) {
	v := m.courier_order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierOrderNumber returns the old "courier_order_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCourierOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourierOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourierOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierOrderNumber: %w", err)
	}
	return oldValue.CourierOrderNumber, nil
}

// ClearCourierOrderNumber clears the value of the "courier_order_number" field.
func (m *OrderMutation) ClearCourierOrderNumber() {
	m.courier_order_number = nil
	m.clearedFields[order.FieldCourierOrderNumber] = struct{}{}
}

// CourierOrderNumberCleared returns if the "courier_order_number" field was cleared in this mutation.
func (m *OrderMutation) CourierOrderNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldCourierOrderNumber]
	return ok
}

// ResetCourierOrderNumber resets all changes to the "courier_order_number" field.
func (m *OrderMutation) ResetCourierOrderNumber() {
	m.courier_order_number = nil
	delete(m.clearedFields, order.FieldCourierOrderNumber)
}

// SetNssCourierOrderNumber sets the "nss_courier_order_number" field.
func (m *OrderMutation) SetNssCourierOrderNumber(s string) {
	m.nss_courier_order_number = &s
}

// NssCourierOrderNumber returns the value of the "nss_courier_order_number" field in the mutation.
func (m *OrderMutation) NssCourierOrderNumber() (r string, exists bool) {
	v := m.nss_courier_order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldNssCourierOrderNumber returns the old "nss_courier_order_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNssCourierOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNssCourierOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNssCourierOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNssCourierOrderNumber: %w", err)
	}
	return oldValue.NssCourierOrderNumber, nil
}

// ClearNssCourierOrderNumber clears the value of the "nss_courier_order_number" field.
func (m *OrderMutation) ClearNssCourierOrderNumber() {
	m.nss_courier_order_number = nil
	m.clearedFields[order.FieldNssCourierOrderNumber] = struct{}{}
}

// NssCourierOrderNumberCleared returns if the "nss_courier_order_number" field was cleared in this mutation.
func (m *OrderMutation) NssCourierOrderNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldNssCourierOrderNumber]
	return ok
}

// ResetNssCourierOrderNumber resets all changes to the "nss_courier_order_number" field.
func (m *OrderMutation) ResetNssCourierOrderNumber() {
	m.nss_courier_order_number = nil
	delete(m.clearedFields, order.FieldNssCourierOrderNumber)
}

// SetNssTrackingNumber sets the "nss_tracking_number" field.
func (m *OrderMutation) SetNssTrackingNumber(s string) {
	m.nss_tracking_number = &s
}

// NssTrackingNumber returns the value of the "nss_tracking_number" field in the mutation.
func (m *OrderMutation) NssTrackingNumber() (r string, exists bool) {
	v := m.nss_tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldNssTrackingNumber returns the old "nss_tracking_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNssTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNssTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNssTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNssTrackingNumber: %w", err)
	}
	return oldValue.NssTrackingNumber, nil
}

// ClearNssTrackingNumber clears the value of the "nss_tracking_number" field.
func (m *OrderMutation) ClearNssTrackingNumber() {
	m.nss_tracking_number = nil
	m.clearedFields[order.FieldNssTrackingNumber] = struct{}{}
}

// NssTrackingNumberCleared returns if the "nss_tracking_number" field was cleared in this mutation.
func (m *OrderMutation) NssTrackingNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldNssTrackingNumber]
	return ok
}

// ResetNssTrackingNumber resets all changes to the "nss_tracking_number" field.
func (m *OrderMutation) ResetNssTrackingNumber() {
	m.nss_tracking_number = nil
	delete(m.clearedFields, order.FieldNssTrackingNumber)
}

// SetNssTrackingURL sets the "nss_tracking_url" field.
func (m *OrderMutation) SetNssTrackingURL(s string) {
	m.nss_tracking_url = &s
}

// NssTrackingURL returns the value of the "nss_tracking_url" field in the mutation.
func (m *OrderMutation) NssTrackingURL() (r string, exists bool) {
	v := m.nss_tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNssTrackingURL returns the old "nss_tracking_url" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNssTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNssTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNssTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNssTrackingURL: %w", err)
	}
	return oldValue.NssTrackingURL, nil
}

// ClearNssTrackingURL clears the value of the "nss_tracking_url" field.
func (m *OrderMutation) ClearNssTrackingURL() {
	m.nss_tracking_url = nil
	m.clearedFields[order.FieldNssTrackingURL] = struct{}{}
}

// NssTrackingURLCleared returns if the "nss_tracking_url" field was cleared in this mutation.
func (m *OrderMutation) NssTrackingURLCleared() bool {
	_, ok := m.clearedFields[order.FieldNssTrackingURL]
	return ok
}

// ResetNssTrackingURL resets all changes to the "nss_tracking_url" field.
func (m *OrderMutation) ResetNssTrackingURL() {
	m.nss_tracking_url = nil
	delete(m.clearedFields, order.FieldNssTrackingURL)
}

// SetShippingLabelURL sets the "shipping_label_url" field.
func (m *OrderMutation) SetShippingLabelURL(s string) {
	m.shipping_label_url = &s
}

// ShippingLabelURL returns the value of the "shipping_label_url" field in the mutation.
func (m *OrderMutation) ShippingLabelURL() (r string, exists bool) {
	v := m.shipping_label_url
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingLabelURL returns the old "shipping_label_url" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingLabelURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingLabelURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingLabelURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingLabelURL: %w", err)
	}
	return oldValue.ShippingLabelURL, nil
}

// ClearShippingLabelURL clears the value of the "shipping_label_url" field.
func (m *OrderMutation) ClearShippingLabelURL() {
	m.shipping_label_url = nil
	m.clearedFields[order.FieldShippingLabelURL] = struct{}{}
}

// ShippingLabelURLCleared returns if the "shipping_label_url" field was cleared in this mutation.
func (m *OrderMutation) ShippingLabelURLCleared() bool {
	_, ok := m.clearedFields[order.FieldShippingLabelURL]
	return ok
}

// ResetShippingLabelURL resets all changes to the "shipping_label_url" field.
func (m *OrderMutation) ResetShippingLabelURL() {
	m.shipping_label_url = nil
	delete(m.clearedFields, order.FieldShippingLabelURL)
}

// SetShippingLabelPath sets the "shipping_label_path" field.
func (m *OrderMutation) SetShippingLabelPath(s string) {
	m.shipping_label_path = &s
}

// ShippingLabelPath returns the value of the "shipping_label_path" field in the mutation.
func (m *OrderMutation) ShippingLabelPath() (r string, exists bool) {
	v := m.shipping_label_path
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingLabelPath returns the old "shipping_label_path" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShippingLabelPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingLabelPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingLabelPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingLabelPath: %w", err)
	}
	return oldValue.ShippingLabelPath, nil
}

// ClearShippingLabelPath clears the value of the "shipping_label_path" field.
func (m *OrderMutation) ClearShippingLabelPath() {
	m.shipping_label_path = nil
	m.clearedFields[order.FieldShippingLabelPath] = struct{}{}
}

// ShippingLabelPathCleared returns if the "shipping_label_path" field was cleared in this mutation.
func (m *OrderMutation) ShippingLabelPathCleared() bool {
	_, ok := m.clearedFields[order.FieldShippingLabelPath]
	return ok
}

// ResetShippingLabelPath resets all changes to the "shipping_label_path" field.
func (m *OrderMutation) ResetShippingLabelPath() {
	m.shipping_label_path = nil
	delete(m.clearedFields, order.FieldShippingLabelPath)
}

// SetLabelDataPath sets the "label_data_path" field.
func (m *OrderMutation) SetLabelDataPath(s string) {
	m.label_data_path = &s
}

// LabelDataPath returns the value of the "label_data_path" field in the mutation.
func (m *OrderMutation) LabelDataPath() (r string, exists bool) {
	v := m.label_data_path
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelDataPath returns the old "label_data_path" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldLabelDataPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelDataPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelDataPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelDataPath: %w", err)
	}
	return oldValue.LabelDataPath, nil
}

// ClearLabelDataPath clears the value of the "label_data_path" field.
func (m *OrderMutation) ClearLabelDataPath() {
	m.label_data_path = nil
	m.clearedFields[order.FieldLabelDataPath] = struct{}{}
}

// LabelDataPathCleared returns if the "label_data_path" field was cleared in this mutation.
func (m *OrderMutation) LabelDataPathCleared() bool {
	_, ok := m.clearedFields[order.FieldLabelDataPath]
	return ok
}

// ResetLabelDataPath resets all changes to the "label_data_path" field.
func (m *OrderMutation) ResetLabelDataPath() {
	m.label_data_path = nil
	delete(m.clearedFields, order.FieldLabelDataPath)
}

// SetPackageID sets the "package_id" field.
func (m *OrderMutation) SetPackageID(s string) {
	m.package_id = &s
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *OrderMutation) PackageID() (r string, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPackageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *OrderMutation) ClearPackageID() {
	m.package_id = nil
	m.clearedFields[order.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *OrderMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[order.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *OrderMutation) ResetPackageID() {
	m.package_id = nil
	delete(m.clearedFields, order.FieldPackageID)
}

// SetShipDate sets the "ship_date" field.
func (m *OrderMutation) SetShipDate(t time.Time) {
	m.ship_date = &t
}

// ShipDate returns the value of the "ship_date" field in the mutation.
func (m *OrderMutation) ShipDate() (r time.Time, exists bool) {
	v := m.ship_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipDate returns the old "ship_date" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShipDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipDate: %w", err)
	}
	return oldValue.ShipDate, nil
}

// ClearShipDate clears the value of the "ship_date" field.
func (m *OrderMutation) ClearShipDate() {
	m.ship_date = nil
	m.clearedFields[order.FieldShipDate] = struct{}{}
}

// ShipDateCleared returns if the "ship_date" field was cleared in this mutation.
func (m *OrderMutation) ShipDateCleared() bool {
	_, ok := m.clearedFields[order.FieldShipDate]
	return ok
}

// ResetShipDate resets all changes to the "ship_date" field.
func (m *OrderMutation) ResetShipDate() {
	m.ship_date = nil
	delete(m.clearedFields, order.FieldShipDate)
}

// SetRequestShippingAt sets the "request_shipping_at" field.
func (m *OrderMutation) SetRequestShippingAt(t time.Time) {
	m.request_shipping_at = &t
}

// RequestShippingAt returns the value of the "request_shipping_at" field in the mutation.
func (m *OrderMutation) RequestShippingAt() (r time.Time, exists bool) {
	v := m.request_shipping_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestShippingAt returns the old "request_shipping_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRequestShippingAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestShippingAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestShippingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestShippingAt: %w", err)
	}
	return oldValue.RequestShippingAt, nil
}

// ClearRequestShippingAt clears the value of the "request_shipping_at" field.
func (m *OrderMutation) ClearRequestShippingAt() {
	m.request_shipping_at = nil
	m.clearedFields[order.FieldRequestShippingAt] = struct{}{}
}

// RequestShippingAtCleared returns if the "request_shipping_at" field was cleared in this mutation.
func (m *OrderMutation) RequestShippingAtCleared() bool {
	_, ok := m.clearedFields[order.FieldRequestShippingAt]
	return ok
}

// ResetRequestShippingAt resets all changes to the "request_shipping_at" field.
func (m *OrderMutation) ResetRequestShippingAt() {
	m.request_shipping_at = nil
	delete(m.clearedFields, order.FieldRequestShippingAt)
}

// SetUnshelfRequestedTime sets the "unshelf_requested_time" field.
func (m *OrderMutation) SetUnshelfRequestedTime(t time.Time) {
	m.unshelf_requested_time = &t
}

// UnshelfRequestedTime returns the value of the "unshelf_requested_time" field in the mutation.
func (m *OrderMutation) UnshelfRequestedTime() (r time.Time, exists bool) {
	v := m.unshelf_requested_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUnshelfRequestedTime returns the old "unshelf_requested_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUnshelfRequestedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnshelfRequestedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnshelfRequestedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnshelfRequestedTime: %w", err)
	}
	return oldValue.UnshelfRequestedTime, nil
}

// ClearUnshelfRequestedTime clears the value of the "unshelf_requested_time" field.
func (m *OrderMutation) ClearUnshelfRequestedTime() {
	m.unshelf_requested_time = nil
	m.clearedFields[order.FieldUnshelfRequestedTime] = struct{}{}
}

// UnshelfRequestedTimeCleared returns if the "unshelf_requested_time" field was cleared in this mutation.
func (m *OrderMutation) UnshelfRequestedTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldUnshelfRequestedTime]
	return ok
}

// ResetUnshelfRequestedTime resets all changes to the "unshelf_requested_time" field.
func (m *OrderMutation) ResetUnshelfRequestedTime() {
	m.unshelf_requested_time = nil
	delete(m.clearedFields, order.FieldUnshelfRequestedTime)
}

// SetContainerCode sets the "container_code" field.
func (m *OrderMutation) SetContainerCode(s string) {
	m.container_code = &s
}

// ContainerCode returns the value of the "container_code" field in the mutation.
func (m *OrderMutation) ContainerCode() (r string, exists bool) {
	v := m.container_code
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerCode returns the old "container_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldContainerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerCode: %w", err)
	}
	return oldValue.ContainerCode, nil
}

// ClearContainerCode clears the value of the "container_code" field.
func (m *OrderMutation) ClearContainerCode() {
	m.container_code = nil
	m.clearedFields[order.FieldContainerCode] = struct{}{}
}

// ContainerCodeCleared returns if the "container_code" field was cleared in this mutation.
func (m *OrderMutation) ContainerCodeCleared() bool {
	_, ok := m.clearedFields[order.FieldContainerCode]
	return ok
}

// ResetContainerCode resets all changes to the "container_code" field.
func (m *OrderMutation) ResetContainerCode() {
	m.container_code = nil
	delete(m.clearedFields, order.FieldContainerCode)
}

// SetBasketNumber sets the "basket_number" field.
func (m *OrderMutation) SetBasketNumber(s string) {
	m.basket_number = &s
}

// BasketNumber returns the value of the "basket_number" field in the mutation.
func (m *OrderMutation) BasketNumber() (r string, exists bool) {
	v := m.basket_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBasketNumber returns the old "basket_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldBasketNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasketNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasketNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasketNumber: %w", err)
	}
	return oldValue.BasketNumber, nil
}

// ClearBasketNumber clears the value of the "basket_number" field.
func (m *OrderMutation) ClearBasketNumber() {
	m.basket_number = nil
	m.clearedFields[order.FieldBasketNumber] = struct{}{}
}

// BasketNumberCleared returns if the "basket_number" field was cleared in this mutation.
func (m *OrderMutation) BasketNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldBasketNumber]
	return ok
}

// ResetBasketNumber resets all changes to the "basket_number" field.
func (m *OrderMutation) ResetBasketNumber() {
	m.basket_number = nil
	delete(m.clearedFields, order.FieldBasketNumber)
}

// SetPrintTimes sets the "print_times" field.
func (m *OrderMutation) SetPrintTimes(i int) {
	m.print_times = &i
	m.addprint_times = nil
}

// PrintTimes returns the value of the "print_times" field in the mutation.
func (m *OrderMutation) PrintTimes() (r int, exists bool) {
	v := m.print_times
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintTimes returns the old "print_times" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPrintTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintTimes: %w", err)
	}
	return oldValue.PrintTimes, nil
}

// AddPrintTimes adds i to the "print_times" field.
func (m *OrderMutation) AddPrintTimes(i int) {
	if m.addprint_times != nil {
		*m.addprint_times += i
	} else {
		m.addprint_times = &i
	}
}

// AddedPrintTimes returns the value that was added to the "print_times" field in this mutation.
func (m *OrderMutation) AddedPrintTimes() (r int, exists bool) {
	v := m.addprint_times
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrintTimes clears the value of the "print_times" field.
func (m *OrderMutation) ClearPrintTimes() {
	m.print_times = nil
	m.addprint_times = nil
	m.clearedFields[order.FieldPrintTimes] = struct{}{}
}

// PrintTimesCleared returns if the "print_times" field was cleared in this mutation.
func (m *OrderMutation) PrintTimesCleared() bool {
	_, ok := m.clearedFields[order.FieldPrintTimes]
	return ok
}

// ResetPrintTimes resets all changes to the "print_times" field.
func (m *OrderMutation) ResetPrintTimes() {
	m.print_times = nil
	m.addprint_times = nil
	delete(m.clearedFields, order.FieldPrintTimes)
}

// SetSortingTrackingNumber sets the "sorting_tracking_number" field.
func (m *OrderMutation) SetSortingTrackingNumber(s string) {
	m.sorting_tracking_number = &s
}

// SortingTrackingNumber returns the value of the "sorting_tracking_number" field in the mutation.
func (m *OrderMutation) SortingTrackingNumber() (r string, exists bool) {
	v := m.sorting_tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingTrackingNumber returns the old "sorting_tracking_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSortingTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingTrackingNumber: %w", err)
	}
	return oldValue.SortingTrackingNumber, nil
}

// ClearSortingTrackingNumber clears the value of the "sorting_tracking_number" field.
func (m *OrderMutation) ClearSortingTrackingNumber() {
	m.sorting_tracking_number = nil
	m.clearedFields[order.FieldSortingTrackingNumber] = struct{}{}
}

// SortingTrackingNumberCleared returns if the "sorting_tracking_number" field was cleared in this mutation.
func (m *OrderMutation) SortingTrackingNumberCleared() bool {
	_, ok := m.clearedFields[order.FieldSortingTrackingNumber]
	return ok
}

// ResetSortingTrackingNumber resets all changes to the "sorting_tracking_number" field.
func (m *OrderMutation) ResetSortingTrackingNumber() {
	m.sorting_tracking_number = nil
	delete(m.clearedFields, order.FieldSortingTrackingNumber)
}

// SetSortingPort sets the "sorting_port" field.
func (m *OrderMutation) SetSortingPort(i int32) {
	m.sorting_port = &i
	m.addsorting_port = nil
}

// SortingPort returns the value of the "sorting_port" field in the mutation.
func (m *OrderMutation) SortingPort() (r int32, exists bool) {
	v := m.sorting_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingPort returns the old "sorting_port" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSortingPort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingPort: %w", err)
	}
	return oldValue.SortingPort, nil
}

// AddSortingPort adds i to the "sorting_port" field.
func (m *OrderMutation) AddSortingPort(i int32) {
	if m.addsorting_port != nil {
		*m.addsorting_port += i
	} else {
		m.addsorting_port = &i
	}
}

// AddedSortingPort returns the value that was added to the "sorting_port" field in this mutation.
func (m *OrderMutation) AddedSortingPort() (r int32, exists bool) {
	v := m.addsorting_port
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortingPort clears the value of the "sorting_port" field.
func (m *OrderMutation) ClearSortingPort() {
	m.sorting_port = nil
	m.addsorting_port = nil
	m.clearedFields[order.FieldSortingPort] = struct{}{}
}

// SortingPortCleared returns if the "sorting_port" field was cleared in this mutation.
func (m *OrderMutation) SortingPortCleared() bool {
	_, ok := m.clearedFields[order.FieldSortingPort]
	return ok
}

// ResetSortingPort resets all changes to the "sorting_port" field.
func (m *OrderMutation) ResetSortingPort() {
	m.sorting_port = nil
	m.addsorting_port = nil
	delete(m.clearedFields, order.FieldSortingPort)
}

// SetSortingLength sets the "sorting_length" field.
func (m *OrderMutation) SetSortingLength(i int) {
	m.sorting_length = &i
	m.addsorting_length = nil
}

// SortingLength returns the value of the "sorting_length" field in the mutation.
func (m *OrderMutation) SortingLength() (r int, exists bool) {
	v := m.sorting_length
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingLength returns the old "sorting_length" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSortingLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingLength: %w", err)
	}
	return oldValue.SortingLength, nil
}

// AddSortingLength adds i to the "sorting_length" field.
func (m *OrderMutation) AddSortingLength(i int) {
	if m.addsorting_length != nil {
		*m.addsorting_length += i
	} else {
		m.addsorting_length = &i
	}
}

// AddedSortingLength returns the value that was added to the "sorting_length" field in this mutation.
func (m *OrderMutation) AddedSortingLength() (r int, exists bool) {
	v := m.addsorting_length
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortingLength clears the value of the "sorting_length" field.
func (m *OrderMutation) ClearSortingLength() {
	m.sorting_length = nil
	m.addsorting_length = nil
	m.clearedFields[order.FieldSortingLength] = struct{}{}
}

// SortingLengthCleared returns if the "sorting_length" field was cleared in this mutation.
func (m *OrderMutation) SortingLengthCleared() bool {
	_, ok := m.clearedFields[order.FieldSortingLength]
	return ok
}

// ResetSortingLength resets all changes to the "sorting_length" field.
func (m *OrderMutation) ResetSortingLength() {
	m.sorting_length = nil
	m.addsorting_length = nil
	delete(m.clearedFields, order.FieldSortingLength)
}

// SetSortingWidth sets the "sorting_width" field.
func (m *OrderMutation) SetSortingWidth(i int) {
	m.sorting_width = &i
	m.addsorting_width = nil
}

// SortingWidth returns the value of the "sorting_width" field in the mutation.
func (m *OrderMutation) SortingWidth() (r int, exists bool) {
	v := m.sorting_width
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingWidth returns the old "sorting_width" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSortingWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingWidth: %w", err)
	}
	return oldValue.SortingWidth, nil
}

// AddSortingWidth adds i to the "sorting_width" field.
func (m *OrderMutation) AddSortingWidth(i int) {
	if m.addsorting_width != nil {
		*m.addsorting_width += i
	} else {
		m.addsorting_width = &i
	}
}

// AddedSortingWidth returns the value that was added to the "sorting_width" field in this mutation.
func (m *OrderMutation) AddedSortingWidth() (r int, exists bool) {
	v := m.addsorting_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortingWidth clears the value of the "sorting_width" field.
func (m *OrderMutation) ClearSortingWidth() {
	m.sorting_width = nil
	m.addsorting_width = nil
	m.clearedFields[order.FieldSortingWidth] = struct{}{}
}

// SortingWidthCleared returns if the "sorting_width" field was cleared in this mutation.
func (m *OrderMutation) SortingWidthCleared() bool {
	_, ok := m.clearedFields[order.FieldSortingWidth]
	return ok
}

// ResetSortingWidth resets all changes to the "sorting_width" field.
func (m *OrderMutation) ResetSortingWidth() {
	m.sorting_width = nil
	m.addsorting_width = nil
	delete(m.clearedFields, order.FieldSortingWidth)
}

// SetSortingHeight sets the "sorting_height" field.
func (m *OrderMutation) SetSortingHeight(i int) {
	m.sorting_height = &i
	m.addsorting_height = nil
}

// SortingHeight returns the value of the "sorting_height" field in the mutation.
func (m *OrderMutation) SortingHeight() (r int, exists bool) {
	v := m.sorting_height
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingHeight returns the old "sorting_height" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSortingHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingHeight: %w", err)
	}
	return oldValue.SortingHeight, nil
}

// AddSortingHeight adds i to the "sorting_height" field.
func (m *OrderMutation) AddSortingHeight(i int) {
	if m.addsorting_height != nil {
		*m.addsorting_height += i
	} else {
		m.addsorting_height = &i
	}
}

// AddedSortingHeight returns the value that was added to the "sorting_height" field in this mutation.
func (m *OrderMutation) AddedSortingHeight() (r int, exists bool) {
	v := m.addsorting_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortingHeight clears the value of the "sorting_height" field.
func (m *OrderMutation) ClearSortingHeight() {
	m.sorting_height = nil
	m.addsorting_height = nil
	m.clearedFields[order.FieldSortingHeight] = struct{}{}
}

// SortingHeightCleared returns if the "sorting_height" field was cleared in this mutation.
func (m *OrderMutation) SortingHeightCleared() bool {
	_, ok := m.clearedFields[order.FieldSortingHeight]
	return ok
}

// ResetSortingHeight resets all changes to the "sorting_height" field.
func (m *OrderMutation) ResetSortingHeight() {
	m.sorting_height = nil
	m.addsorting_height = nil
	delete(m.clearedFields, order.FieldSortingHeight)
}

// SetSortingWeight sets the "sorting_weight" field.
func (m *OrderMutation) SetSortingWeight(i int) {
	m.sorting_weight = &i
	m.addsorting_weight = nil
}

// SortingWeight returns the value of the "sorting_weight" field in the mutation.
func (m *OrderMutation) SortingWeight() (r int, exists bool) {
	v := m.sorting_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldSortingWeight returns the old "sorting_weight" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSortingWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortingWeight: %w", err)
	}
	return oldValue.SortingWeight, nil
}

// AddSortingWeight adds i to the "sorting_weight" field.
func (m *OrderMutation) AddSortingWeight(i int) {
	if m.addsorting_weight != nil {
		*m.addsorting_weight += i
	} else {
		m.addsorting_weight = &i
	}
}

// AddedSortingWeight returns the value that was added to the "sorting_weight" field in this mutation.
func (m *OrderMutation) AddedSortingWeight() (r int, exists bool) {
	v := m.addsorting_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearSortingWeight clears the value of the "sorting_weight" field.
func (m *OrderMutation) ClearSortingWeight() {
	m.sorting_weight = nil
	m.addsorting_weight = nil
	m.clearedFields[order.FieldSortingWeight] = struct{}{}
}

// SortingWeightCleared returns if the "sorting_weight" field was cleared in this mutation.
func (m *OrderMutation) SortingWeightCleared() bool {
	_, ok := m.clearedFields[order.FieldSortingWeight]
	return ok
}

// ResetSortingWeight resets all changes to the "sorting_weight" field.
func (m *OrderMutation) ResetSortingWeight() {
	m.sorting_weight = nil
	m.addsorting_weight = nil
	delete(m.clearedFields, order.FieldSortingWeight)
}

// SetEstimatedWeight sets the "estimated_weight" field.
func (m *OrderMutation) SetEstimatedWeight(i int) {
	m.estimated_weight = &i
	m.addestimated_weight = nil
}

// EstimatedWeight returns the value of the "estimated_weight" field in the mutation.
func (m *OrderMutation) EstimatedWeight() (r int, exists bool) {
	v := m.estimated_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedWeight returns the old "estimated_weight" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEstimatedWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedWeight: %w", err)
	}
	return oldValue.EstimatedWeight, nil
}

// AddEstimatedWeight adds i to the "estimated_weight" field.
func (m *OrderMutation) AddEstimatedWeight(i int) {
	if m.addestimated_weight != nil {
		*m.addestimated_weight += i
	} else {
		m.addestimated_weight = &i
	}
}

// AddedEstimatedWeight returns the value that was added to the "estimated_weight" field in this mutation.
func (m *OrderMutation) AddedEstimatedWeight() (r int, exists bool) {
	v := m.addestimated_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedWeight clears the value of the "estimated_weight" field.
func (m *OrderMutation) ClearEstimatedWeight() {
	m.estimated_weight = nil
	m.addestimated_weight = nil
	m.clearedFields[order.FieldEstimatedWeight] = struct{}{}
}

// EstimatedWeightCleared returns if the "estimated_weight" field was cleared in this mutation.
func (m *OrderMutation) EstimatedWeightCleared() bool {
	_, ok := m.clearedFields[order.FieldEstimatedWeight]
	return ok
}

// ResetEstimatedWeight resets all changes to the "estimated_weight" field.
func (m *OrderMutation) ResetEstimatedWeight() {
	m.estimated_weight = nil
	m.addestimated_weight = nil
	delete(m.clearedFields, order.FieldEstimatedWeight)
}

// SetCheckoutActualWeight sets the "checkout_actual_weight" field.
func (m *OrderMutation) SetCheckoutActualWeight(i int) {
	m.checkout_actual_weight = &i
	m.addcheckout_actual_weight = nil
}

// CheckoutActualWeight returns the value of the "checkout_actual_weight" field in the mutation.
func (m *OrderMutation) CheckoutActualWeight() (r int, exists bool) {
	v := m.checkout_actual_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckoutActualWeight returns the old "checkout_actual_weight" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCheckoutActualWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckoutActualWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckoutActualWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckoutActualWeight: %w", err)
	}
	return oldValue.CheckoutActualWeight, nil
}

// AddCheckoutActualWeight adds i to the "checkout_actual_weight" field.
func (m *OrderMutation) AddCheckoutActualWeight(i int) {
	if m.addcheckout_actual_weight != nil {
		*m.addcheckout_actual_weight += i
	} else {
		m.addcheckout_actual_weight = &i
	}
}

// AddedCheckoutActualWeight returns the value that was added to the "checkout_actual_weight" field in this mutation.
func (m *OrderMutation) AddedCheckoutActualWeight() (r int, exists bool) {
	v := m.addcheckout_actual_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearCheckoutActualWeight clears the value of the "checkout_actual_weight" field.
func (m *OrderMutation) ClearCheckoutActualWeight() {
	m.checkout_actual_weight = nil
	m.addcheckout_actual_weight = nil
	m.clearedFields[order.FieldCheckoutActualWeight] = struct{}{}
}

// CheckoutActualWeightCleared returns if the "checkout_actual_weight" field was cleared in this mutation.
func (m *OrderMutation) CheckoutActualWeightCleared() bool {
	_, ok := m.clearedFields[order.FieldCheckoutActualWeight]
	return ok
}

// ResetCheckoutActualWeight resets all changes to the "checkout_actual_weight" field.
func (m *OrderMutation) ResetCheckoutActualWeight() {
	m.checkout_actual_weight = nil
	m.addcheckout_actual_weight = nil
	delete(m.clearedFields, order.FieldCheckoutActualWeight)
}

// SetVolumeWeight sets the "volume_weight" field.
func (m *OrderMutation) SetVolumeWeight(i int) {
	m.volume_weight = &i
	m.addvolume_weight = nil
}

// VolumeWeight returns the value of the "volume_weight" field in the mutation.
func (m *OrderMutation) VolumeWeight() (r int, exists bool) {
	v := m.volume_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeWeight returns the old "volume_weight" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldVolumeWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeWeight: %w", err)
	}
	return oldValue.VolumeWeight, nil
}

// AddVolumeWeight adds i to the "volume_weight" field.
func (m *OrderMutation) AddVolumeWeight(i int) {
	if m.addvolume_weight != nil {
		*m.addvolume_weight += i
	} else {
		m.addvolume_weight = &i
	}
}

// AddedVolumeWeight returns the value that was added to the "volume_weight" field in this mutation.
func (m *OrderMutation) AddedVolumeWeight() (r int, exists bool) {
	v := m.addvolume_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearVolumeWeight clears the value of the "volume_weight" field.
func (m *OrderMutation) ClearVolumeWeight() {
	m.volume_weight = nil
	m.addvolume_weight = nil
	m.clearedFields[order.FieldVolumeWeight] = struct{}{}
}

// VolumeWeightCleared returns if the "volume_weight" field was cleared in this mutation.
func (m *OrderMutation) VolumeWeightCleared() bool {
	_, ok := m.clearedFields[order.FieldVolumeWeight]
	return ok
}

// ResetVolumeWeight resets all changes to the "volume_weight" field.
func (m *OrderMutation) ResetVolumeWeight() {
	m.volume_weight = nil
	m.addvolume_weight = nil
	delete(m.clearedFields, order.FieldVolumeWeight)
}

// SetCourierWeight sets the "courier_weight" field.
func (m *OrderMutation) SetCourierWeight(i int) {
	m.courier_weight = &i
	m.addcourier_weight = nil
}

// CourierWeight returns the value of the "courier_weight" field in the mutation.
func (m *OrderMutation) CourierWeight() (r int, exists bool) {
	v := m.courier_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierWeight returns the old "courier_weight" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCourierWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourierWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourierWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierWeight: %w", err)
	}
	return oldValue.CourierWeight, nil
}

// AddCourierWeight adds i to the "courier_weight" field.
func (m *OrderMutation) AddCourierWeight(i int) {
	if m.addcourier_weight != nil {
		*m.addcourier_weight += i
	} else {
		m.addcourier_weight = &i
	}
}

// AddedCourierWeight returns the value that was added to the "courier_weight" field in this mutation.
func (m *OrderMutation) AddedCourierWeight() (r int, exists bool) {
	v := m.addcourier_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearCourierWeight clears the value of the "courier_weight" field.
func (m *OrderMutation) ClearCourierWeight() {
	m.courier_weight = nil
	m.addcourier_weight = nil
	m.clearedFields[order.FieldCourierWeight] = struct{}{}
}

// CourierWeightCleared returns if the "courier_weight" field was cleared in this mutation.
func (m *OrderMutation) CourierWeightCleared() bool {
	_, ok := m.clearedFields[order.FieldCourierWeight]
	return ok
}

// ResetCourierWeight resets all changes to the "courier_weight" field.
func (m *OrderMutation) ResetCourierWeight() {
	m.courier_weight = nil
	m.addcourier_weight = nil
	delete(m.clearedFields, order.FieldCourierWeight)
}

// SetDeclaredValueInUsd sets the "declared_value_in_usd" field.
func (m *OrderMutation) SetDeclaredValueInUsd(f float64) {
	m.declared_value_in_usd = &f
	m.adddeclared_value_in_usd = nil
}

// DeclaredValueInUsd returns the value of the "declared_value_in_usd" field in the mutation.
func (m *OrderMutation) DeclaredValueInUsd() (r float64, exists bool) {
	v := m.declared_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredValueInUsd returns the old "declared_value_in_usd" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeclaredValueInUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredValueInUsd: %w", err)
	}
	return oldValue.DeclaredValueInUsd, nil
}

// AddDeclaredValueInUsd adds f to the "declared_value_in_usd" field.
func (m *OrderMutation) AddDeclaredValueInUsd(f float64) {
	if m.adddeclared_value_in_usd != nil {
		*m.adddeclared_value_in_usd += f
	} else {
		m.adddeclared_value_in_usd = &f
	}
}

// AddedDeclaredValueInUsd returns the value that was added to the "declared_value_in_usd" field in this mutation.
func (m *OrderMutation) AddedDeclaredValueInUsd() (r float64, exists bool) {
	v := m.adddeclared_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeclaredValueInUsd clears the value of the "declared_value_in_usd" field.
func (m *OrderMutation) ClearDeclaredValueInUsd() {
	m.declared_value_in_usd = nil
	m.adddeclared_value_in_usd = nil
	m.clearedFields[order.FieldDeclaredValueInUsd] = struct{}{}
}

// DeclaredValueInUsdCleared returns if the "declared_value_in_usd" field was cleared in this mutation.
func (m *OrderMutation) DeclaredValueInUsdCleared() bool {
	_, ok := m.clearedFields[order.FieldDeclaredValueInUsd]
	return ok
}

// ResetDeclaredValueInUsd resets all changes to the "declared_value_in_usd" field.
func (m *OrderMutation) ResetDeclaredValueInUsd() {
	m.declared_value_in_usd = nil
	m.adddeclared_value_in_usd = nil
	delete(m.clearedFields, order.FieldDeclaredValueInUsd)
}

// SetDeclaredValueInEur sets the "declared_value_in_eur" field.
func (m *OrderMutation) SetDeclaredValueInEur(f float64) {
	m.declared_value_in_eur = &f
	m.adddeclared_value_in_eur = nil
}

// DeclaredValueInEur returns the value of the "declared_value_in_eur" field in the mutation.
func (m *OrderMutation) DeclaredValueInEur() (r float64, exists bool) {
	v := m.declared_value_in_eur
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredValueInEur returns the old "declared_value_in_eur" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeclaredValueInEur(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredValueInEur is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredValueInEur requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredValueInEur: %w", err)
	}
	return oldValue.DeclaredValueInEur, nil
}

// AddDeclaredValueInEur adds f to the "declared_value_in_eur" field.
func (m *OrderMutation) AddDeclaredValueInEur(f float64) {
	if m.adddeclared_value_in_eur != nil {
		*m.adddeclared_value_in_eur += f
	} else {
		m.adddeclared_value_in_eur = &f
	}
}

// AddedDeclaredValueInEur returns the value that was added to the "declared_value_in_eur" field in this mutation.
func (m *OrderMutation) AddedDeclaredValueInEur() (r float64, exists bool) {
	v := m.adddeclared_value_in_eur
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeclaredValueInEur clears the value of the "declared_value_in_eur" field.
func (m *OrderMutation) ClearDeclaredValueInEur() {
	m.declared_value_in_eur = nil
	m.adddeclared_value_in_eur = nil
	m.clearedFields[order.FieldDeclaredValueInEur] = struct{}{}
}

// DeclaredValueInEurCleared returns if the "declared_value_in_eur" field was cleared in this mutation.
func (m *OrderMutation) DeclaredValueInEurCleared() bool {
	_, ok := m.clearedFields[order.FieldDeclaredValueInEur]
	return ok
}

// ResetDeclaredValueInEur resets all changes to the "declared_value_in_eur" field.
func (m *OrderMutation) ResetDeclaredValueInEur() {
	m.declared_value_in_eur = nil
	m.adddeclared_value_in_eur = nil
	delete(m.clearedFields, order.FieldDeclaredValueInEur)
}

// SetTotalItemsPrice sets the "total_items_price" field.
func (m *OrderMutation) SetTotalItemsPrice(f float64) {
	m.total_items_price = &f
	m.addtotal_items_price = nil
}

// TotalItemsPrice returns the value of the "total_items_price" field in the mutation.
func (m *OrderMutation) TotalItemsPrice() (r float64, exists bool) {
	v := m.total_items_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalItemsPrice returns the old "total_items_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalItemsPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalItemsPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalItemsPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalItemsPrice: %w", err)
	}
	return oldValue.TotalItemsPrice, nil
}

// AddTotalItemsPrice adds f to the "total_items_price" field.
func (m *OrderMutation) AddTotalItemsPrice(f float64) {
	if m.addtotal_items_price != nil {
		*m.addtotal_items_price += f
	} else {
		m.addtotal_items_price = &f
	}
}

// AddedTotalItemsPrice returns the value that was added to the "total_items_price" field in this mutation.
func (m *OrderMutation) AddedTotalItemsPrice() (r float64, exists bool) {
	v := m.addtotal_items_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalItemsPrice clears the value of the "total_items_price" field.
func (m *OrderMutation) ClearTotalItemsPrice() {
	m.total_items_price = nil
	m.addtotal_items_price = nil
	m.clearedFields[order.FieldTotalItemsPrice] = struct{}{}
}

// TotalItemsPriceCleared returns if the "total_items_price" field was cleared in this mutation.
func (m *OrderMutation) TotalItemsPriceCleared() bool {
	_, ok := m.clearedFields[order.FieldTotalItemsPrice]
	return ok
}

// ResetTotalItemsPrice resets all changes to the "total_items_price" field.
func (m *OrderMutation) ResetTotalItemsPrice() {
	m.total_items_price = nil
	m.addtotal_items_price = nil
	delete(m.clearedFields, order.FieldTotalItemsPrice)
}

// SetCurrency sets the "currency" field.
func (m *OrderMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *OrderMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *OrderMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[order.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *OrderMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[order.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *OrderMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, order.FieldCurrency)
}

// SetDeliveryCost sets the "delivery_cost" field.
func (m *OrderMutation) SetDeliveryCost(f float64) {
	m.delivery_cost = &f
	m.adddelivery_cost = nil
}

// DeliveryCost returns the value of the "delivery_cost" field in the mutation.
func (m *OrderMutation) DeliveryCost() (r float64, exists bool) {
	v := m.delivery_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryCost returns the old "delivery_cost" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveryCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryCost: %w", err)
	}
	return oldValue.DeliveryCost, nil
}

// AddDeliveryCost adds f to the "delivery_cost" field.
func (m *OrderMutation) AddDeliveryCost(f float64) {
	if m.adddelivery_cost != nil {
		*m.adddelivery_cost += f
	} else {
		m.adddelivery_cost = &f
	}
}

// AddedDeliveryCost returns the value that was added to the "delivery_cost" field in this mutation.
func (m *OrderMutation) AddedDeliveryCost() (r float64, exists bool) {
	v := m.adddelivery_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeliveryCost resets all changes to the "delivery_cost" field.
func (m *OrderMutation) ResetDeliveryCost() {
	m.delivery_cost = nil
	m.adddelivery_cost = nil
}

// SetMiscFee sets the "misc_fee" field.
func (m *OrderMutation) SetMiscFee(f float64) {
	m.misc_fee = &f
	m.addmisc_fee = nil
}

// MiscFee returns the value of the "misc_fee" field in the mutation.
func (m *OrderMutation) MiscFee() (r float64, exists bool) {
	v := m.misc_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldMiscFee returns the old "misc_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldMiscFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiscFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiscFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiscFee: %w", err)
	}
	return oldValue.MiscFee, nil
}

// AddMiscFee adds f to the "misc_fee" field.
func (m *OrderMutation) AddMiscFee(f float64) {
	if m.addmisc_fee != nil {
		*m.addmisc_fee += f
	} else {
		m.addmisc_fee = &f
	}
}

// AddedMiscFee returns the value that was added to the "misc_fee" field in this mutation.
func (m *OrderMutation) AddedMiscFee() (r float64, exists bool) {
	v := m.addmisc_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetMiscFee resets all changes to the "misc_fee" field.
func (m *OrderMutation) ResetMiscFee() {
	m.misc_fee = nil
	m.addmisc_fee = nil
}

// SetFuelFee sets the "fuel_fee" field.
func (m *OrderMutation) SetFuelFee(f float64) {
	m.fuel_fee = &f
	m.addfuel_fee = nil
}

// FuelFee returns the value of the "fuel_fee" field in the mutation.
func (m *OrderMutation) FuelFee() (r float64, exists bool) {
	v := m.fuel_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelFee returns the old "fuel_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFuelFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelFee: %w", err)
	}
	return oldValue.FuelFee, nil
}

// AddFuelFee adds f to the "fuel_fee" field.
func (m *OrderMutation) AddFuelFee(f float64) {
	if m.addfuel_fee != nil {
		*m.addfuel_fee += f
	} else {
		m.addfuel_fee = &f
	}
}

// AddedFuelFee returns the value that was added to the "fuel_fee" field in this mutation.
func (m *OrderMutation) AddedFuelFee() (r float64, exists bool) {
	v := m.addfuel_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFuelFee resets all changes to the "fuel_fee" field.
func (m *OrderMutation) ResetFuelFee() {
	m.fuel_fee = nil
	m.addfuel_fee = nil
}

// SetRegistrationFee sets the "registration_fee" field.
func (m *OrderMutation) SetRegistrationFee(f float64) {
	m.registration_fee = &f
	m.addregistration_fee = nil
}

// RegistrationFee returns the value of the "registration_fee" field in the mutation.
func (m *OrderMutation) RegistrationFee() (r float64, exists bool) {
	v := m.registration_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationFee returns the old "registration_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRegistrationFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationFee: %w", err)
	}
	return oldValue.RegistrationFee, nil
}

// AddRegistrationFee adds f to the "registration_fee" field.
func (m *OrderMutation) AddRegistrationFee(f float64) {
	if m.addregistration_fee != nil {
		*m.addregistration_fee += f
	} else {
		m.addregistration_fee = &f
	}
}

// AddedRegistrationFee returns the value that was added to the "registration_fee" field in this mutation.
func (m *OrderMutation) AddedRegistrationFee() (r float64, exists bool) {
	v := m.addregistration_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegistrationFee resets all changes to the "registration_fee" field.
func (m *OrderMutation) ResetRegistrationFee() {
	m.registration_fee = nil
	m.addregistration_fee = nil
}

// SetProcessingFee sets the "processing_fee" field.
func (m *OrderMutation) SetProcessingFee(f float64) {
	m.processing_fee = &f
	m.addprocessing_fee = nil
}

// ProcessingFee returns the value of the "processing_fee" field in the mutation.
func (m *OrderMutation) ProcessingFee() (r float64, exists bool) {
	v := m.processing_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessingFee returns the old "processing_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldProcessingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessingFee: %w", err)
	}
	return oldValue.ProcessingFee, nil
}

// AddProcessingFee adds f to the "processing_fee" field.
func (m *OrderMutation) AddProcessingFee(f float64) {
	if m.addprocessing_fee != nil {
		*m.addprocessing_fee += f
	} else {
		m.addprocessing_fee = &f
	}
}

// AddedProcessingFee returns the value that was added to the "processing_fee" field in this mutation.
func (m *OrderMutation) AddedProcessingFee() (r float64, exists bool) {
	v := m.addprocessing_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcessingFee resets all changes to the "processing_fee" field.
func (m *OrderMutation) ResetProcessingFee() {
	m.processing_fee = nil
	m.addprocessing_fee = nil
}

// SetPackageFee sets the "package_fee" field.
func (m *OrderMutation) SetPackageFee(f float64) {
	m.package_fee = &f
	m.addpackage_fee = nil
}

// PackageFee returns the value of the "package_fee" field in the mutation.
func (m *OrderMutation) PackageFee() (r float64, exists bool) {
	v := m.package_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageFee returns the old "package_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPackageFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageFee: %w", err)
	}
	return oldValue.PackageFee, nil
}

// AddPackageFee adds f to the "package_fee" field.
func (m *OrderMutation) AddPackageFee(f float64) {
	if m.addpackage_fee != nil {
		*m.addpackage_fee += f
	} else {
		m.addpackage_fee = &f
	}
}

// AddedPackageFee returns the value that was added to the "package_fee" field in this mutation.
func (m *OrderMutation) AddedPackageFee() (r float64, exists bool) {
	v := m.addpackage_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetPackageFee resets all changes to the "package_fee" field.
func (m *OrderMutation) ResetPackageFee() {
	m.package_fee = nil
	m.addpackage_fee = nil
}

// SetHandlingFee sets the "handling_fee" field.
func (m *OrderMutation) SetHandlingFee(f float64) {
	m.handling_fee = &f
	m.addhandling_fee = nil
}

// HandlingFee returns the value of the "handling_fee" field in the mutation.
func (m *OrderMutation) HandlingFee() (r float64, exists bool) {
	v := m.handling_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlingFee returns the old "handling_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldHandlingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlingFee: %w", err)
	}
	return oldValue.HandlingFee, nil
}

// AddHandlingFee adds f to the "handling_fee" field.
func (m *OrderMutation) AddHandlingFee(f float64) {
	if m.addhandling_fee != nil {
		*m.addhandling_fee += f
	} else {
		m.addhandling_fee = &f
	}
}

// AddedHandlingFee returns the value that was added to the "handling_fee" field in this mutation.
func (m *OrderMutation) AddedHandlingFee() (r float64, exists bool) {
	v := m.addhandling_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandlingFee resets all changes to the "handling_fee" field.
func (m *OrderMutation) ResetHandlingFee() {
	m.handling_fee = nil
	m.addhandling_fee = nil
}

// SetVat sets the "vat" field.
func (m *OrderMutation) SetVat(f float64) {
	m.vat = &f
	m.addvat = nil
}

// Vat returns the value of the "vat" field in the mutation.
func (m *OrderMutation) Vat() (r float64, exists bool) {
	v := m.vat
	if v == nil {
		return
	}
	return *v, true
}

// OldVat returns the old "vat" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldVat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVat: %w", err)
	}
	return oldValue.Vat, nil
}

// AddVat adds f to the "vat" field.
func (m *OrderMutation) AddVat(f float64) {
	if m.addvat != nil {
		*m.addvat += f
	} else {
		m.addvat = &f
	}
}

// AddedVat returns the value that was added to the "vat" field in this mutation.
func (m *OrderMutation) AddedVat() (r float64, exists bool) {
	v := m.addvat
	if v == nil {
		return
	}
	return *v, true
}

// ResetVat resets all changes to the "vat" field.
func (m *OrderMutation) ResetVat() {
	m.vat = nil
	m.addvat = nil
}

// SetEstimatedCost sets the "estimated_cost" field.
func (m *OrderMutation) SetEstimatedCost(f float64) {
	m.estimated_cost = &f
	m.addestimated_cost = nil
}

// EstimatedCost returns the value of the "estimated_cost" field in the mutation.
func (m *OrderMutation) EstimatedCost() (r float64, exists bool) {
	v := m.estimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCost returns the old "estimated_cost" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEstimatedCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCost: %w", err)
	}
	return oldValue.EstimatedCost, nil
}

// AddEstimatedCost adds f to the "estimated_cost" field.
func (m *OrderMutation) AddEstimatedCost(f float64) {
	if m.addestimated_cost != nil {
		*m.addestimated_cost += f
	} else {
		m.addestimated_cost = &f
	}
}

// AddedEstimatedCost returns the value that was added to the "estimated_cost" field in this mutation.
func (m *OrderMutation) AddedEstimatedCost() (r float64, exists bool) {
	v := m.addestimated_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstimatedCost resets all changes to the "estimated_cost" field.
func (m *OrderMutation) ResetEstimatedCost() {
	m.estimated_cost = nil
	m.addestimated_cost = nil
}

// SetEstimatedCurrency sets the "estimated_currency" field.
func (m *OrderMutation) SetEstimatedCurrency(s string) {
	m.estimated_currency = &s
}

// EstimatedCurrency returns the value of the "estimated_currency" field in the mutation.
func (m *OrderMutation) EstimatedCurrency() (r string, exists bool) {
	v := m.estimated_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCurrency returns the old "estimated_currency" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEstimatedCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCurrency: %w", err)
	}
	return oldValue.EstimatedCurrency, nil
}

// ResetEstimatedCurrency resets all changes to the "estimated_currency" field.
func (m *OrderMutation) ResetEstimatedCurrency() {
	m.estimated_currency = nil
}

// SetReceivablesAmount sets the "receivables_amount" field.
func (m *OrderMutation) SetReceivablesAmount(f float64) {
	m.receivables_amount = &f
	m.addreceivables_amount = nil
}

// ReceivablesAmount returns the value of the "receivables_amount" field in the mutation.
func (m *OrderMutation) ReceivablesAmount() (r float64, exists bool) {
	v := m.receivables_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivablesAmount returns the old "receivables_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldReceivablesAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivablesAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivablesAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivablesAmount: %w", err)
	}
	return oldValue.ReceivablesAmount, nil
}

// AddReceivablesAmount adds f to the "receivables_amount" field.
func (m *OrderMutation) AddReceivablesAmount(f float64) {
	if m.addreceivables_amount != nil {
		*m.addreceivables_amount += f
	} else {
		m.addreceivables_amount = &f
	}
}

// AddedReceivablesAmount returns the value that was added to the "receivables_amount" field in this mutation.
func (m *OrderMutation) AddedReceivablesAmount() (r float64, exists bool) {
	v := m.addreceivables_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivablesAmount resets all changes to the "receivables_amount" field.
func (m *OrderMutation) ResetReceivablesAmount() {
	m.receivables_amount = nil
	m.addreceivables_amount = nil
}

// SetReceivablesCurrency sets the "receivables_currency" field.
func (m *OrderMutation) SetReceivablesCurrency(s string) {
	m.receivables_currency = &s
}

// ReceivablesCurrency returns the value of the "receivables_currency" field in the mutation.
func (m *OrderMutation) ReceivablesCurrency() (r string, exists bool) {
	v := m.receivables_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivablesCurrency returns the old "receivables_currency" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldReceivablesCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivablesCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivablesCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivablesCurrency: %w", err)
	}
	return oldValue.ReceivablesCurrency, nil
}

// ResetReceivablesCurrency resets all changes to the "receivables_currency" field.
func (m *OrderMutation) ResetReceivablesCurrency() {
	m.receivables_currency = nil
}

// SetNotAcceptPlatformUpdate sets the "not_accept_platform_update" field.
func (m *OrderMutation) SetNotAcceptPlatformUpdate(b bool) {
	m.not_accept_platform_update = &b
}

// NotAcceptPlatformUpdate returns the value of the "not_accept_platform_update" field in the mutation.
func (m *OrderMutation) NotAcceptPlatformUpdate() (r bool, exists bool) {
	v := m.not_accept_platform_update
	if v == nil {
		return
	}
	return *v, true
}

// OldNotAcceptPlatformUpdate returns the old "not_accept_platform_update" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNotAcceptPlatformUpdate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotAcceptPlatformUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotAcceptPlatformUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotAcceptPlatformUpdate: %w", err)
	}
	return oldValue.NotAcceptPlatformUpdate, nil
}

// ResetNotAcceptPlatformUpdate resets all changes to the "not_accept_platform_update" field.
func (m *OrderMutation) ResetNotAcceptPlatformUpdate() {
	m.not_accept_platform_update = nil
}

// SetNotAcceptPlatformUpdateItem sets the "not_accept_platform_update_item" field.
func (m *OrderMutation) SetNotAcceptPlatformUpdateItem(b bool) {
	m.not_accept_platform_update_item = &b
}

// NotAcceptPlatformUpdateItem returns the value of the "not_accept_platform_update_item" field in the mutation.
func (m *OrderMutation) NotAcceptPlatformUpdateItem() (r bool, exists bool) {
	v := m.not_accept_platform_update_item
	if v == nil {
		return
	}
	return *v, true
}

// OldNotAcceptPlatformUpdateItem returns the old "not_accept_platform_update_item" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNotAcceptPlatformUpdateItem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotAcceptPlatformUpdateItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotAcceptPlatformUpdateItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotAcceptPlatformUpdateItem: %w", err)
	}
	return oldValue.NotAcceptPlatformUpdateItem, nil
}

// ResetNotAcceptPlatformUpdateItem resets all changes to the "not_accept_platform_update_item" field.
func (m *OrderMutation) ResetNotAcceptPlatformUpdateItem() {
	m.not_accept_platform_update_item = nil
}

// SetJdPushedStatus sets the "jd_pushed_status" field.
func (m *OrderMutation) SetJdPushedStatus(s string) {
	m.jd_pushed_status = &s
}

// JdPushedStatus returns the value of the "jd_pushed_status" field in the mutation.
func (m *OrderMutation) JdPushedStatus() (r string, exists bool) {
	v := m.jd_pushed_status
	if v == nil {
		return
	}
	return *v, true
}

// OldJdPushedStatus returns the old "jd_pushed_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldJdPushedStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJdPushedStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJdPushedStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJdPushedStatus: %w", err)
	}
	return oldValue.JdPushedStatus, nil
}

// ResetJdPushedStatus resets all changes to the "jd_pushed_status" field.
func (m *OrderMutation) ResetJdPushedStatus() {
	m.jd_pushed_status = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *OrderMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrderMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrderMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *OrderMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrderMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddOrderItemIDs(ids ...int64) {
	if m.order_items == nil {
		m.order_items = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveOrderItemIDs(ids ...int64) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedOrderItemsIDs() (ids []int64) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderMutation) OrderItemsIDs() (ids []int64) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddOrderHoldReasonIDs adds the "order_hold_reasons" edge to the OrderHoldReason entity by ids.
func (m *OrderMutation) AddOrderHoldReasonIDs(ids ...int64) {
	if m.order_hold_reasons == nil {
		m.order_hold_reasons = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_hold_reasons[ids[i]] = struct{}{}
	}
}

// ClearOrderHoldReasons clears the "order_hold_reasons" edge to the OrderHoldReason entity.
func (m *OrderMutation) ClearOrderHoldReasons() {
	m.clearedorder_hold_reasons = true
}

// OrderHoldReasonsCleared reports if the "order_hold_reasons" edge to the OrderHoldReason entity was cleared.
func (m *OrderMutation) OrderHoldReasonsCleared() bool {
	return m.clearedorder_hold_reasons
}

// RemoveOrderHoldReasonIDs removes the "order_hold_reasons" edge to the OrderHoldReason entity by IDs.
func (m *OrderMutation) RemoveOrderHoldReasonIDs(ids ...int64) {
	if m.removedorder_hold_reasons == nil {
		m.removedorder_hold_reasons = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_hold_reasons, ids[i])
		m.removedorder_hold_reasons[ids[i]] = struct{}{}
	}
}

// RemovedOrderHoldReasons returns the removed IDs of the "order_hold_reasons" edge to the OrderHoldReason entity.
func (m *OrderMutation) RemovedOrderHoldReasonsIDs() (ids []int64) {
	for id := range m.removedorder_hold_reasons {
		ids = append(ids, id)
	}
	return
}

// OrderHoldReasonsIDs returns the "order_hold_reasons" edge IDs in the mutation.
func (m *OrderMutation) OrderHoldReasonsIDs() (ids []int64) {
	for id := range m.order_hold_reasons {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHoldReasons resets all changes to the "order_hold_reasons" edge.
func (m *OrderMutation) ResetOrderHoldReasons() {
	m.order_hold_reasons = nil
	m.clearedorder_hold_reasons = false
	m.removedorder_hold_reasons = nil
}

// AddOrderTaxationIDs adds the "order_taxations" edge to the OrderTaxation entity by ids.
func (m *OrderMutation) AddOrderTaxationIDs(ids ...int64) {
	if m.order_taxations == nil {
		m.order_taxations = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_taxations[ids[i]] = struct{}{}
	}
}

// ClearOrderTaxations clears the "order_taxations" edge to the OrderTaxation entity.
func (m *OrderMutation) ClearOrderTaxations() {
	m.clearedorder_taxations = true
}

// OrderTaxationsCleared reports if the "order_taxations" edge to the OrderTaxation entity was cleared.
func (m *OrderMutation) OrderTaxationsCleared() bool {
	return m.clearedorder_taxations
}

// RemoveOrderTaxationIDs removes the "order_taxations" edge to the OrderTaxation entity by IDs.
func (m *OrderMutation) RemoveOrderTaxationIDs(ids ...int64) {
	if m.removedorder_taxations == nil {
		m.removedorder_taxations = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_taxations, ids[i])
		m.removedorder_taxations[ids[i]] = struct{}{}
	}
}

// RemovedOrderTaxations returns the removed IDs of the "order_taxations" edge to the OrderTaxation entity.
func (m *OrderMutation) RemovedOrderTaxationsIDs() (ids []int64) {
	for id := range m.removedorder_taxations {
		ids = append(ids, id)
	}
	return
}

// OrderTaxationsIDs returns the "order_taxations" edge IDs in the mutation.
func (m *OrderMutation) OrderTaxationsIDs() (ids []int64) {
	for id := range m.order_taxations {
		ids = append(ids, id)
	}
	return
}

// ResetOrderTaxations resets all changes to the "order_taxations" edge.
func (m *OrderMutation) ResetOrderTaxations() {
	m.order_taxations = nil
	m.clearedorder_taxations = false
	m.removedorder_taxations = nil
}

// SetStoresID sets the "stores" edge to the Store entity by id.
func (m *OrderMutation) SetStoresID(id int64) {
	m.stores = &id
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *OrderMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *OrderMutation) StoresCleared() bool {
	return m.StoreIDCleared() || m.clearedstores
}

// StoresID returns the "stores" edge ID in the mutation.
func (m *OrderMutation) StoresID() (id int64, exists bool) {
	if m.stores != nil {
		return *m.stores, true
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoresID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) StoresIDs() (ids []int64) {
	if id := m.stores; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *OrderMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
}

// SetWarehousesID sets the "warehouses" edge to the Warehouse entity by id.
func (m *OrderMutation) SetWarehousesID(id int64) {
	m.warehouses = &id
}

// ClearWarehouses clears the "warehouses" edge to the Warehouse entity.
func (m *OrderMutation) ClearWarehouses() {
	m.clearedwarehouses = true
}

// WarehousesCleared reports if the "warehouses" edge to the Warehouse entity was cleared.
func (m *OrderMutation) WarehousesCleared() bool {
	return m.WarehouseIDCleared() || m.clearedwarehouses
}

// WarehousesID returns the "warehouses" edge ID in the mutation.
func (m *OrderMutation) WarehousesID() (id int64, exists bool) {
	if m.warehouses != nil {
		return *m.warehouses, true
	}
	return
}

// WarehousesIDs returns the "warehouses" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WarehousesID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) WarehousesIDs() (ids []int64) {
	if id := m.warehouses; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWarehouses resets all changes to the "warehouses" edge.
func (m *OrderMutation) ResetWarehouses() {
	m.warehouses = nil
	m.clearedwarehouses = false
}

// SetChannelsID sets the "channels" edge to the Channel entity by id.
func (m *OrderMutation) SetChannelsID(id int64) {
	m.channels = &id
}

// ClearChannels clears the "channels" edge to the Channel entity.
func (m *OrderMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the Channel entity was cleared.
func (m *OrderMutation) ChannelsCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannels
}

// ChannelsID returns the "channels" edge ID in the mutation.
func (m *OrderMutation) ChannelsID() (id int64, exists bool) {
	if m.channels != nil {
		return *m.channels, true
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelsID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ChannelsIDs() (ids []int64) {
	if id := m.channels; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *OrderMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
}

// AddTrackMappingIDs adds the "track_mappings" edge to the TrackMapping entity by ids.
func (m *OrderMutation) AddTrackMappingIDs(ids ...int64) {
	if m.track_mappings == nil {
		m.track_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		m.track_mappings[ids[i]] = struct{}{}
	}
}

// ClearTrackMappings clears the "track_mappings" edge to the TrackMapping entity.
func (m *OrderMutation) ClearTrackMappings() {
	m.clearedtrack_mappings = true
}

// TrackMappingsCleared reports if the "track_mappings" edge to the TrackMapping entity was cleared.
func (m *OrderMutation) TrackMappingsCleared() bool {
	return m.clearedtrack_mappings
}

// RemoveTrackMappingIDs removes the "track_mappings" edge to the TrackMapping entity by IDs.
func (m *OrderMutation) RemoveTrackMappingIDs(ids ...int64) {
	if m.removedtrack_mappings == nil {
		m.removedtrack_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.track_mappings, ids[i])
		m.removedtrack_mappings[ids[i]] = struct{}{}
	}
}

// RemovedTrackMappings returns the removed IDs of the "track_mappings" edge to the TrackMapping entity.
func (m *OrderMutation) RemovedTrackMappingsIDs() (ids []int64) {
	for id := range m.removedtrack_mappings {
		ids = append(ids, id)
	}
	return
}

// TrackMappingsIDs returns the "track_mappings" edge IDs in the mutation.
func (m *OrderMutation) TrackMappingsIDs() (ids []int64) {
	for id := range m.track_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetTrackMappings resets all changes to the "track_mappings" edge.
func (m *OrderMutation) ResetTrackMappings() {
	m.track_mappings = nil
	m.clearedtrack_mappings = false
	m.removedtrack_mappings = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 108)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.order_number != nil {
		fields = append(fields, order.FieldOrderNumber)
	}
	if m.mode != nil {
		fields = append(fields, order.FieldMode)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.offline != nil {
		fields = append(fields, order.FieldOffline)
	}
	if m.stores != nil {
		fields = append(fields, order.FieldStoreID)
	}
	if m.warehouses != nil {
		fields = append(fields, order.FieldWarehouseID)
	}
	if m.customer_code != nil {
		fields = append(fields, order.FieldCustomerCode)
	}
	if m.prepay_tariff != nil {
		fields = append(fields, order.FieldPrepayTariff)
	}
	if m.ioss_number != nil {
		fields = append(fields, order.FieldIossNumber)
	}
	if m.ioss_country_code != nil {
		fields = append(fields, order.FieldIossCountryCode)
	}
	if m.ioss_number_type != nil {
		fields = append(fields, order.FieldIossNumberType)
	}
	if m.uk_vat_number != nil {
		fields = append(fields, order.FieldUkVatNumber)
	}
	if m.inbound_order_number != nil {
		fields = append(fields, order.FieldInboundOrderNumber)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.sqs_status != nil {
		fields = append(fields, order.FieldSqsStatus)
	}
	if m.hold_status != nil {
		fields = append(fields, order.FieldHoldStatus)
	}
	if m.payment_status != nil {
		fields = append(fields, order.FieldPaymentStatus)
	}
	if m.cancel_request != nil {
		fields = append(fields, order.FieldCancelRequest)
	}
	if m.platform != nil {
		fields = append(fields, order.FieldPlatform)
	}
	if m.platform_order_id != nil {
		fields = append(fields, order.FieldPlatformOrderID)
	}
	if m.platform_order_no != nil {
		fields = append(fields, order.FieldPlatformOrderNo)
	}
	if m.platform_order_status_url != nil {
		fields = append(fields, order.FieldPlatformOrderStatusURL)
	}
	if m.platform_status != nil {
		fields = append(fields, order.FieldPlatformStatus)
	}
	if m.paid_status != nil {
		fields = append(fields, order.FieldPaidStatus)
	}
	if m.fulfillment_pushed != nil {
		fields = append(fields, order.FieldFulfillmentPushed)
	}
	if m.fulfillment_status != nil {
		fields = append(fields, order.FieldFulfillmentStatus)
	}
	if m.platform_created_at != nil {
		fields = append(fields, order.FieldPlatformCreatedAt)
	}
	if m.location_id != nil {
		fields = append(fields, order.FieldLocationID)
	}
	if m.tags != nil {
		fields = append(fields, order.FieldTags)
	}
	if m.note != nil {
		fields = append(fields, order.FieldNote)
	}
	if m.cancel_reason != nil {
		fields = append(fields, order.FieldCancelReason)
	}
	if m.cancelled_at != nil {
		fields = append(fields, order.FieldCancelledAt)
	}
	if m.closed_at != nil {
		fields = append(fields, order.FieldClosedAt)
	}
	if m.contact_email != nil {
		fields = append(fields, order.FieldContactEmail)
	}
	if m.contact_phone != nil {
		fields = append(fields, order.FieldContactPhone)
	}
	if m.shipping_name != nil {
		fields = append(fields, order.FieldShippingName)
	}
	if m.shipping_first_name != nil {
		fields = append(fields, order.FieldShippingFirstName)
	}
	if m.shipping_last_name != nil {
		fields = append(fields, order.FieldShippingLastName)
	}
	if m.shipping_company != nil {
		fields = append(fields, order.FieldShippingCompany)
	}
	if m.shipping_country != nil {
		fields = append(fields, order.FieldShippingCountry)
	}
	if m.shipping_country_code != nil {
		fields = append(fields, order.FieldShippingCountryCode)
	}
	if m.shipping_province != nil {
		fields = append(fields, order.FieldShippingProvince)
	}
	if m.shipping_province_code != nil {
		fields = append(fields, order.FieldShippingProvinceCode)
	}
	if m.shipping_city != nil {
		fields = append(fields, order.FieldShippingCity)
	}
	if m.shipping_address1 != nil {
		fields = append(fields, order.FieldShippingAddress1)
	}
	if m.shipping_address2 != nil {
		fields = append(fields, order.FieldShippingAddress2)
	}
	if m.shipping_zip_code != nil {
		fields = append(fields, order.FieldShippingZipCode)
	}
	if m.shipping_phone != nil {
		fields = append(fields, order.FieldShippingPhone)
	}
	if m.shipping_certificate_type != nil {
		fields = append(fields, order.FieldShippingCertificateType)
	}
	if m.shipping_certificate_code != nil {
		fields = append(fields, order.FieldShippingCertificateCode)
	}
	if m.shipping_credentials_period != nil {
		fields = append(fields, order.FieldShippingCredentialsPeriod)
	}
	if m.remark != nil {
		fields = append(fields, order.FieldRemark)
	}
	if m.prefer_shipped_type != nil {
		fields = append(fields, order.FieldPreferShippedType)
	}
	if m.prefer_channel_id != nil {
		fields = append(fields, order.FieldPreferChannelID)
	}
	if m.channel_options != nil {
		fields = append(fields, order.FieldChannelOptions)
	}
	if m.channels != nil {
		fields = append(fields, order.FieldChannelID)
	}
	if m.channel_cost_id != nil {
		fields = append(fields, order.FieldChannelCostID)
	}
	if m.ship_type != nil {
		fields = append(fields, order.FieldShipType)
	}
	if m.tracking_company != nil {
		fields = append(fields, order.FieldTrackingCompany)
	}
	if m.tracking_number != nil {
		fields = append(fields, order.FieldTrackingNumber)
	}
	if m.tracking_url != nil {
		fields = append(fields, order.FieldTrackingURL)
	}
	if m.waybill_number != nil {
		fields = append(fields, order.FieldWaybillNumber)
	}
	if m.courier_order_number != nil {
		fields = append(fields, order.FieldCourierOrderNumber)
	}
	if m.nss_courier_order_number != nil {
		fields = append(fields, order.FieldNssCourierOrderNumber)
	}
	if m.nss_tracking_number != nil {
		fields = append(fields, order.FieldNssTrackingNumber)
	}
	if m.nss_tracking_url != nil {
		fields = append(fields, order.FieldNssTrackingURL)
	}
	if m.shipping_label_url != nil {
		fields = append(fields, order.FieldShippingLabelURL)
	}
	if m.shipping_label_path != nil {
		fields = append(fields, order.FieldShippingLabelPath)
	}
	if m.label_data_path != nil {
		fields = append(fields, order.FieldLabelDataPath)
	}
	if m.package_id != nil {
		fields = append(fields, order.FieldPackageID)
	}
	if m.ship_date != nil {
		fields = append(fields, order.FieldShipDate)
	}
	if m.request_shipping_at != nil {
		fields = append(fields, order.FieldRequestShippingAt)
	}
	if m.unshelf_requested_time != nil {
		fields = append(fields, order.FieldUnshelfRequestedTime)
	}
	if m.container_code != nil {
		fields = append(fields, order.FieldContainerCode)
	}
	if m.basket_number != nil {
		fields = append(fields, order.FieldBasketNumber)
	}
	if m.print_times != nil {
		fields = append(fields, order.FieldPrintTimes)
	}
	if m.sorting_tracking_number != nil {
		fields = append(fields, order.FieldSortingTrackingNumber)
	}
	if m.sorting_port != nil {
		fields = append(fields, order.FieldSortingPort)
	}
	if m.sorting_length != nil {
		fields = append(fields, order.FieldSortingLength)
	}
	if m.sorting_width != nil {
		fields = append(fields, order.FieldSortingWidth)
	}
	if m.sorting_height != nil {
		fields = append(fields, order.FieldSortingHeight)
	}
	if m.sorting_weight != nil {
		fields = append(fields, order.FieldSortingWeight)
	}
	if m.estimated_weight != nil {
		fields = append(fields, order.FieldEstimatedWeight)
	}
	if m.checkout_actual_weight != nil {
		fields = append(fields, order.FieldCheckoutActualWeight)
	}
	if m.volume_weight != nil {
		fields = append(fields, order.FieldVolumeWeight)
	}
	if m.courier_weight != nil {
		fields = append(fields, order.FieldCourierWeight)
	}
	if m.declared_value_in_usd != nil {
		fields = append(fields, order.FieldDeclaredValueInUsd)
	}
	if m.declared_value_in_eur != nil {
		fields = append(fields, order.FieldDeclaredValueInEur)
	}
	if m.total_items_price != nil {
		fields = append(fields, order.FieldTotalItemsPrice)
	}
	if m.currency != nil {
		fields = append(fields, order.FieldCurrency)
	}
	if m.delivery_cost != nil {
		fields = append(fields, order.FieldDeliveryCost)
	}
	if m.misc_fee != nil {
		fields = append(fields, order.FieldMiscFee)
	}
	if m.fuel_fee != nil {
		fields = append(fields, order.FieldFuelFee)
	}
	if m.registration_fee != nil {
		fields = append(fields, order.FieldRegistrationFee)
	}
	if m.processing_fee != nil {
		fields = append(fields, order.FieldProcessingFee)
	}
	if m.package_fee != nil {
		fields = append(fields, order.FieldPackageFee)
	}
	if m.handling_fee != nil {
		fields = append(fields, order.FieldHandlingFee)
	}
	if m.vat != nil {
		fields = append(fields, order.FieldVat)
	}
	if m.estimated_cost != nil {
		fields = append(fields, order.FieldEstimatedCost)
	}
	if m.estimated_currency != nil {
		fields = append(fields, order.FieldEstimatedCurrency)
	}
	if m.receivables_amount != nil {
		fields = append(fields, order.FieldReceivablesAmount)
	}
	if m.receivables_currency != nil {
		fields = append(fields, order.FieldReceivablesCurrency)
	}
	if m.not_accept_platform_update != nil {
		fields = append(fields, order.FieldNotAcceptPlatformUpdate)
	}
	if m.not_accept_platform_update_item != nil {
		fields = append(fields, order.FieldNotAcceptPlatformUpdateItem)
	}
	if m.jd_pushed_status != nil {
		fields = append(fields, order.FieldJdPushedStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldOrderNumber:
		return m.OrderNumber()
	case order.FieldMode:
		return m.Mode()
	case order.FieldType:
		return m.GetType()
	case order.FieldOffline:
		return m.Offline()
	case order.FieldStoreID:
		return m.StoreID()
	case order.FieldWarehouseID:
		return m.WarehouseID()
	case order.FieldCustomerCode:
		return m.CustomerCode()
	case order.FieldPrepayTariff:
		return m.PrepayTariff()
	case order.FieldIossNumber:
		return m.IossNumber()
	case order.FieldIossCountryCode:
		return m.IossCountryCode()
	case order.FieldIossNumberType:
		return m.IossNumberType()
	case order.FieldUkVatNumber:
		return m.UkVatNumber()
	case order.FieldInboundOrderNumber:
		return m.InboundOrderNumber()
	case order.FieldStatus:
		return m.Status()
	case order.FieldSqsStatus:
		return m.SqsStatus()
	case order.FieldHoldStatus:
		return m.HoldStatus()
	case order.FieldPaymentStatus:
		return m.PaymentStatus()
	case order.FieldCancelRequest:
		return m.CancelRequest()
	case order.FieldPlatform:
		return m.Platform()
	case order.FieldPlatformOrderID:
		return m.PlatformOrderID()
	case order.FieldPlatformOrderNo:
		return m.PlatformOrderNo()
	case order.FieldPlatformOrderStatusURL:
		return m.PlatformOrderStatusURL()
	case order.FieldPlatformStatus:
		return m.PlatformStatus()
	case order.FieldPaidStatus:
		return m.PaidStatus()
	case order.FieldFulfillmentPushed:
		return m.FulfillmentPushed()
	case order.FieldFulfillmentStatus:
		return m.FulfillmentStatus()
	case order.FieldPlatformCreatedAt:
		return m.PlatformCreatedAt()
	case order.FieldLocationID:
		return m.LocationID()
	case order.FieldTags:
		return m.Tags()
	case order.FieldNote:
		return m.Note()
	case order.FieldCancelReason:
		return m.CancelReason()
	case order.FieldCancelledAt:
		return m.CancelledAt()
	case order.FieldClosedAt:
		return m.ClosedAt()
	case order.FieldContactEmail:
		return m.ContactEmail()
	case order.FieldContactPhone:
		return m.ContactPhone()
	case order.FieldShippingName:
		return m.ShippingName()
	case order.FieldShippingFirstName:
		return m.ShippingFirstName()
	case order.FieldShippingLastName:
		return m.ShippingLastName()
	case order.FieldShippingCompany:
		return m.ShippingCompany()
	case order.FieldShippingCountry:
		return m.ShippingCountry()
	case order.FieldShippingCountryCode:
		return m.ShippingCountryCode()
	case order.FieldShippingProvince:
		return m.ShippingProvince()
	case order.FieldShippingProvinceCode:
		return m.ShippingProvinceCode()
	case order.FieldShippingCity:
		return m.ShippingCity()
	case order.FieldShippingAddress1:
		return m.ShippingAddress1()
	case order.FieldShippingAddress2:
		return m.ShippingAddress2()
	case order.FieldShippingZipCode:
		return m.ShippingZipCode()
	case order.FieldShippingPhone:
		return m.ShippingPhone()
	case order.FieldShippingCertificateType:
		return m.ShippingCertificateType()
	case order.FieldShippingCertificateCode:
		return m.ShippingCertificateCode()
	case order.FieldShippingCredentialsPeriod:
		return m.ShippingCredentialsPeriod()
	case order.FieldRemark:
		return m.Remark()
	case order.FieldPreferShippedType:
		return m.PreferShippedType()
	case order.FieldPreferChannelID:
		return m.PreferChannelID()
	case order.FieldChannelOptions:
		return m.ChannelOptions()
	case order.FieldChannelID:
		return m.ChannelID()
	case order.FieldChannelCostID:
		return m.ChannelCostID()
	case order.FieldShipType:
		return m.ShipType()
	case order.FieldTrackingCompany:
		return m.TrackingCompany()
	case order.FieldTrackingNumber:
		return m.TrackingNumber()
	case order.FieldTrackingURL:
		return m.TrackingURL()
	case order.FieldWaybillNumber:
		return m.WaybillNumber()
	case order.FieldCourierOrderNumber:
		return m.CourierOrderNumber()
	case order.FieldNssCourierOrderNumber:
		return m.NssCourierOrderNumber()
	case order.FieldNssTrackingNumber:
		return m.NssTrackingNumber()
	case order.FieldNssTrackingURL:
		return m.NssTrackingURL()
	case order.FieldShippingLabelURL:
		return m.ShippingLabelURL()
	case order.FieldShippingLabelPath:
		return m.ShippingLabelPath()
	case order.FieldLabelDataPath:
		return m.LabelDataPath()
	case order.FieldPackageID:
		return m.PackageID()
	case order.FieldShipDate:
		return m.ShipDate()
	case order.FieldRequestShippingAt:
		return m.RequestShippingAt()
	case order.FieldUnshelfRequestedTime:
		return m.UnshelfRequestedTime()
	case order.FieldContainerCode:
		return m.ContainerCode()
	case order.FieldBasketNumber:
		return m.BasketNumber()
	case order.FieldPrintTimes:
		return m.PrintTimes()
	case order.FieldSortingTrackingNumber:
		return m.SortingTrackingNumber()
	case order.FieldSortingPort:
		return m.SortingPort()
	case order.FieldSortingLength:
		return m.SortingLength()
	case order.FieldSortingWidth:
		return m.SortingWidth()
	case order.FieldSortingHeight:
		return m.SortingHeight()
	case order.FieldSortingWeight:
		return m.SortingWeight()
	case order.FieldEstimatedWeight:
		return m.EstimatedWeight()
	case order.FieldCheckoutActualWeight:
		return m.CheckoutActualWeight()
	case order.FieldVolumeWeight:
		return m.VolumeWeight()
	case order.FieldCourierWeight:
		return m.CourierWeight()
	case order.FieldDeclaredValueInUsd:
		return m.DeclaredValueInUsd()
	case order.FieldDeclaredValueInEur:
		return m.DeclaredValueInEur()
	case order.FieldTotalItemsPrice:
		return m.TotalItemsPrice()
	case order.FieldCurrency:
		return m.Currency()
	case order.FieldDeliveryCost:
		return m.DeliveryCost()
	case order.FieldMiscFee:
		return m.MiscFee()
	case order.FieldFuelFee:
		return m.FuelFee()
	case order.FieldRegistrationFee:
		return m.RegistrationFee()
	case order.FieldProcessingFee:
		return m.ProcessingFee()
	case order.FieldPackageFee:
		return m.PackageFee()
	case order.FieldHandlingFee:
		return m.HandlingFee()
	case order.FieldVat:
		return m.Vat()
	case order.FieldEstimatedCost:
		return m.EstimatedCost()
	case order.FieldEstimatedCurrency:
		return m.EstimatedCurrency()
	case order.FieldReceivablesAmount:
		return m.ReceivablesAmount()
	case order.FieldReceivablesCurrency:
		return m.ReceivablesCurrency()
	case order.FieldNotAcceptPlatformUpdate:
		return m.NotAcceptPlatformUpdate()
	case order.FieldNotAcceptPlatformUpdateItem:
		return m.NotAcceptPlatformUpdateItem()
	case order.FieldJdPushedStatus:
		return m.JdPushedStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case order.FieldMode:
		return m.OldMode(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldOffline:
		return m.OldOffline(ctx)
	case order.FieldStoreID:
		return m.OldStoreID(ctx)
	case order.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case order.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	case order.FieldPrepayTariff:
		return m.OldPrepayTariff(ctx)
	case order.FieldIossNumber:
		return m.OldIossNumber(ctx)
	case order.FieldIossCountryCode:
		return m.OldIossCountryCode(ctx)
	case order.FieldIossNumberType:
		return m.OldIossNumberType(ctx)
	case order.FieldUkVatNumber:
		return m.OldUkVatNumber(ctx)
	case order.FieldInboundOrderNumber:
		return m.OldInboundOrderNumber(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldSqsStatus:
		return m.OldSqsStatus(ctx)
	case order.FieldHoldStatus:
		return m.OldHoldStatus(ctx)
	case order.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case order.FieldCancelRequest:
		return m.OldCancelRequest(ctx)
	case order.FieldPlatform:
		return m.OldPlatform(ctx)
	case order.FieldPlatformOrderID:
		return m.OldPlatformOrderID(ctx)
	case order.FieldPlatformOrderNo:
		return m.OldPlatformOrderNo(ctx)
	case order.FieldPlatformOrderStatusURL:
		return m.OldPlatformOrderStatusURL(ctx)
	case order.FieldPlatformStatus:
		return m.OldPlatformStatus(ctx)
	case order.FieldPaidStatus:
		return m.OldPaidStatus(ctx)
	case order.FieldFulfillmentPushed:
		return m.OldFulfillmentPushed(ctx)
	case order.FieldFulfillmentStatus:
		return m.OldFulfillmentStatus(ctx)
	case order.FieldPlatformCreatedAt:
		return m.OldPlatformCreatedAt(ctx)
	case order.FieldLocationID:
		return m.OldLocationID(ctx)
	case order.FieldTags:
		return m.OldTags(ctx)
	case order.FieldNote:
		return m.OldNote(ctx)
	case order.FieldCancelReason:
		return m.OldCancelReason(ctx)
	case order.FieldCancelledAt:
		return m.OldCancelledAt(ctx)
	case order.FieldClosedAt:
		return m.OldClosedAt(ctx)
	case order.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case order.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case order.FieldShippingName:
		return m.OldShippingName(ctx)
	case order.FieldShippingFirstName:
		return m.OldShippingFirstName(ctx)
	case order.FieldShippingLastName:
		return m.OldShippingLastName(ctx)
	case order.FieldShippingCompany:
		return m.OldShippingCompany(ctx)
	case order.FieldShippingCountry:
		return m.OldShippingCountry(ctx)
	case order.FieldShippingCountryCode:
		return m.OldShippingCountryCode(ctx)
	case order.FieldShippingProvince:
		return m.OldShippingProvince(ctx)
	case order.FieldShippingProvinceCode:
		return m.OldShippingProvinceCode(ctx)
	case order.FieldShippingCity:
		return m.OldShippingCity(ctx)
	case order.FieldShippingAddress1:
		return m.OldShippingAddress1(ctx)
	case order.FieldShippingAddress2:
		return m.OldShippingAddress2(ctx)
	case order.FieldShippingZipCode:
		return m.OldShippingZipCode(ctx)
	case order.FieldShippingPhone:
		return m.OldShippingPhone(ctx)
	case order.FieldShippingCertificateType:
		return m.OldShippingCertificateType(ctx)
	case order.FieldShippingCertificateCode:
		return m.OldShippingCertificateCode(ctx)
	case order.FieldShippingCredentialsPeriod:
		return m.OldShippingCredentialsPeriod(ctx)
	case order.FieldRemark:
		return m.OldRemark(ctx)
	case order.FieldPreferShippedType:
		return m.OldPreferShippedType(ctx)
	case order.FieldPreferChannelID:
		return m.OldPreferChannelID(ctx)
	case order.FieldChannelOptions:
		return m.OldChannelOptions(ctx)
	case order.FieldChannelID:
		return m.OldChannelID(ctx)
	case order.FieldChannelCostID:
		return m.OldChannelCostID(ctx)
	case order.FieldShipType:
		return m.OldShipType(ctx)
	case order.FieldTrackingCompany:
		return m.OldTrackingCompany(ctx)
	case order.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case order.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case order.FieldWaybillNumber:
		return m.OldWaybillNumber(ctx)
	case order.FieldCourierOrderNumber:
		return m.OldCourierOrderNumber(ctx)
	case order.FieldNssCourierOrderNumber:
		return m.OldNssCourierOrderNumber(ctx)
	case order.FieldNssTrackingNumber:
		return m.OldNssTrackingNumber(ctx)
	case order.FieldNssTrackingURL:
		return m.OldNssTrackingURL(ctx)
	case order.FieldShippingLabelURL:
		return m.OldShippingLabelURL(ctx)
	case order.FieldShippingLabelPath:
		return m.OldShippingLabelPath(ctx)
	case order.FieldLabelDataPath:
		return m.OldLabelDataPath(ctx)
	case order.FieldPackageID:
		return m.OldPackageID(ctx)
	case order.FieldShipDate:
		return m.OldShipDate(ctx)
	case order.FieldRequestShippingAt:
		return m.OldRequestShippingAt(ctx)
	case order.FieldUnshelfRequestedTime:
		return m.OldUnshelfRequestedTime(ctx)
	case order.FieldContainerCode:
		return m.OldContainerCode(ctx)
	case order.FieldBasketNumber:
		return m.OldBasketNumber(ctx)
	case order.FieldPrintTimes:
		return m.OldPrintTimes(ctx)
	case order.FieldSortingTrackingNumber:
		return m.OldSortingTrackingNumber(ctx)
	case order.FieldSortingPort:
		return m.OldSortingPort(ctx)
	case order.FieldSortingLength:
		return m.OldSortingLength(ctx)
	case order.FieldSortingWidth:
		return m.OldSortingWidth(ctx)
	case order.FieldSortingHeight:
		return m.OldSortingHeight(ctx)
	case order.FieldSortingWeight:
		return m.OldSortingWeight(ctx)
	case order.FieldEstimatedWeight:
		return m.OldEstimatedWeight(ctx)
	case order.FieldCheckoutActualWeight:
		return m.OldCheckoutActualWeight(ctx)
	case order.FieldVolumeWeight:
		return m.OldVolumeWeight(ctx)
	case order.FieldCourierWeight:
		return m.OldCourierWeight(ctx)
	case order.FieldDeclaredValueInUsd:
		return m.OldDeclaredValueInUsd(ctx)
	case order.FieldDeclaredValueInEur:
		return m.OldDeclaredValueInEur(ctx)
	case order.FieldTotalItemsPrice:
		return m.OldTotalItemsPrice(ctx)
	case order.FieldCurrency:
		return m.OldCurrency(ctx)
	case order.FieldDeliveryCost:
		return m.OldDeliveryCost(ctx)
	case order.FieldMiscFee:
		return m.OldMiscFee(ctx)
	case order.FieldFuelFee:
		return m.OldFuelFee(ctx)
	case order.FieldRegistrationFee:
		return m.OldRegistrationFee(ctx)
	case order.FieldProcessingFee:
		return m.OldProcessingFee(ctx)
	case order.FieldPackageFee:
		return m.OldPackageFee(ctx)
	case order.FieldHandlingFee:
		return m.OldHandlingFee(ctx)
	case order.FieldVat:
		return m.OldVat(ctx)
	case order.FieldEstimatedCost:
		return m.OldEstimatedCost(ctx)
	case order.FieldEstimatedCurrency:
		return m.OldEstimatedCurrency(ctx)
	case order.FieldReceivablesAmount:
		return m.OldReceivablesAmount(ctx)
	case order.FieldReceivablesCurrency:
		return m.OldReceivablesCurrency(ctx)
	case order.FieldNotAcceptPlatformUpdate:
		return m.OldNotAcceptPlatformUpdate(ctx)
	case order.FieldNotAcceptPlatformUpdateItem:
		return m.OldNotAcceptPlatformUpdateItem(ctx)
	case order.FieldJdPushedStatus:
		return m.OldJdPushedStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case order.FieldMode:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case order.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldOffline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOffline(v)
		return nil
	case order.FieldStoreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case order.FieldWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case order.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	case order.FieldPrepayTariff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepayTariff(v)
		return nil
	case order.FieldIossNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossNumber(v)
		return nil
	case order.FieldIossCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossCountryCode(v)
		return nil
	case order.FieldIossNumberType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossNumberType(v)
		return nil
	case order.FieldUkVatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUkVatNumber(v)
		return nil
	case order.FieldInboundOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInboundOrderNumber(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldSqsStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSqsStatus(v)
		return nil
	case order.FieldHoldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoldStatus(v)
		return nil
	case order.FieldPaymentStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case order.FieldCancelRequest:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelRequest(v)
		return nil
	case order.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case order.FieldPlatformOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformOrderID(v)
		return nil
	case order.FieldPlatformOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformOrderNo(v)
		return nil
	case order.FieldPlatformOrderStatusURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformOrderStatusURL(v)
		return nil
	case order.FieldPlatformStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformStatus(v)
		return nil
	case order.FieldPaidStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidStatus(v)
		return nil
	case order.FieldFulfillmentPushed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFulfillmentPushed(v)
		return nil
	case order.FieldFulfillmentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFulfillmentStatus(v)
		return nil
	case order.FieldPlatformCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformCreatedAt(v)
		return nil
	case order.FieldLocationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case order.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case order.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case order.FieldCancelReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelReason(v)
		return nil
	case order.FieldCancelledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelledAt(v)
		return nil
	case order.FieldClosedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosedAt(v)
		return nil
	case order.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case order.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case order.FieldShippingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingName(v)
		return nil
	case order.FieldShippingFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFirstName(v)
		return nil
	case order.FieldShippingLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingLastName(v)
		return nil
	case order.FieldShippingCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCompany(v)
		return nil
	case order.FieldShippingCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCountry(v)
		return nil
	case order.FieldShippingCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCountryCode(v)
		return nil
	case order.FieldShippingProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingProvince(v)
		return nil
	case order.FieldShippingProvinceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingProvinceCode(v)
		return nil
	case order.FieldShippingCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCity(v)
		return nil
	case order.FieldShippingAddress1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingAddress1(v)
		return nil
	case order.FieldShippingAddress2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingAddress2(v)
		return nil
	case order.FieldShippingZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingZipCode(v)
		return nil
	case order.FieldShippingPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingPhone(v)
		return nil
	case order.FieldShippingCertificateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCertificateType(v)
		return nil
	case order.FieldShippingCertificateCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCertificateCode(v)
		return nil
	case order.FieldShippingCredentialsPeriod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCredentialsPeriod(v)
		return nil
	case order.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case order.FieldPreferShippedType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferShippedType(v)
		return nil
	case order.FieldPreferChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferChannelID(v)
		return nil
	case order.FieldChannelOptions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelOptions(v)
		return nil
	case order.FieldChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case order.FieldChannelCostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelCostID(v)
		return nil
	case order.FieldShipType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipType(v)
		return nil
	case order.FieldTrackingCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingCompany(v)
		return nil
	case order.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case order.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case order.FieldWaybillNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWaybillNumber(v)
		return nil
	case order.FieldCourierOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierOrderNumber(v)
		return nil
	case order.FieldNssCourierOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNssCourierOrderNumber(v)
		return nil
	case order.FieldNssTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNssTrackingNumber(v)
		return nil
	case order.FieldNssTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNssTrackingURL(v)
		return nil
	case order.FieldShippingLabelURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingLabelURL(v)
		return nil
	case order.FieldShippingLabelPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingLabelPath(v)
		return nil
	case order.FieldLabelDataPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelDataPath(v)
		return nil
	case order.FieldPackageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case order.FieldShipDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipDate(v)
		return nil
	case order.FieldRequestShippingAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestShippingAt(v)
		return nil
	case order.FieldUnshelfRequestedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnshelfRequestedTime(v)
		return nil
	case order.FieldContainerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerCode(v)
		return nil
	case order.FieldBasketNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasketNumber(v)
		return nil
	case order.FieldPrintTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintTimes(v)
		return nil
	case order.FieldSortingTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingTrackingNumber(v)
		return nil
	case order.FieldSortingPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingPort(v)
		return nil
	case order.FieldSortingLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingLength(v)
		return nil
	case order.FieldSortingWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingWidth(v)
		return nil
	case order.FieldSortingHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingHeight(v)
		return nil
	case order.FieldSortingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortingWeight(v)
		return nil
	case order.FieldEstimatedWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedWeight(v)
		return nil
	case order.FieldCheckoutActualWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckoutActualWeight(v)
		return nil
	case order.FieldVolumeWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeWeight(v)
		return nil
	case order.FieldCourierWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierWeight(v)
		return nil
	case order.FieldDeclaredValueInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredValueInUsd(v)
		return nil
	case order.FieldDeclaredValueInEur:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredValueInEur(v)
		return nil
	case order.FieldTotalItemsPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalItemsPrice(v)
		return nil
	case order.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case order.FieldDeliveryCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryCost(v)
		return nil
	case order.FieldMiscFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiscFee(v)
		return nil
	case order.FieldFuelFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelFee(v)
		return nil
	case order.FieldRegistrationFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationFee(v)
		return nil
	case order.FieldProcessingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessingFee(v)
		return nil
	case order.FieldPackageFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageFee(v)
		return nil
	case order.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlingFee(v)
		return nil
	case order.FieldVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVat(v)
		return nil
	case order.FieldEstimatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCost(v)
		return nil
	case order.FieldEstimatedCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCurrency(v)
		return nil
	case order.FieldReceivablesAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivablesAmount(v)
		return nil
	case order.FieldReceivablesCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivablesCurrency(v)
		return nil
	case order.FieldNotAcceptPlatformUpdate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotAcceptPlatformUpdate(v)
		return nil
	case order.FieldNotAcceptPlatformUpdateItem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotAcceptPlatformUpdateItem(v)
		return nil
	case order.FieldJdPushedStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJdPushedStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addmode != nil {
		fields = append(fields, order.FieldMode)
	}
	if m.add_type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.addioss_number_type != nil {
		fields = append(fields, order.FieldIossNumberType)
	}
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addpayment_status != nil {
		fields = append(fields, order.FieldPaymentStatus)
	}
	if m.addcancel_request != nil {
		fields = append(fields, order.FieldCancelRequest)
	}
	if m.addprefer_shipped_type != nil {
		fields = append(fields, order.FieldPreferShippedType)
	}
	if m.addprefer_channel_id != nil {
		fields = append(fields, order.FieldPreferChannelID)
	}
	if m.addchannel_cost_id != nil {
		fields = append(fields, order.FieldChannelCostID)
	}
	if m.addship_type != nil {
		fields = append(fields, order.FieldShipType)
	}
	if m.addprint_times != nil {
		fields = append(fields, order.FieldPrintTimes)
	}
	if m.addsorting_port != nil {
		fields = append(fields, order.FieldSortingPort)
	}
	if m.addsorting_length != nil {
		fields = append(fields, order.FieldSortingLength)
	}
	if m.addsorting_width != nil {
		fields = append(fields, order.FieldSortingWidth)
	}
	if m.addsorting_height != nil {
		fields = append(fields, order.FieldSortingHeight)
	}
	if m.addsorting_weight != nil {
		fields = append(fields, order.FieldSortingWeight)
	}
	if m.addestimated_weight != nil {
		fields = append(fields, order.FieldEstimatedWeight)
	}
	if m.addcheckout_actual_weight != nil {
		fields = append(fields, order.FieldCheckoutActualWeight)
	}
	if m.addvolume_weight != nil {
		fields = append(fields, order.FieldVolumeWeight)
	}
	if m.addcourier_weight != nil {
		fields = append(fields, order.FieldCourierWeight)
	}
	if m.adddeclared_value_in_usd != nil {
		fields = append(fields, order.FieldDeclaredValueInUsd)
	}
	if m.adddeclared_value_in_eur != nil {
		fields = append(fields, order.FieldDeclaredValueInEur)
	}
	if m.addtotal_items_price != nil {
		fields = append(fields, order.FieldTotalItemsPrice)
	}
	if m.adddelivery_cost != nil {
		fields = append(fields, order.FieldDeliveryCost)
	}
	if m.addmisc_fee != nil {
		fields = append(fields, order.FieldMiscFee)
	}
	if m.addfuel_fee != nil {
		fields = append(fields, order.FieldFuelFee)
	}
	if m.addregistration_fee != nil {
		fields = append(fields, order.FieldRegistrationFee)
	}
	if m.addprocessing_fee != nil {
		fields = append(fields, order.FieldProcessingFee)
	}
	if m.addpackage_fee != nil {
		fields = append(fields, order.FieldPackageFee)
	}
	if m.addhandling_fee != nil {
		fields = append(fields, order.FieldHandlingFee)
	}
	if m.addvat != nil {
		fields = append(fields, order.FieldVat)
	}
	if m.addestimated_cost != nil {
		fields = append(fields, order.FieldEstimatedCost)
	}
	if m.addreceivables_amount != nil {
		fields = append(fields, order.FieldReceivablesAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldMode:
		return m.AddedMode()
	case order.FieldType:
		return m.AddedType()
	case order.FieldIossNumberType:
		return m.AddedIossNumberType()
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldPaymentStatus:
		return m.AddedPaymentStatus()
	case order.FieldCancelRequest:
		return m.AddedCancelRequest()
	case order.FieldPreferShippedType:
		return m.AddedPreferShippedType()
	case order.FieldPreferChannelID:
		return m.AddedPreferChannelID()
	case order.FieldChannelCostID:
		return m.AddedChannelCostID()
	case order.FieldShipType:
		return m.AddedShipType()
	case order.FieldPrintTimes:
		return m.AddedPrintTimes()
	case order.FieldSortingPort:
		return m.AddedSortingPort()
	case order.FieldSortingLength:
		return m.AddedSortingLength()
	case order.FieldSortingWidth:
		return m.AddedSortingWidth()
	case order.FieldSortingHeight:
		return m.AddedSortingHeight()
	case order.FieldSortingWeight:
		return m.AddedSortingWeight()
	case order.FieldEstimatedWeight:
		return m.AddedEstimatedWeight()
	case order.FieldCheckoutActualWeight:
		return m.AddedCheckoutActualWeight()
	case order.FieldVolumeWeight:
		return m.AddedVolumeWeight()
	case order.FieldCourierWeight:
		return m.AddedCourierWeight()
	case order.FieldDeclaredValueInUsd:
		return m.AddedDeclaredValueInUsd()
	case order.FieldDeclaredValueInEur:
		return m.AddedDeclaredValueInEur()
	case order.FieldTotalItemsPrice:
		return m.AddedTotalItemsPrice()
	case order.FieldDeliveryCost:
		return m.AddedDeliveryCost()
	case order.FieldMiscFee:
		return m.AddedMiscFee()
	case order.FieldFuelFee:
		return m.AddedFuelFee()
	case order.FieldRegistrationFee:
		return m.AddedRegistrationFee()
	case order.FieldProcessingFee:
		return m.AddedProcessingFee()
	case order.FieldPackageFee:
		return m.AddedPackageFee()
	case order.FieldHandlingFee:
		return m.AddedHandlingFee()
	case order.FieldVat:
		return m.AddedVat()
	case order.FieldEstimatedCost:
		return m.AddedEstimatedCost()
	case order.FieldReceivablesAmount:
		return m.AddedReceivablesAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldMode:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMode(v)
		return nil
	case order.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case order.FieldIossNumberType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIossNumberType(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldPaymentStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentStatus(v)
		return nil
	case order.FieldCancelRequest:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelRequest(v)
		return nil
	case order.FieldPreferShippedType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreferShippedType(v)
		return nil
	case order.FieldPreferChannelID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreferChannelID(v)
		return nil
	case order.FieldChannelCostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelCostID(v)
		return nil
	case order.FieldShipType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipType(v)
		return nil
	case order.FieldPrintTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrintTimes(v)
		return nil
	case order.FieldSortingPort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortingPort(v)
		return nil
	case order.FieldSortingLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortingLength(v)
		return nil
	case order.FieldSortingWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortingWidth(v)
		return nil
	case order.FieldSortingHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortingHeight(v)
		return nil
	case order.FieldSortingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortingWeight(v)
		return nil
	case order.FieldEstimatedWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedWeight(v)
		return nil
	case order.FieldCheckoutActualWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckoutActualWeight(v)
		return nil
	case order.FieldVolumeWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolumeWeight(v)
		return nil
	case order.FieldCourierWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCourierWeight(v)
		return nil
	case order.FieldDeclaredValueInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclaredValueInUsd(v)
		return nil
	case order.FieldDeclaredValueInEur:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclaredValueInEur(v)
		return nil
	case order.FieldTotalItemsPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalItemsPrice(v)
		return nil
	case order.FieldDeliveryCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryCost(v)
		return nil
	case order.FieldMiscFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMiscFee(v)
		return nil
	case order.FieldFuelFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFuelFee(v)
		return nil
	case order.FieldRegistrationFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegistrationFee(v)
		return nil
	case order.FieldProcessingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessingFee(v)
		return nil
	case order.FieldPackageFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPackageFee(v)
		return nil
	case order.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandlingFee(v)
		return nil
	case order.FieldVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVat(v)
		return nil
	case order.FieldEstimatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedCost(v)
		return nil
	case order.FieldReceivablesAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivablesAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldDeletedAt) {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.FieldCleared(order.FieldStoreID) {
		fields = append(fields, order.FieldStoreID)
	}
	if m.FieldCleared(order.FieldWarehouseID) {
		fields = append(fields, order.FieldWarehouseID)
	}
	if m.FieldCleared(order.FieldSqsStatus) {
		fields = append(fields, order.FieldSqsStatus)
	}
	if m.FieldCleared(order.FieldHoldStatus) {
		fields = append(fields, order.FieldHoldStatus)
	}
	if m.FieldCleared(order.FieldPaymentStatus) {
		fields = append(fields, order.FieldPaymentStatus)
	}
	if m.FieldCleared(order.FieldCancelRequest) {
		fields = append(fields, order.FieldCancelRequest)
	}
	if m.FieldCleared(order.FieldPlatformOrderID) {
		fields = append(fields, order.FieldPlatformOrderID)
	}
	if m.FieldCleared(order.FieldPlatformOrderNo) {
		fields = append(fields, order.FieldPlatformOrderNo)
	}
	if m.FieldCleared(order.FieldPlatformOrderStatusURL) {
		fields = append(fields, order.FieldPlatformOrderStatusURL)
	}
	if m.FieldCleared(order.FieldPlatformStatus) {
		fields = append(fields, order.FieldPlatformStatus)
	}
	if m.FieldCleared(order.FieldPaidStatus) {
		fields = append(fields, order.FieldPaidStatus)
	}
	if m.FieldCleared(order.FieldFulfillmentPushed) {
		fields = append(fields, order.FieldFulfillmentPushed)
	}
	if m.FieldCleared(order.FieldFulfillmentStatus) {
		fields = append(fields, order.FieldFulfillmentStatus)
	}
	if m.FieldCleared(order.FieldPlatformCreatedAt) {
		fields = append(fields, order.FieldPlatformCreatedAt)
	}
	if m.FieldCleared(order.FieldLocationID) {
		fields = append(fields, order.FieldLocationID)
	}
	if m.FieldCleared(order.FieldTags) {
		fields = append(fields, order.FieldTags)
	}
	if m.FieldCleared(order.FieldNote) {
		fields = append(fields, order.FieldNote)
	}
	if m.FieldCleared(order.FieldCancelReason) {
		fields = append(fields, order.FieldCancelReason)
	}
	if m.FieldCleared(order.FieldCancelledAt) {
		fields = append(fields, order.FieldCancelledAt)
	}
	if m.FieldCleared(order.FieldClosedAt) {
		fields = append(fields, order.FieldClosedAt)
	}
	if m.FieldCleared(order.FieldShippingCertificateType) {
		fields = append(fields, order.FieldShippingCertificateType)
	}
	if m.FieldCleared(order.FieldShippingCertificateCode) {
		fields = append(fields, order.FieldShippingCertificateCode)
	}
	if m.FieldCleared(order.FieldShippingCredentialsPeriod) {
		fields = append(fields, order.FieldShippingCredentialsPeriod)
	}
	if m.FieldCleared(order.FieldRemark) {
		fields = append(fields, order.FieldRemark)
	}
	if m.FieldCleared(order.FieldPreferShippedType) {
		fields = append(fields, order.FieldPreferShippedType)
	}
	if m.FieldCleared(order.FieldPreferChannelID) {
		fields = append(fields, order.FieldPreferChannelID)
	}
	if m.FieldCleared(order.FieldChannelOptions) {
		fields = append(fields, order.FieldChannelOptions)
	}
	if m.FieldCleared(order.FieldChannelID) {
		fields = append(fields, order.FieldChannelID)
	}
	if m.FieldCleared(order.FieldChannelCostID) {
		fields = append(fields, order.FieldChannelCostID)
	}
	if m.FieldCleared(order.FieldShipType) {
		fields = append(fields, order.FieldShipType)
	}
	if m.FieldCleared(order.FieldTrackingCompany) {
		fields = append(fields, order.FieldTrackingCompany)
	}
	if m.FieldCleared(order.FieldTrackingNumber) {
		fields = append(fields, order.FieldTrackingNumber)
	}
	if m.FieldCleared(order.FieldTrackingURL) {
		fields = append(fields, order.FieldTrackingURL)
	}
	if m.FieldCleared(order.FieldWaybillNumber) {
		fields = append(fields, order.FieldWaybillNumber)
	}
	if m.FieldCleared(order.FieldCourierOrderNumber) {
		fields = append(fields, order.FieldCourierOrderNumber)
	}
	if m.FieldCleared(order.FieldNssCourierOrderNumber) {
		fields = append(fields, order.FieldNssCourierOrderNumber)
	}
	if m.FieldCleared(order.FieldNssTrackingNumber) {
		fields = append(fields, order.FieldNssTrackingNumber)
	}
	if m.FieldCleared(order.FieldNssTrackingURL) {
		fields = append(fields, order.FieldNssTrackingURL)
	}
	if m.FieldCleared(order.FieldShippingLabelURL) {
		fields = append(fields, order.FieldShippingLabelURL)
	}
	if m.FieldCleared(order.FieldShippingLabelPath) {
		fields = append(fields, order.FieldShippingLabelPath)
	}
	if m.FieldCleared(order.FieldLabelDataPath) {
		fields = append(fields, order.FieldLabelDataPath)
	}
	if m.FieldCleared(order.FieldPackageID) {
		fields = append(fields, order.FieldPackageID)
	}
	if m.FieldCleared(order.FieldShipDate) {
		fields = append(fields, order.FieldShipDate)
	}
	if m.FieldCleared(order.FieldRequestShippingAt) {
		fields = append(fields, order.FieldRequestShippingAt)
	}
	if m.FieldCleared(order.FieldUnshelfRequestedTime) {
		fields = append(fields, order.FieldUnshelfRequestedTime)
	}
	if m.FieldCleared(order.FieldContainerCode) {
		fields = append(fields, order.FieldContainerCode)
	}
	if m.FieldCleared(order.FieldBasketNumber) {
		fields = append(fields, order.FieldBasketNumber)
	}
	if m.FieldCleared(order.FieldPrintTimes) {
		fields = append(fields, order.FieldPrintTimes)
	}
	if m.FieldCleared(order.FieldSortingTrackingNumber) {
		fields = append(fields, order.FieldSortingTrackingNumber)
	}
	if m.FieldCleared(order.FieldSortingPort) {
		fields = append(fields, order.FieldSortingPort)
	}
	if m.FieldCleared(order.FieldSortingLength) {
		fields = append(fields, order.FieldSortingLength)
	}
	if m.FieldCleared(order.FieldSortingWidth) {
		fields = append(fields, order.FieldSortingWidth)
	}
	if m.FieldCleared(order.FieldSortingHeight) {
		fields = append(fields, order.FieldSortingHeight)
	}
	if m.FieldCleared(order.FieldSortingWeight) {
		fields = append(fields, order.FieldSortingWeight)
	}
	if m.FieldCleared(order.FieldEstimatedWeight) {
		fields = append(fields, order.FieldEstimatedWeight)
	}
	if m.FieldCleared(order.FieldCheckoutActualWeight) {
		fields = append(fields, order.FieldCheckoutActualWeight)
	}
	if m.FieldCleared(order.FieldVolumeWeight) {
		fields = append(fields, order.FieldVolumeWeight)
	}
	if m.FieldCleared(order.FieldCourierWeight) {
		fields = append(fields, order.FieldCourierWeight)
	}
	if m.FieldCleared(order.FieldDeclaredValueInUsd) {
		fields = append(fields, order.FieldDeclaredValueInUsd)
	}
	if m.FieldCleared(order.FieldDeclaredValueInEur) {
		fields = append(fields, order.FieldDeclaredValueInEur)
	}
	if m.FieldCleared(order.FieldTotalItemsPrice) {
		fields = append(fields, order.FieldTotalItemsPrice)
	}
	if m.FieldCleared(order.FieldCurrency) {
		fields = append(fields, order.FieldCurrency)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case order.FieldStoreID:
		m.ClearStoreID()
		return nil
	case order.FieldWarehouseID:
		m.ClearWarehouseID()
		return nil
	case order.FieldSqsStatus:
		m.ClearSqsStatus()
		return nil
	case order.FieldHoldStatus:
		m.ClearHoldStatus()
		return nil
	case order.FieldPaymentStatus:
		m.ClearPaymentStatus()
		return nil
	case order.FieldCancelRequest:
		m.ClearCancelRequest()
		return nil
	case order.FieldPlatformOrderID:
		m.ClearPlatformOrderID()
		return nil
	case order.FieldPlatformOrderNo:
		m.ClearPlatformOrderNo()
		return nil
	case order.FieldPlatformOrderStatusURL:
		m.ClearPlatformOrderStatusURL()
		return nil
	case order.FieldPlatformStatus:
		m.ClearPlatformStatus()
		return nil
	case order.FieldPaidStatus:
		m.ClearPaidStatus()
		return nil
	case order.FieldFulfillmentPushed:
		m.ClearFulfillmentPushed()
		return nil
	case order.FieldFulfillmentStatus:
		m.ClearFulfillmentStatus()
		return nil
	case order.FieldPlatformCreatedAt:
		m.ClearPlatformCreatedAt()
		return nil
	case order.FieldLocationID:
		m.ClearLocationID()
		return nil
	case order.FieldTags:
		m.ClearTags()
		return nil
	case order.FieldNote:
		m.ClearNote()
		return nil
	case order.FieldCancelReason:
		m.ClearCancelReason()
		return nil
	case order.FieldCancelledAt:
		m.ClearCancelledAt()
		return nil
	case order.FieldClosedAt:
		m.ClearClosedAt()
		return nil
	case order.FieldShippingCertificateType:
		m.ClearShippingCertificateType()
		return nil
	case order.FieldShippingCertificateCode:
		m.ClearShippingCertificateCode()
		return nil
	case order.FieldShippingCredentialsPeriod:
		m.ClearShippingCredentialsPeriod()
		return nil
	case order.FieldRemark:
		m.ClearRemark()
		return nil
	case order.FieldPreferShippedType:
		m.ClearPreferShippedType()
		return nil
	case order.FieldPreferChannelID:
		m.ClearPreferChannelID()
		return nil
	case order.FieldChannelOptions:
		m.ClearChannelOptions()
		return nil
	case order.FieldChannelID:
		m.ClearChannelID()
		return nil
	case order.FieldChannelCostID:
		m.ClearChannelCostID()
		return nil
	case order.FieldShipType:
		m.ClearShipType()
		return nil
	case order.FieldTrackingCompany:
		m.ClearTrackingCompany()
		return nil
	case order.FieldTrackingNumber:
		m.ClearTrackingNumber()
		return nil
	case order.FieldTrackingURL:
		m.ClearTrackingURL()
		return nil
	case order.FieldWaybillNumber:
		m.ClearWaybillNumber()
		return nil
	case order.FieldCourierOrderNumber:
		m.ClearCourierOrderNumber()
		return nil
	case order.FieldNssCourierOrderNumber:
		m.ClearNssCourierOrderNumber()
		return nil
	case order.FieldNssTrackingNumber:
		m.ClearNssTrackingNumber()
		return nil
	case order.FieldNssTrackingURL:
		m.ClearNssTrackingURL()
		return nil
	case order.FieldShippingLabelURL:
		m.ClearShippingLabelURL()
		return nil
	case order.FieldShippingLabelPath:
		m.ClearShippingLabelPath()
		return nil
	case order.FieldLabelDataPath:
		m.ClearLabelDataPath()
		return nil
	case order.FieldPackageID:
		m.ClearPackageID()
		return nil
	case order.FieldShipDate:
		m.ClearShipDate()
		return nil
	case order.FieldRequestShippingAt:
		m.ClearRequestShippingAt()
		return nil
	case order.FieldUnshelfRequestedTime:
		m.ClearUnshelfRequestedTime()
		return nil
	case order.FieldContainerCode:
		m.ClearContainerCode()
		return nil
	case order.FieldBasketNumber:
		m.ClearBasketNumber()
		return nil
	case order.FieldPrintTimes:
		m.ClearPrintTimes()
		return nil
	case order.FieldSortingTrackingNumber:
		m.ClearSortingTrackingNumber()
		return nil
	case order.FieldSortingPort:
		m.ClearSortingPort()
		return nil
	case order.FieldSortingLength:
		m.ClearSortingLength()
		return nil
	case order.FieldSortingWidth:
		m.ClearSortingWidth()
		return nil
	case order.FieldSortingHeight:
		m.ClearSortingHeight()
		return nil
	case order.FieldSortingWeight:
		m.ClearSortingWeight()
		return nil
	case order.FieldEstimatedWeight:
		m.ClearEstimatedWeight()
		return nil
	case order.FieldCheckoutActualWeight:
		m.ClearCheckoutActualWeight()
		return nil
	case order.FieldVolumeWeight:
		m.ClearVolumeWeight()
		return nil
	case order.FieldCourierWeight:
		m.ClearCourierWeight()
		return nil
	case order.FieldDeclaredValueInUsd:
		m.ClearDeclaredValueInUsd()
		return nil
	case order.FieldDeclaredValueInEur:
		m.ClearDeclaredValueInEur()
		return nil
	case order.FieldTotalItemsPrice:
		m.ClearTotalItemsPrice()
		return nil
	case order.FieldCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case order.FieldMode:
		m.ResetMode()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldOffline:
		m.ResetOffline()
		return nil
	case order.FieldStoreID:
		m.ResetStoreID()
		return nil
	case order.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case order.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	case order.FieldPrepayTariff:
		m.ResetPrepayTariff()
		return nil
	case order.FieldIossNumber:
		m.ResetIossNumber()
		return nil
	case order.FieldIossCountryCode:
		m.ResetIossCountryCode()
		return nil
	case order.FieldIossNumberType:
		m.ResetIossNumberType()
		return nil
	case order.FieldUkVatNumber:
		m.ResetUkVatNumber()
		return nil
	case order.FieldInboundOrderNumber:
		m.ResetInboundOrderNumber()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldSqsStatus:
		m.ResetSqsStatus()
		return nil
	case order.FieldHoldStatus:
		m.ResetHoldStatus()
		return nil
	case order.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case order.FieldCancelRequest:
		m.ResetCancelRequest()
		return nil
	case order.FieldPlatform:
		m.ResetPlatform()
		return nil
	case order.FieldPlatformOrderID:
		m.ResetPlatformOrderID()
		return nil
	case order.FieldPlatformOrderNo:
		m.ResetPlatformOrderNo()
		return nil
	case order.FieldPlatformOrderStatusURL:
		m.ResetPlatformOrderStatusURL()
		return nil
	case order.FieldPlatformStatus:
		m.ResetPlatformStatus()
		return nil
	case order.FieldPaidStatus:
		m.ResetPaidStatus()
		return nil
	case order.FieldFulfillmentPushed:
		m.ResetFulfillmentPushed()
		return nil
	case order.FieldFulfillmentStatus:
		m.ResetFulfillmentStatus()
		return nil
	case order.FieldPlatformCreatedAt:
		m.ResetPlatformCreatedAt()
		return nil
	case order.FieldLocationID:
		m.ResetLocationID()
		return nil
	case order.FieldTags:
		m.ResetTags()
		return nil
	case order.FieldNote:
		m.ResetNote()
		return nil
	case order.FieldCancelReason:
		m.ResetCancelReason()
		return nil
	case order.FieldCancelledAt:
		m.ResetCancelledAt()
		return nil
	case order.FieldClosedAt:
		m.ResetClosedAt()
		return nil
	case order.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case order.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case order.FieldShippingName:
		m.ResetShippingName()
		return nil
	case order.FieldShippingFirstName:
		m.ResetShippingFirstName()
		return nil
	case order.FieldShippingLastName:
		m.ResetShippingLastName()
		return nil
	case order.FieldShippingCompany:
		m.ResetShippingCompany()
		return nil
	case order.FieldShippingCountry:
		m.ResetShippingCountry()
		return nil
	case order.FieldShippingCountryCode:
		m.ResetShippingCountryCode()
		return nil
	case order.FieldShippingProvince:
		m.ResetShippingProvince()
		return nil
	case order.FieldShippingProvinceCode:
		m.ResetShippingProvinceCode()
		return nil
	case order.FieldShippingCity:
		m.ResetShippingCity()
		return nil
	case order.FieldShippingAddress1:
		m.ResetShippingAddress1()
		return nil
	case order.FieldShippingAddress2:
		m.ResetShippingAddress2()
		return nil
	case order.FieldShippingZipCode:
		m.ResetShippingZipCode()
		return nil
	case order.FieldShippingPhone:
		m.ResetShippingPhone()
		return nil
	case order.FieldShippingCertificateType:
		m.ResetShippingCertificateType()
		return nil
	case order.FieldShippingCertificateCode:
		m.ResetShippingCertificateCode()
		return nil
	case order.FieldShippingCredentialsPeriod:
		m.ResetShippingCredentialsPeriod()
		return nil
	case order.FieldRemark:
		m.ResetRemark()
		return nil
	case order.FieldPreferShippedType:
		m.ResetPreferShippedType()
		return nil
	case order.FieldPreferChannelID:
		m.ResetPreferChannelID()
		return nil
	case order.FieldChannelOptions:
		m.ResetChannelOptions()
		return nil
	case order.FieldChannelID:
		m.ResetChannelID()
		return nil
	case order.FieldChannelCostID:
		m.ResetChannelCostID()
		return nil
	case order.FieldShipType:
		m.ResetShipType()
		return nil
	case order.FieldTrackingCompany:
		m.ResetTrackingCompany()
		return nil
	case order.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case order.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case order.FieldWaybillNumber:
		m.ResetWaybillNumber()
		return nil
	case order.FieldCourierOrderNumber:
		m.ResetCourierOrderNumber()
		return nil
	case order.FieldNssCourierOrderNumber:
		m.ResetNssCourierOrderNumber()
		return nil
	case order.FieldNssTrackingNumber:
		m.ResetNssTrackingNumber()
		return nil
	case order.FieldNssTrackingURL:
		m.ResetNssTrackingURL()
		return nil
	case order.FieldShippingLabelURL:
		m.ResetShippingLabelURL()
		return nil
	case order.FieldShippingLabelPath:
		m.ResetShippingLabelPath()
		return nil
	case order.FieldLabelDataPath:
		m.ResetLabelDataPath()
		return nil
	case order.FieldPackageID:
		m.ResetPackageID()
		return nil
	case order.FieldShipDate:
		m.ResetShipDate()
		return nil
	case order.FieldRequestShippingAt:
		m.ResetRequestShippingAt()
		return nil
	case order.FieldUnshelfRequestedTime:
		m.ResetUnshelfRequestedTime()
		return nil
	case order.FieldContainerCode:
		m.ResetContainerCode()
		return nil
	case order.FieldBasketNumber:
		m.ResetBasketNumber()
		return nil
	case order.FieldPrintTimes:
		m.ResetPrintTimes()
		return nil
	case order.FieldSortingTrackingNumber:
		m.ResetSortingTrackingNumber()
		return nil
	case order.FieldSortingPort:
		m.ResetSortingPort()
		return nil
	case order.FieldSortingLength:
		m.ResetSortingLength()
		return nil
	case order.FieldSortingWidth:
		m.ResetSortingWidth()
		return nil
	case order.FieldSortingHeight:
		m.ResetSortingHeight()
		return nil
	case order.FieldSortingWeight:
		m.ResetSortingWeight()
		return nil
	case order.FieldEstimatedWeight:
		m.ResetEstimatedWeight()
		return nil
	case order.FieldCheckoutActualWeight:
		m.ResetCheckoutActualWeight()
		return nil
	case order.FieldVolumeWeight:
		m.ResetVolumeWeight()
		return nil
	case order.FieldCourierWeight:
		m.ResetCourierWeight()
		return nil
	case order.FieldDeclaredValueInUsd:
		m.ResetDeclaredValueInUsd()
		return nil
	case order.FieldDeclaredValueInEur:
		m.ResetDeclaredValueInEur()
		return nil
	case order.FieldTotalItemsPrice:
		m.ResetTotalItemsPrice()
		return nil
	case order.FieldCurrency:
		m.ResetCurrency()
		return nil
	case order.FieldDeliveryCost:
		m.ResetDeliveryCost()
		return nil
	case order.FieldMiscFee:
		m.ResetMiscFee()
		return nil
	case order.FieldFuelFee:
		m.ResetFuelFee()
		return nil
	case order.FieldRegistrationFee:
		m.ResetRegistrationFee()
		return nil
	case order.FieldProcessingFee:
		m.ResetProcessingFee()
		return nil
	case order.FieldPackageFee:
		m.ResetPackageFee()
		return nil
	case order.FieldHandlingFee:
		m.ResetHandlingFee()
		return nil
	case order.FieldVat:
		m.ResetVat()
		return nil
	case order.FieldEstimatedCost:
		m.ResetEstimatedCost()
		return nil
	case order.FieldEstimatedCurrency:
		m.ResetEstimatedCurrency()
		return nil
	case order.FieldReceivablesAmount:
		m.ResetReceivablesAmount()
		return nil
	case order.FieldReceivablesCurrency:
		m.ResetReceivablesCurrency()
		return nil
	case order.FieldNotAcceptPlatformUpdate:
		m.ResetNotAcceptPlatformUpdate()
		return nil
	case order.FieldNotAcceptPlatformUpdateItem:
		m.ResetNotAcceptPlatformUpdateItem()
		return nil
	case order.FieldJdPushedStatus:
		m.ResetJdPushedStatus()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, order.EdgeTenant)
	}
	if m.order_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.order_hold_reasons != nil {
		edges = append(edges, order.EdgeOrderHoldReasons)
	}
	if m.order_taxations != nil {
		edges = append(edges, order.EdgeOrderTaxations)
	}
	if m.stores != nil {
		edges = append(edges, order.EdgeStores)
	}
	if m.warehouses != nil {
		edges = append(edges, order.EdgeWarehouses)
	}
	if m.channels != nil {
		edges = append(edges, order.EdgeChannels)
	}
	if m.track_mappings != nil {
		edges = append(edges, order.EdgeTrackMappings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderHoldReasons:
		ids := make([]ent.Value, 0, len(m.order_hold_reasons))
		for id := range m.order_hold_reasons {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderTaxations:
		ids := make([]ent.Value, 0, len(m.order_taxations))
		for id := range m.order_taxations {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeStores:
		if id := m.stores; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeWarehouses:
		if id := m.warehouses; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeChannels:
		if id := m.channels; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeTrackMappings:
		ids := make([]ent.Value, 0, len(m.track_mappings))
		for id := range m.track_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedorder_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.removedorder_hold_reasons != nil {
		edges = append(edges, order.EdgeOrderHoldReasons)
	}
	if m.removedorder_taxations != nil {
		edges = append(edges, order.EdgeOrderTaxations)
	}
	if m.removedtrack_mappings != nil {
		edges = append(edges, order.EdgeTrackMappings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderHoldReasons:
		ids := make([]ent.Value, 0, len(m.removedorder_hold_reasons))
		for id := range m.removedorder_hold_reasons {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderTaxations:
		ids := make([]ent.Value, 0, len(m.removedorder_taxations))
		for id := range m.removedorder_taxations {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeTrackMappings:
		ids := make([]ent.Value, 0, len(m.removedtrack_mappings))
		for id := range m.removedtrack_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, order.EdgeTenant)
	}
	if m.clearedorder_items {
		edges = append(edges, order.EdgeOrderItems)
	}
	if m.clearedorder_hold_reasons {
		edges = append(edges, order.EdgeOrderHoldReasons)
	}
	if m.clearedorder_taxations {
		edges = append(edges, order.EdgeOrderTaxations)
	}
	if m.clearedstores {
		edges = append(edges, order.EdgeStores)
	}
	if m.clearedwarehouses {
		edges = append(edges, order.EdgeWarehouses)
	}
	if m.clearedchannels {
		edges = append(edges, order.EdgeChannels)
	}
	if m.clearedtrack_mappings {
		edges = append(edges, order.EdgeTrackMappings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeTenant:
		return m.clearedtenant
	case order.EdgeOrderItems:
		return m.clearedorder_items
	case order.EdgeOrderHoldReasons:
		return m.clearedorder_hold_reasons
	case order.EdgeOrderTaxations:
		return m.clearedorder_taxations
	case order.EdgeStores:
		return m.clearedstores
	case order.EdgeWarehouses:
		return m.clearedwarehouses
	case order.EdgeChannels:
		return m.clearedchannels
	case order.EdgeTrackMappings:
		return m.clearedtrack_mappings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeTenant:
		m.ClearTenant()
		return nil
	case order.EdgeStores:
		m.ClearStores()
		return nil
	case order.EdgeWarehouses:
		m.ClearWarehouses()
		return nil
	case order.EdgeChannels:
		m.ClearChannels()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeTenant:
		m.ResetTenant()
		return nil
	case order.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case order.EdgeOrderHoldReasons:
		m.ResetOrderHoldReasons()
		return nil
	case order.EdgeOrderTaxations:
		m.ResetOrderTaxations()
		return nil
	case order.EdgeStores:
		m.ResetStores()
		return nil
	case order.EdgeWarehouses:
		m.ResetWarehouses()
		return nil
	case order.EdgeChannels:
		m.ResetChannels()
		return nil
	case order.EdgeTrackMappings:
		m.ResetTrackMappings()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderHoldReasonMutation represents an operation that mutates the OrderHoldReason nodes in the graph.
type OrderHoldReasonMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	product_id    *int64
	addproduct_id *int64
	_type         *string
	code          *int32
	addcode       *int32
	reason        *string
	en_reason     *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	orders        *int64
	clearedorders bool
	done          bool
	oldValue      func(context.Context) (*OrderHoldReason, error)
	predicates    []predicate.OrderHoldReason
}

var _ ent.Mutation = (*OrderHoldReasonMutation)(nil)

// orderholdreasonOption allows management of the mutation configuration using functional options.
type orderholdreasonOption func(*OrderHoldReasonMutation)

// newOrderHoldReasonMutation creates new mutation for the OrderHoldReason entity.
func newOrderHoldReasonMutation(c config, op Op, opts ...orderholdreasonOption) *OrderHoldReasonMutation {
	m := &OrderHoldReasonMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderHoldReason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderHoldReasonID sets the ID field of the mutation.
func withOrderHoldReasonID(id int64) orderholdreasonOption {
	return func(m *OrderHoldReasonMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderHoldReason
		)
		m.oldValue = func(ctx context.Context) (*OrderHoldReason, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderHoldReason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderHoldReason sets the old OrderHoldReason of the mutation.
func withOrderHoldReason(node *OrderHoldReason) orderholdreasonOption {
	return func(m *OrderHoldReasonMutation) {
		m.oldValue = func(context.Context) (*OrderHoldReason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderHoldReasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderHoldReasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderHoldReason entities.
func (m *OrderHoldReasonMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderHoldReasonMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderHoldReasonMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderHoldReason.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderHoldReasonMutation) SetOrderID(i int64) {
	m.orders = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderHoldReasonMutation) OrderID() (r int64, exists bool) {
	v := m.orders
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderHoldReasonMutation) ClearOrderID() {
	m.orders = nil
	m.clearedFields[orderholdreason.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderHoldReasonMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderholdreason.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderHoldReasonMutation) ResetOrderID() {
	m.orders = nil
	delete(m.clearedFields, orderholdreason.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderHoldReasonMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderHoldReasonMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderHoldReasonMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderHoldReasonMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderHoldReasonMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderholdreason.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderHoldReasonMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderholdreason.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderHoldReasonMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderholdreason.FieldProductID)
}

// SetType sets the "type" field.
func (m *OrderHoldReasonMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderHoldReasonMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderHoldReasonMutation) ResetType() {
	m._type = nil
}

// SetCode sets the "code" field.
func (m *OrderHoldReasonMutation) SetCode(i int32) {
	m.code = &i
	m.addcode = nil
}

// Code returns the value of the "code" field in the mutation.
func (m *OrderHoldReasonMutation) Code() (r int32, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// AddCode adds i to the "code" field.
func (m *OrderHoldReasonMutation) AddCode(i int32) {
	if m.addcode != nil {
		*m.addcode += i
	} else {
		m.addcode = &i
	}
}

// AddedCode returns the value that was added to the "code" field in this mutation.
func (m *OrderHoldReasonMutation) AddedCode() (r int32, exists bool) {
	v := m.addcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCode resets all changes to the "code" field.
func (m *OrderHoldReasonMutation) ResetCode() {
	m.code = nil
	m.addcode = nil
}

// SetReason sets the "reason" field.
func (m *OrderHoldReasonMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *OrderHoldReasonMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *OrderHoldReasonMutation) ResetReason() {
	m.reason = nil
}

// SetEnReason sets the "en_reason" field.
func (m *OrderHoldReasonMutation) SetEnReason(s string) {
	m.en_reason = &s
}

// EnReason returns the value of the "en_reason" field in the mutation.
func (m *OrderHoldReasonMutation) EnReason() (r string, exists bool) {
	v := m.en_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldEnReason returns the old "en_reason" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldEnReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnReason: %w", err)
	}
	return oldValue.EnReason, nil
}

// ResetEnReason resets all changes to the "en_reason" field.
func (m *OrderHoldReasonMutation) ResetEnReason() {
	m.en_reason = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderHoldReasonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderHoldReasonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderHoldReason entity.
// If the OrderHoldReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHoldReasonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderHoldReasonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOrdersID sets the "orders" edge to the Order entity by id.
func (m *OrderHoldReasonMutation) SetOrdersID(id int64) {
	m.orders = &id
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *OrderHoldReasonMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *OrderHoldReasonMutation) OrdersCleared() bool {
	return m.OrderIDCleared() || m.clearedorders
}

// OrdersID returns the "orders" edge ID in the mutation.
func (m *OrderHoldReasonMutation) OrdersID() (id int64, exists bool) {
	if m.orders != nil {
		return *m.orders, true
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrdersID instead. It exists only for internal usage by the builders.
func (m *OrderHoldReasonMutation) OrdersIDs() (ids []int64) {
	if id := m.orders; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *OrderHoldReasonMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
}

// Where appends a list predicates to the OrderHoldReasonMutation builder.
func (m *OrderHoldReasonMutation) Where(ps ...predicate.OrderHoldReason) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderHoldReasonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderHoldReason).
func (m *OrderHoldReasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderHoldReasonMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.orders != nil {
		fields = append(fields, orderholdreason.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderholdreason.FieldProductID)
	}
	if m._type != nil {
		fields = append(fields, orderholdreason.FieldType)
	}
	if m.code != nil {
		fields = append(fields, orderholdreason.FieldCode)
	}
	if m.reason != nil {
		fields = append(fields, orderholdreason.FieldReason)
	}
	if m.en_reason != nil {
		fields = append(fields, orderholdreason.FieldEnReason)
	}
	if m.created_at != nil {
		fields = append(fields, orderholdreason.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderHoldReasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderholdreason.FieldOrderID:
		return m.OrderID()
	case orderholdreason.FieldProductID:
		return m.ProductID()
	case orderholdreason.FieldType:
		return m.GetType()
	case orderholdreason.FieldCode:
		return m.Code()
	case orderholdreason.FieldReason:
		return m.Reason()
	case orderholdreason.FieldEnReason:
		return m.EnReason()
	case orderholdreason.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderHoldReasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderholdreason.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderholdreason.FieldProductID:
		return m.OldProductID(ctx)
	case orderholdreason.FieldType:
		return m.OldType(ctx)
	case orderholdreason.FieldCode:
		return m.OldCode(ctx)
	case orderholdreason.FieldReason:
		return m.OldReason(ctx)
	case orderholdreason.FieldEnReason:
		return m.OldEnReason(ctx)
	case orderholdreason.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrderHoldReason field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHoldReasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderholdreason.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderholdreason.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderholdreason.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case orderholdreason.FieldCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case orderholdreason.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case orderholdreason.FieldEnReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnReason(v)
		return nil
	case orderholdreason.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHoldReason field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderHoldReasonMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, orderholdreason.FieldProductID)
	}
	if m.addcode != nil {
		fields = append(fields, orderholdreason.FieldCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderHoldReasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderholdreason.FieldProductID:
		return m.AddedProductID()
	case orderholdreason.FieldCode:
		return m.AddedCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHoldReasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderholdreason.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderholdreason.FieldCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCode(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHoldReason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderHoldReasonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderholdreason.FieldOrderID) {
		fields = append(fields, orderholdreason.FieldOrderID)
	}
	if m.FieldCleared(orderholdreason.FieldProductID) {
		fields = append(fields, orderholdreason.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderHoldReasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderHoldReasonMutation) ClearField(name string) error {
	switch name {
	case orderholdreason.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderholdreason.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown OrderHoldReason nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderHoldReasonMutation) ResetField(name string) error {
	switch name {
	case orderholdreason.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderholdreason.FieldProductID:
		m.ResetProductID()
		return nil
	case orderholdreason.FieldType:
		m.ResetType()
		return nil
	case orderholdreason.FieldCode:
		m.ResetCode()
		return nil
	case orderholdreason.FieldReason:
		m.ResetReason()
		return nil
	case orderholdreason.FieldEnReason:
		m.ResetEnReason()
		return nil
	case orderholdreason.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrderHoldReason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderHoldReasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, orderholdreason.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderHoldReasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderholdreason.EdgeOrders:
		if id := m.orders; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderHoldReasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderHoldReasonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderHoldReasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorders {
		edges = append(edges, orderholdreason.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderHoldReasonMutation) EdgeCleared(name string) bool {
	switch name {
	case orderholdreason.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderHoldReasonMutation) ClearEdge(name string) error {
	switch name {
	case orderholdreason.EdgeOrders:
		m.ClearOrders()
		return nil
	}
	return fmt.Errorf("unknown OrderHoldReason unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderHoldReasonMutation) ResetEdge(name string) error {
	switch name {
	case orderholdreason.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown OrderHoldReason edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	product_id               *int64
	addproduct_id            *int64
	platform_product_id      *int64
	addplatform_product_id   *int64
	barcode                  *string
	fulfillment_service      *string
	ext_order_item_id        *string
	ext_product_id           *string
	is_custom_item           *bool
	name                     *string
	declared_cn_name         *string
	hs_code                  *string
	material                 *string
	purpose                  *string
	images                   *string
	attributes               *string
	grams                    *int
	addgrams                 *int
	length                   *int
	addlength                *int
	width                    *int
	addwidth                 *int
	height                   *int
	addheight                *int
	qty                      *int
	addqty                   *int
	unit_price               *float64
	addunit_price            *float64
	declared_value_in_usd    *float64
	adddeclared_value_in_usd *float64
	declared_value_in_eur    *float64
	adddeclared_value_in_eur *float64
	currency                 *string
	fulfill_qty              *int
	addfulfill_qty           *int
	requires_shipping        *bool
	gift_card                *bool
	taxable                  *bool
	status                   *int8
	addstatus                *int8
	sku                      *string
	listing_sku              *string
	declared_en_name         *string
	product_name             *string
	customer_code            *string
	clearedFields            map[string]struct{}
	tenant                   *int64
	clearedtenant            bool
	_order                   *int64
	cleared_order            bool
	done                     bool
	oldValue                 func(context.Context) (*OrderItem, error)
	predicates               []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int64) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orderitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orderitem.FieldDeletedAt)
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderitem.FieldProductID)
}

// SetPlatformProductID sets the "platform_product_id" field.
func (m *OrderItemMutation) SetPlatformProductID(i int64) {
	m.platform_product_id = &i
	m.addplatform_product_id = nil
}

// PlatformProductID returns the value of the "platform_product_id" field in the mutation.
func (m *OrderItemMutation) PlatformProductID() (r int64, exists bool) {
	v := m.platform_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformProductID returns the old "platform_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPlatformProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformProductID: %w", err)
	}
	return oldValue.PlatformProductID, nil
}

// AddPlatformProductID adds i to the "platform_product_id" field.
func (m *OrderItemMutation) AddPlatformProductID(i int64) {
	if m.addplatform_product_id != nil {
		*m.addplatform_product_id += i
	} else {
		m.addplatform_product_id = &i
	}
}

// AddedPlatformProductID returns the value that was added to the "platform_product_id" field in this mutation.
func (m *OrderItemMutation) AddedPlatformProductID() (r int64, exists bool) {
	v := m.addplatform_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlatformProductID clears the value of the "platform_product_id" field.
func (m *OrderItemMutation) ClearPlatformProductID() {
	m.platform_product_id = nil
	m.addplatform_product_id = nil
	m.clearedFields[orderitem.FieldPlatformProductID] = struct{}{}
}

// PlatformProductIDCleared returns if the "platform_product_id" field was cleared in this mutation.
func (m *OrderItemMutation) PlatformProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldPlatformProductID]
	return ok
}

// ResetPlatformProductID resets all changes to the "platform_product_id" field.
func (m *OrderItemMutation) ResetPlatformProductID() {
	m.platform_product_id = nil
	m.addplatform_product_id = nil
	delete(m.clearedFields, orderitem.FieldPlatformProductID)
}

// SetBarcode sets the "barcode" field.
func (m *OrderItemMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *OrderItemMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *OrderItemMutation) ResetBarcode() {
	m.barcode = nil
}

// SetFulfillmentService sets the "fulfillment_service" field.
func (m *OrderItemMutation) SetFulfillmentService(s string) {
	m.fulfillment_service = &s
}

// FulfillmentService returns the value of the "fulfillment_service" field in the mutation.
func (m *OrderItemMutation) FulfillmentService() (r string, exists bool) {
	v := m.fulfillment_service
	if v == nil {
		return
	}
	return *v, true
}

// OldFulfillmentService returns the old "fulfillment_service" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldFulfillmentService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFulfillmentService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFulfillmentService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFulfillmentService: %w", err)
	}
	return oldValue.FulfillmentService, nil
}

// ResetFulfillmentService resets all changes to the "fulfillment_service" field.
func (m *OrderItemMutation) ResetFulfillmentService() {
	m.fulfillment_service = nil
}

// SetExtOrderItemID sets the "ext_order_item_id" field.
func (m *OrderItemMutation) SetExtOrderItemID(s string) {
	m.ext_order_item_id = &s
}

// ExtOrderItemID returns the value of the "ext_order_item_id" field in the mutation.
func (m *OrderItemMutation) ExtOrderItemID() (r string, exists bool) {
	v := m.ext_order_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtOrderItemID returns the old "ext_order_item_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldExtOrderItemID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtOrderItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtOrderItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtOrderItemID: %w", err)
	}
	return oldValue.ExtOrderItemID, nil
}

// ResetExtOrderItemID resets all changes to the "ext_order_item_id" field.
func (m *OrderItemMutation) ResetExtOrderItemID() {
	m.ext_order_item_id = nil
}

// SetExtProductID sets the "ext_product_id" field.
func (m *OrderItemMutation) SetExtProductID(s string) {
	m.ext_product_id = &s
}

// ExtProductID returns the value of the "ext_product_id" field in the mutation.
func (m *OrderItemMutation) ExtProductID() (r string, exists bool) {
	v := m.ext_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExtProductID returns the old "ext_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldExtProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtProductID: %w", err)
	}
	return oldValue.ExtProductID, nil
}

// ResetExtProductID resets all changes to the "ext_product_id" field.
func (m *OrderItemMutation) ResetExtProductID() {
	m.ext_product_id = nil
}

// SetIsCustomItem sets the "is_custom_item" field.
func (m *OrderItemMutation) SetIsCustomItem(b bool) {
	m.is_custom_item = &b
}

// IsCustomItem returns the value of the "is_custom_item" field in the mutation.
func (m *OrderItemMutation) IsCustomItem() (r bool, exists bool) {
	v := m.is_custom_item
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCustomItem returns the old "is_custom_item" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldIsCustomItem(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCustomItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCustomItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCustomItem: %w", err)
	}
	return oldValue.IsCustomItem, nil
}

// ResetIsCustomItem resets all changes to the "is_custom_item" field.
func (m *OrderItemMutation) ResetIsCustomItem() {
	m.is_custom_item = nil
}

// SetName sets the "name" field.
func (m *OrderItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemMutation) ResetName() {
	m.name = nil
}

// SetDeclaredCnName sets the "declared_cn_name" field.
func (m *OrderItemMutation) SetDeclaredCnName(s string) {
	m.declared_cn_name = &s
}

// DeclaredCnName returns the value of the "declared_cn_name" field in the mutation.
func (m *OrderItemMutation) DeclaredCnName() (r string, exists bool) {
	v := m.declared_cn_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredCnName returns the old "declared_cn_name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeclaredCnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredCnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredCnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredCnName: %w", err)
	}
	return oldValue.DeclaredCnName, nil
}

// ClearDeclaredCnName clears the value of the "declared_cn_name" field.
func (m *OrderItemMutation) ClearDeclaredCnName() {
	m.declared_cn_name = nil
	m.clearedFields[orderitem.FieldDeclaredCnName] = struct{}{}
}

// DeclaredCnNameCleared returns if the "declared_cn_name" field was cleared in this mutation.
func (m *OrderItemMutation) DeclaredCnNameCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDeclaredCnName]
	return ok
}

// ResetDeclaredCnName resets all changes to the "declared_cn_name" field.
func (m *OrderItemMutation) ResetDeclaredCnName() {
	m.declared_cn_name = nil
	delete(m.clearedFields, orderitem.FieldDeclaredCnName)
}

// SetHsCode sets the "hs_code" field.
func (m *OrderItemMutation) SetHsCode(s string) {
	m.hs_code = &s
}

// HsCode returns the value of the "hs_code" field in the mutation.
func (m *OrderItemMutation) HsCode() (r string, exists bool) {
	v := m.hs_code
	if v == nil {
		return
	}
	return *v, true
}

// OldHsCode returns the old "hs_code" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldHsCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHsCode: %w", err)
	}
	return oldValue.HsCode, nil
}

// ResetHsCode resets all changes to the "hs_code" field.
func (m *OrderItemMutation) ResetHsCode() {
	m.hs_code = nil
}

// SetMaterial sets the "material" field.
func (m *OrderItemMutation) SetMaterial(s string) {
	m.material = &s
}

// Material returns the value of the "material" field in the mutation.
func (m *OrderItemMutation) Material() (r string, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldMaterial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ResetMaterial resets all changes to the "material" field.
func (m *OrderItemMutation) ResetMaterial() {
	m.material = nil
}

// SetPurpose sets the "purpose" field.
func (m *OrderItemMutation) SetPurpose(s string) {
	m.purpose = &s
}

// Purpose returns the value of the "purpose" field in the mutation.
func (m *OrderItemMutation) Purpose() (r string, exists bool) {
	v := m.purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPurpose returns the old "purpose" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurpose: %w", err)
	}
	return oldValue.Purpose, nil
}

// ResetPurpose resets all changes to the "purpose" field.
func (m *OrderItemMutation) ResetPurpose() {
	m.purpose = nil
}

// SetImages sets the "images" field.
func (m *OrderItemMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *OrderItemMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *OrderItemMutation) ClearImages() {
	m.images = nil
	m.clearedFields[orderitem.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *OrderItemMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *OrderItemMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, orderitem.FieldImages)
}

// SetAttributes sets the "attributes" field.
func (m *OrderItemMutation) SetAttributes(s string) {
	m.attributes = &s
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *OrderItemMutation) Attributes() (r string, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldAttributes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *OrderItemMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[orderitem.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *OrderItemMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *OrderItemMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, orderitem.FieldAttributes)
}

// SetGrams sets the "grams" field.
func (m *OrderItemMutation) SetGrams(i int) {
	m.grams = &i
	m.addgrams = nil
}

// Grams returns the value of the "grams" field in the mutation.
func (m *OrderItemMutation) Grams() (r int, exists bool) {
	v := m.grams
	if v == nil {
		return
	}
	return *v, true
}

// OldGrams returns the old "grams" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldGrams(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrams: %w", err)
	}
	return oldValue.Grams, nil
}

// AddGrams adds i to the "grams" field.
func (m *OrderItemMutation) AddGrams(i int) {
	if m.addgrams != nil {
		*m.addgrams += i
	} else {
		m.addgrams = &i
	}
}

// AddedGrams returns the value that was added to the "grams" field in this mutation.
func (m *OrderItemMutation) AddedGrams() (r int, exists bool) {
	v := m.addgrams
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrams resets all changes to the "grams" field.
func (m *OrderItemMutation) ResetGrams() {
	m.grams = nil
	m.addgrams = nil
}

// SetLength sets the "length" field.
func (m *OrderItemMutation) SetLength(i int) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *OrderItemMutation) Length() (r int, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *OrderItemMutation) AddLength(i int) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *OrderItemMutation) AddedLength() (r int, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *OrderItemMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *OrderItemMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *OrderItemMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *OrderItemMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *OrderItemMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *OrderItemMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *OrderItemMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *OrderItemMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *OrderItemMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *OrderItemMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *OrderItemMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetQty sets the "qty" field.
func (m *OrderItemMutation) SetQty(i int) {
	m.qty = &i
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *OrderItemMutation) Qty() (r int, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds i to the "qty" field.
func (m *OrderItemMutation) AddQty(i int) {
	if m.addqty != nil {
		*m.addqty += i
	} else {
		m.addqty = &i
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *OrderItemMutation) AddedQty() (r int, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *OrderItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *OrderItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *OrderItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *OrderItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *OrderItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *OrderItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetDeclaredValueInUsd sets the "declared_value_in_usd" field.
func (m *OrderItemMutation) SetDeclaredValueInUsd(f float64) {
	m.declared_value_in_usd = &f
	m.adddeclared_value_in_usd = nil
}

// DeclaredValueInUsd returns the value of the "declared_value_in_usd" field in the mutation.
func (m *OrderItemMutation) DeclaredValueInUsd() (r float64, exists bool) {
	v := m.declared_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredValueInUsd returns the old "declared_value_in_usd" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeclaredValueInUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredValueInUsd: %w", err)
	}
	return oldValue.DeclaredValueInUsd, nil
}

// AddDeclaredValueInUsd adds f to the "declared_value_in_usd" field.
func (m *OrderItemMutation) AddDeclaredValueInUsd(f float64) {
	if m.adddeclared_value_in_usd != nil {
		*m.adddeclared_value_in_usd += f
	} else {
		m.adddeclared_value_in_usd = &f
	}
}

// AddedDeclaredValueInUsd returns the value that was added to the "declared_value_in_usd" field in this mutation.
func (m *OrderItemMutation) AddedDeclaredValueInUsd() (r float64, exists bool) {
	v := m.adddeclared_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeclaredValueInUsd resets all changes to the "declared_value_in_usd" field.
func (m *OrderItemMutation) ResetDeclaredValueInUsd() {
	m.declared_value_in_usd = nil
	m.adddeclared_value_in_usd = nil
}

// SetDeclaredValueInEur sets the "declared_value_in_eur" field.
func (m *OrderItemMutation) SetDeclaredValueInEur(f float64) {
	m.declared_value_in_eur = &f
	m.adddeclared_value_in_eur = nil
}

// DeclaredValueInEur returns the value of the "declared_value_in_eur" field in the mutation.
func (m *OrderItemMutation) DeclaredValueInEur() (r float64, exists bool) {
	v := m.declared_value_in_eur
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredValueInEur returns the old "declared_value_in_eur" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeclaredValueInEur(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredValueInEur is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredValueInEur requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredValueInEur: %w", err)
	}
	return oldValue.DeclaredValueInEur, nil
}

// AddDeclaredValueInEur adds f to the "declared_value_in_eur" field.
func (m *OrderItemMutation) AddDeclaredValueInEur(f float64) {
	if m.adddeclared_value_in_eur != nil {
		*m.adddeclared_value_in_eur += f
	} else {
		m.adddeclared_value_in_eur = &f
	}
}

// AddedDeclaredValueInEur returns the value that was added to the "declared_value_in_eur" field in this mutation.
func (m *OrderItemMutation) AddedDeclaredValueInEur() (r float64, exists bool) {
	v := m.adddeclared_value_in_eur
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeclaredValueInEur resets all changes to the "declared_value_in_eur" field.
func (m *OrderItemMutation) ResetDeclaredValueInEur() {
	m.declared_value_in_eur = nil
	m.adddeclared_value_in_eur = nil
}

// SetCurrency sets the "currency" field.
func (m *OrderItemMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *OrderItemMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *OrderItemMutation) ResetCurrency() {
	m.currency = nil
}

// SetFulfillQty sets the "fulfill_qty" field.
func (m *OrderItemMutation) SetFulfillQty(i int) {
	m.fulfill_qty = &i
	m.addfulfill_qty = nil
}

// FulfillQty returns the value of the "fulfill_qty" field in the mutation.
func (m *OrderItemMutation) FulfillQty() (r int, exists bool) {
	v := m.fulfill_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldFulfillQty returns the old "fulfill_qty" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldFulfillQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFulfillQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFulfillQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFulfillQty: %w", err)
	}
	return oldValue.FulfillQty, nil
}

// AddFulfillQty adds i to the "fulfill_qty" field.
func (m *OrderItemMutation) AddFulfillQty(i int) {
	if m.addfulfill_qty != nil {
		*m.addfulfill_qty += i
	} else {
		m.addfulfill_qty = &i
	}
}

// AddedFulfillQty returns the value that was added to the "fulfill_qty" field in this mutation.
func (m *OrderItemMutation) AddedFulfillQty() (r int, exists bool) {
	v := m.addfulfill_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetFulfillQty resets all changes to the "fulfill_qty" field.
func (m *OrderItemMutation) ResetFulfillQty() {
	m.fulfill_qty = nil
	m.addfulfill_qty = nil
}

// SetRequiresShipping sets the "requires_shipping" field.
func (m *OrderItemMutation) SetRequiresShipping(b bool) {
	m.requires_shipping = &b
}

// RequiresShipping returns the value of the "requires_shipping" field in the mutation.
func (m *OrderItemMutation) RequiresShipping() (r bool, exists bool) {
	v := m.requires_shipping
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresShipping returns the old "requires_shipping" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRequiresShipping(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresShipping: %w", err)
	}
	return oldValue.RequiresShipping, nil
}

// ResetRequiresShipping resets all changes to the "requires_shipping" field.
func (m *OrderItemMutation) ResetRequiresShipping() {
	m.requires_shipping = nil
}

// SetGiftCard sets the "gift_card" field.
func (m *OrderItemMutation) SetGiftCard(b bool) {
	m.gift_card = &b
}

// GiftCard returns the value of the "gift_card" field in the mutation.
func (m *OrderItemMutation) GiftCard() (r bool, exists bool) {
	v := m.gift_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftCard returns the old "gift_card" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldGiftCard(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGiftCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGiftCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftCard: %w", err)
	}
	return oldValue.GiftCard, nil
}

// ResetGiftCard resets all changes to the "gift_card" field.
func (m *OrderItemMutation) ResetGiftCard() {
	m.gift_card = nil
}

// SetTaxable sets the "taxable" field.
func (m *OrderItemMutation) SetTaxable(b bool) {
	m.taxable = &b
}

// Taxable returns the value of the "taxable" field in the mutation.
func (m *OrderItemMutation) Taxable() (r bool, exists bool) {
	v := m.taxable
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxable returns the old "taxable" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldTaxable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxable: %w", err)
	}
	return oldValue.Taxable, nil
}

// ResetTaxable resets all changes to the "taxable" field.
func (m *OrderItemMutation) ResetTaxable() {
	m.taxable = nil
}

// SetStatus sets the "status" field.
func (m *OrderItemMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderItemMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderItemMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderItemMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderItemMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSku sets the "sku" field.
func (m *OrderItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *OrderItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *OrderItemMutation) ClearSku() {
	m.sku = nil
	m.clearedFields[orderitem.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *OrderItemMutation) SkuCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *OrderItemMutation) ResetSku() {
	m.sku = nil
	delete(m.clearedFields, orderitem.FieldSku)
}

// SetListingSku sets the "listing_sku" field.
func (m *OrderItemMutation) SetListingSku(s string) {
	m.listing_sku = &s
}

// ListingSku returns the value of the "listing_sku" field in the mutation.
func (m *OrderItemMutation) ListingSku() (r string, exists bool) {
	v := m.listing_sku
	if v == nil {
		return
	}
	return *v, true
}

// OldListingSku returns the old "listing_sku" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldListingSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListingSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListingSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListingSku: %w", err)
	}
	return oldValue.ListingSku, nil
}

// ClearListingSku clears the value of the "listing_sku" field.
func (m *OrderItemMutation) ClearListingSku() {
	m.listing_sku = nil
	m.clearedFields[orderitem.FieldListingSku] = struct{}{}
}

// ListingSkuCleared returns if the "listing_sku" field was cleared in this mutation.
func (m *OrderItemMutation) ListingSkuCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldListingSku]
	return ok
}

// ResetListingSku resets all changes to the "listing_sku" field.
func (m *OrderItemMutation) ResetListingSku() {
	m.listing_sku = nil
	delete(m.clearedFields, orderitem.FieldListingSku)
}

// SetDeclaredEnName sets the "declared_en_name" field.
func (m *OrderItemMutation) SetDeclaredEnName(s string) {
	m.declared_en_name = &s
}

// DeclaredEnName returns the value of the "declared_en_name" field in the mutation.
func (m *OrderItemMutation) DeclaredEnName() (r string, exists bool) {
	v := m.declared_en_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredEnName returns the old "declared_en_name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeclaredEnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredEnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredEnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredEnName: %w", err)
	}
	return oldValue.DeclaredEnName, nil
}

// ClearDeclaredEnName clears the value of the "declared_en_name" field.
func (m *OrderItemMutation) ClearDeclaredEnName() {
	m.declared_en_name = nil
	m.clearedFields[orderitem.FieldDeclaredEnName] = struct{}{}
}

// DeclaredEnNameCleared returns if the "declared_en_name" field was cleared in this mutation.
func (m *OrderItemMutation) DeclaredEnNameCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDeclaredEnName]
	return ok
}

// ResetDeclaredEnName resets all changes to the "declared_en_name" field.
func (m *OrderItemMutation) ResetDeclaredEnName() {
	m.declared_en_name = nil
	delete(m.clearedFields, orderitem.FieldDeclaredEnName)
}

// SetProductName sets the "product_name" field.
func (m *OrderItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *OrderItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *OrderItemMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[orderitem.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *OrderItemMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *OrderItemMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, orderitem.FieldProductName)
}

// SetCustomerCode sets the "customer_code" field.
func (m *OrderItemMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *OrderItemMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCustomerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *OrderItemMutation) ResetCustomerCode() {
	m.customer_code = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *OrderItemMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrderItemMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrderItemMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *OrderItemMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrderItemMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderitem.FieldDeletedAt)
	}
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.platform_product_id != nil {
		fields = append(fields, orderitem.FieldPlatformProductID)
	}
	if m.barcode != nil {
		fields = append(fields, orderitem.FieldBarcode)
	}
	if m.fulfillment_service != nil {
		fields = append(fields, orderitem.FieldFulfillmentService)
	}
	if m.ext_order_item_id != nil {
		fields = append(fields, orderitem.FieldExtOrderItemID)
	}
	if m.ext_product_id != nil {
		fields = append(fields, orderitem.FieldExtProductID)
	}
	if m.is_custom_item != nil {
		fields = append(fields, orderitem.FieldIsCustomItem)
	}
	if m.name != nil {
		fields = append(fields, orderitem.FieldName)
	}
	if m.declared_cn_name != nil {
		fields = append(fields, orderitem.FieldDeclaredCnName)
	}
	if m.hs_code != nil {
		fields = append(fields, orderitem.FieldHsCode)
	}
	if m.material != nil {
		fields = append(fields, orderitem.FieldMaterial)
	}
	if m.purpose != nil {
		fields = append(fields, orderitem.FieldPurpose)
	}
	if m.images != nil {
		fields = append(fields, orderitem.FieldImages)
	}
	if m.attributes != nil {
		fields = append(fields, orderitem.FieldAttributes)
	}
	if m.grams != nil {
		fields = append(fields, orderitem.FieldGrams)
	}
	if m.length != nil {
		fields = append(fields, orderitem.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, orderitem.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, orderitem.FieldHeight)
	}
	if m.qty != nil {
		fields = append(fields, orderitem.FieldQty)
	}
	if m.unit_price != nil {
		fields = append(fields, orderitem.FieldUnitPrice)
	}
	if m.declared_value_in_usd != nil {
		fields = append(fields, orderitem.FieldDeclaredValueInUsd)
	}
	if m.declared_value_in_eur != nil {
		fields = append(fields, orderitem.FieldDeclaredValueInEur)
	}
	if m.currency != nil {
		fields = append(fields, orderitem.FieldCurrency)
	}
	if m.fulfill_qty != nil {
		fields = append(fields, orderitem.FieldFulfillQty)
	}
	if m.requires_shipping != nil {
		fields = append(fields, orderitem.FieldRequiresShipping)
	}
	if m.gift_card != nil {
		fields = append(fields, orderitem.FieldGiftCard)
	}
	if m.taxable != nil {
		fields = append(fields, orderitem.FieldTaxable)
	}
	if m.status != nil {
		fields = append(fields, orderitem.FieldStatus)
	}
	if m.sku != nil {
		fields = append(fields, orderitem.FieldSku)
	}
	if m.listing_sku != nil {
		fields = append(fields, orderitem.FieldListingSku)
	}
	if m.declared_en_name != nil {
		fields = append(fields, orderitem.FieldDeclaredEnName)
	}
	if m.product_name != nil {
		fields = append(fields, orderitem.FieldProductName)
	}
	if m.customer_code != nil {
		fields = append(fields, orderitem.FieldCustomerCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderitem.FieldDeletedAt:
		return m.DeletedAt()
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldPlatformProductID:
		return m.PlatformProductID()
	case orderitem.FieldBarcode:
		return m.Barcode()
	case orderitem.FieldFulfillmentService:
		return m.FulfillmentService()
	case orderitem.FieldExtOrderItemID:
		return m.ExtOrderItemID()
	case orderitem.FieldExtProductID:
		return m.ExtProductID()
	case orderitem.FieldIsCustomItem:
		return m.IsCustomItem()
	case orderitem.FieldName:
		return m.Name()
	case orderitem.FieldDeclaredCnName:
		return m.DeclaredCnName()
	case orderitem.FieldHsCode:
		return m.HsCode()
	case orderitem.FieldMaterial:
		return m.Material()
	case orderitem.FieldPurpose:
		return m.Purpose()
	case orderitem.FieldImages:
		return m.Images()
	case orderitem.FieldAttributes:
		return m.Attributes()
	case orderitem.FieldGrams:
		return m.Grams()
	case orderitem.FieldLength:
		return m.Length()
	case orderitem.FieldWidth:
		return m.Width()
	case orderitem.FieldHeight:
		return m.Height()
	case orderitem.FieldQty:
		return m.Qty()
	case orderitem.FieldUnitPrice:
		return m.UnitPrice()
	case orderitem.FieldDeclaredValueInUsd:
		return m.DeclaredValueInUsd()
	case orderitem.FieldDeclaredValueInEur:
		return m.DeclaredValueInEur()
	case orderitem.FieldCurrency:
		return m.Currency()
	case orderitem.FieldFulfillQty:
		return m.FulfillQty()
	case orderitem.FieldRequiresShipping:
		return m.RequiresShipping()
	case orderitem.FieldGiftCard:
		return m.GiftCard()
	case orderitem.FieldTaxable:
		return m.Taxable()
	case orderitem.FieldStatus:
		return m.Status()
	case orderitem.FieldSku:
		return m.Sku()
	case orderitem.FieldListingSku:
		return m.ListingSku()
	case orderitem.FieldDeclaredEnName:
		return m.DeclaredEnName()
	case orderitem.FieldProductName:
		return m.ProductName()
	case orderitem.FieldCustomerCode:
		return m.CustomerCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldPlatformProductID:
		return m.OldPlatformProductID(ctx)
	case orderitem.FieldBarcode:
		return m.OldBarcode(ctx)
	case orderitem.FieldFulfillmentService:
		return m.OldFulfillmentService(ctx)
	case orderitem.FieldExtOrderItemID:
		return m.OldExtOrderItemID(ctx)
	case orderitem.FieldExtProductID:
		return m.OldExtProductID(ctx)
	case orderitem.FieldIsCustomItem:
		return m.OldIsCustomItem(ctx)
	case orderitem.FieldName:
		return m.OldName(ctx)
	case orderitem.FieldDeclaredCnName:
		return m.OldDeclaredCnName(ctx)
	case orderitem.FieldHsCode:
		return m.OldHsCode(ctx)
	case orderitem.FieldMaterial:
		return m.OldMaterial(ctx)
	case orderitem.FieldPurpose:
		return m.OldPurpose(ctx)
	case orderitem.FieldImages:
		return m.OldImages(ctx)
	case orderitem.FieldAttributes:
		return m.OldAttributes(ctx)
	case orderitem.FieldGrams:
		return m.OldGrams(ctx)
	case orderitem.FieldLength:
		return m.OldLength(ctx)
	case orderitem.FieldWidth:
		return m.OldWidth(ctx)
	case orderitem.FieldHeight:
		return m.OldHeight(ctx)
	case orderitem.FieldQty:
		return m.OldQty(ctx)
	case orderitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case orderitem.FieldDeclaredValueInUsd:
		return m.OldDeclaredValueInUsd(ctx)
	case orderitem.FieldDeclaredValueInEur:
		return m.OldDeclaredValueInEur(ctx)
	case orderitem.FieldCurrency:
		return m.OldCurrency(ctx)
	case orderitem.FieldFulfillQty:
		return m.OldFulfillQty(ctx)
	case orderitem.FieldRequiresShipping:
		return m.OldRequiresShipping(ctx)
	case orderitem.FieldGiftCard:
		return m.OldGiftCard(ctx)
	case orderitem.FieldTaxable:
		return m.OldTaxable(ctx)
	case orderitem.FieldStatus:
		return m.OldStatus(ctx)
	case orderitem.FieldSku:
		return m.OldSku(ctx)
	case orderitem.FieldListingSku:
		return m.OldListingSku(ctx)
	case orderitem.FieldDeclaredEnName:
		return m.OldDeclaredEnName(ctx)
	case orderitem.FieldProductName:
		return m.OldProductName(ctx)
	case orderitem.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderitem.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldPlatformProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformProductID(v)
		return nil
	case orderitem.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case orderitem.FieldFulfillmentService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFulfillmentService(v)
		return nil
	case orderitem.FieldExtOrderItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtOrderItemID(v)
		return nil
	case orderitem.FieldExtProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtProductID(v)
		return nil
	case orderitem.FieldIsCustomItem:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCustomItem(v)
		return nil
	case orderitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitem.FieldDeclaredCnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredCnName(v)
		return nil
	case orderitem.FieldHsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHsCode(v)
		return nil
	case orderitem.FieldMaterial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	case orderitem.FieldPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurpose(v)
		return nil
	case orderitem.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case orderitem.FieldAttributes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case orderitem.FieldGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrams(v)
		return nil
	case orderitem.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case orderitem.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case orderitem.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case orderitem.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case orderitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case orderitem.FieldDeclaredValueInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredValueInUsd(v)
		return nil
	case orderitem.FieldDeclaredValueInEur:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredValueInEur(v)
		return nil
	case orderitem.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case orderitem.FieldFulfillQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFulfillQty(v)
		return nil
	case orderitem.FieldRequiresShipping:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresShipping(v)
		return nil
	case orderitem.FieldGiftCard:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftCard(v)
		return nil
	case orderitem.FieldTaxable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxable(v)
		return nil
	case orderitem.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orderitem.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case orderitem.FieldListingSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListingSku(v)
		return nil
	case orderitem.FieldDeclaredEnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredEnName(v)
		return nil
	case orderitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case orderitem.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.addplatform_product_id != nil {
		fields = append(fields, orderitem.FieldPlatformProductID)
	}
	if m.addgrams != nil {
		fields = append(fields, orderitem.FieldGrams)
	}
	if m.addlength != nil {
		fields = append(fields, orderitem.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, orderitem.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, orderitem.FieldHeight)
	}
	if m.addqty != nil {
		fields = append(fields, orderitem.FieldQty)
	}
	if m.addunit_price != nil {
		fields = append(fields, orderitem.FieldUnitPrice)
	}
	if m.adddeclared_value_in_usd != nil {
		fields = append(fields, orderitem.FieldDeclaredValueInUsd)
	}
	if m.adddeclared_value_in_eur != nil {
		fields = append(fields, orderitem.FieldDeclaredValueInEur)
	}
	if m.addfulfill_qty != nil {
		fields = append(fields, orderitem.FieldFulfillQty)
	}
	if m.addstatus != nil {
		fields = append(fields, orderitem.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldProductID:
		return m.AddedProductID()
	case orderitem.FieldPlatformProductID:
		return m.AddedPlatformProductID()
	case orderitem.FieldGrams:
		return m.AddedGrams()
	case orderitem.FieldLength:
		return m.AddedLength()
	case orderitem.FieldWidth:
		return m.AddedWidth()
	case orderitem.FieldHeight:
		return m.AddedHeight()
	case orderitem.FieldQty:
		return m.AddedQty()
	case orderitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case orderitem.FieldDeclaredValueInUsd:
		return m.AddedDeclaredValueInUsd()
	case orderitem.FieldDeclaredValueInEur:
		return m.AddedDeclaredValueInEur()
	case orderitem.FieldFulfillQty:
		return m.AddedFulfillQty()
	case orderitem.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderitem.FieldPlatformProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformProductID(v)
		return nil
	case orderitem.FieldGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrams(v)
		return nil
	case orderitem.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case orderitem.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case orderitem.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case orderitem.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case orderitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case orderitem.FieldDeclaredValueInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclaredValueInUsd(v)
		return nil
	case orderitem.FieldDeclaredValueInEur:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclaredValueInEur(v)
		return nil
	case orderitem.FieldFulfillQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFulfillQty(v)
		return nil
	case orderitem.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldDeletedAt) {
		fields = append(fields, orderitem.FieldDeletedAt)
	}
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.FieldCleared(orderitem.FieldProductID) {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.FieldCleared(orderitem.FieldPlatformProductID) {
		fields = append(fields, orderitem.FieldPlatformProductID)
	}
	if m.FieldCleared(orderitem.FieldDeclaredCnName) {
		fields = append(fields, orderitem.FieldDeclaredCnName)
	}
	if m.FieldCleared(orderitem.FieldImages) {
		fields = append(fields, orderitem.FieldImages)
	}
	if m.FieldCleared(orderitem.FieldAttributes) {
		fields = append(fields, orderitem.FieldAttributes)
	}
	if m.FieldCleared(orderitem.FieldSku) {
		fields = append(fields, orderitem.FieldSku)
	}
	if m.FieldCleared(orderitem.FieldListingSku) {
		fields = append(fields, orderitem.FieldListingSku)
	}
	if m.FieldCleared(orderitem.FieldDeclaredEnName) {
		fields = append(fields, orderitem.FieldDeclaredEnName)
	}
	if m.FieldCleared(orderitem.FieldProductName) {
		fields = append(fields, orderitem.FieldProductName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ClearProductID()
		return nil
	case orderitem.FieldPlatformProductID:
		m.ClearPlatformProductID()
		return nil
	case orderitem.FieldDeclaredCnName:
		m.ClearDeclaredCnName()
		return nil
	case orderitem.FieldImages:
		m.ClearImages()
		return nil
	case orderitem.FieldAttributes:
		m.ClearAttributes()
		return nil
	case orderitem.FieldSku:
		m.ClearSku()
		return nil
	case orderitem.FieldListingSku:
		m.ClearListingSku()
		return nil
	case orderitem.FieldDeclaredEnName:
		m.ClearDeclaredEnName()
		return nil
	case orderitem.FieldProductName:
		m.ClearProductName()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldPlatformProductID:
		m.ResetPlatformProductID()
		return nil
	case orderitem.FieldBarcode:
		m.ResetBarcode()
		return nil
	case orderitem.FieldFulfillmentService:
		m.ResetFulfillmentService()
		return nil
	case orderitem.FieldExtOrderItemID:
		m.ResetExtOrderItemID()
		return nil
	case orderitem.FieldExtProductID:
		m.ResetExtProductID()
		return nil
	case orderitem.FieldIsCustomItem:
		m.ResetIsCustomItem()
		return nil
	case orderitem.FieldName:
		m.ResetName()
		return nil
	case orderitem.FieldDeclaredCnName:
		m.ResetDeclaredCnName()
		return nil
	case orderitem.FieldHsCode:
		m.ResetHsCode()
		return nil
	case orderitem.FieldMaterial:
		m.ResetMaterial()
		return nil
	case orderitem.FieldPurpose:
		m.ResetPurpose()
		return nil
	case orderitem.FieldImages:
		m.ResetImages()
		return nil
	case orderitem.FieldAttributes:
		m.ResetAttributes()
		return nil
	case orderitem.FieldGrams:
		m.ResetGrams()
		return nil
	case orderitem.FieldLength:
		m.ResetLength()
		return nil
	case orderitem.FieldWidth:
		m.ResetWidth()
		return nil
	case orderitem.FieldHeight:
		m.ResetHeight()
		return nil
	case orderitem.FieldQty:
		m.ResetQty()
		return nil
	case orderitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case orderitem.FieldDeclaredValueInUsd:
		m.ResetDeclaredValueInUsd()
		return nil
	case orderitem.FieldDeclaredValueInEur:
		m.ResetDeclaredValueInEur()
		return nil
	case orderitem.FieldCurrency:
		m.ResetCurrency()
		return nil
	case orderitem.FieldFulfillQty:
		m.ResetFulfillQty()
		return nil
	case orderitem.FieldRequiresShipping:
		m.ResetRequiresShipping()
		return nil
	case orderitem.FieldGiftCard:
		m.ResetGiftCard()
		return nil
	case orderitem.FieldTaxable:
		m.ResetTaxable()
		return nil
	case orderitem.FieldStatus:
		m.ResetStatus()
		return nil
	case orderitem.FieldSku:
		m.ResetSku()
		return nil
	case orderitem.FieldListingSku:
		m.ResetListingSku()
		return nil
	case orderitem.FieldDeclaredEnName:
		m.ResetDeclaredEnName()
		return nil
	case orderitem.FieldProductName:
		m.ResetProductName()
		return nil
	case orderitem.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, orderitem.EdgeTenant)
	}
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, orderitem.EdgeTenant)
	}
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeTenant:
		return m.clearedtenant
	case orderitem.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeTenant:
		m.ClearTenant()
		return nil
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeTenant:
		m.ResetTenant()
		return nil
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderTaxationMutation represents an operation that mutates the OrderTaxation nodes in the graph.
type OrderTaxationMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *string
	country_code  *string
	number        *string
	clearedFields map[string]struct{}
	orders        *int64
	clearedorders bool
	done          bool
	oldValue      func(context.Context) (*OrderTaxation, error)
	predicates    []predicate.OrderTaxation
}

var _ ent.Mutation = (*OrderTaxationMutation)(nil)

// ordertaxationOption allows management of the mutation configuration using functional options.
type ordertaxationOption func(*OrderTaxationMutation)

// newOrderTaxationMutation creates new mutation for the OrderTaxation entity.
func newOrderTaxationMutation(c config, op Op, opts ...ordertaxationOption) *OrderTaxationMutation {
	m := &OrderTaxationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderTaxation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderTaxationID sets the ID field of the mutation.
func withOrderTaxationID(id int64) ordertaxationOption {
	return func(m *OrderTaxationMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderTaxation
		)
		m.oldValue = func(ctx context.Context) (*OrderTaxation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderTaxation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderTaxation sets the old OrderTaxation of the mutation.
func withOrderTaxation(node *OrderTaxation) ordertaxationOption {
	return func(m *OrderTaxationMutation) {
		m.oldValue = func(context.Context) (*OrderTaxation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderTaxationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderTaxationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderTaxation entities.
func (m *OrderTaxationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderTaxationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderTaxationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderTaxation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderTaxationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderTaxationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderTaxationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderTaxationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderTaxationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderTaxationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderTaxationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderTaxationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderTaxationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ordertaxation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderTaxationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ordertaxation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderTaxationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ordertaxation.FieldDeletedAt)
}

// SetOrderID sets the "order_id" field.
func (m *OrderTaxationMutation) SetOrderID(i int64) {
	m.orders = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderTaxationMutation) OrderID() (r int64, exists bool) {
	v := m.orders
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderTaxationMutation) ClearOrderID() {
	m.orders = nil
	m.clearedFields[ordertaxation.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderTaxationMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordertaxation.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderTaxationMutation) ResetOrderID() {
	m.orders = nil
	delete(m.clearedFields, ordertaxation.FieldOrderID)
}

// SetType sets the "type" field.
func (m *OrderTaxationMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderTaxationMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderTaxationMutation) ResetType() {
	m._type = nil
}

// SetCountryCode sets the "country_code" field.
func (m *OrderTaxationMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *OrderTaxationMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *OrderTaxationMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[ordertaxation.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *OrderTaxationMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[ordertaxation.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *OrderTaxationMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, ordertaxation.FieldCountryCode)
}

// SetNumber sets the "number" field.
func (m *OrderTaxationMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *OrderTaxationMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the OrderTaxation entity.
// If the OrderTaxation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderTaxationMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *OrderTaxationMutation) ResetNumber() {
	m.number = nil
}

// SetOrdersID sets the "orders" edge to the Order entity by id.
func (m *OrderTaxationMutation) SetOrdersID(id int64) {
	m.orders = &id
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *OrderTaxationMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *OrderTaxationMutation) OrdersCleared() bool {
	return m.OrderIDCleared() || m.clearedorders
}

// OrdersID returns the "orders" edge ID in the mutation.
func (m *OrderTaxationMutation) OrdersID() (id int64, exists bool) {
	if m.orders != nil {
		return *m.orders, true
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrdersID instead. It exists only for internal usage by the builders.
func (m *OrderTaxationMutation) OrdersIDs() (ids []int64) {
	if id := m.orders; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *OrderTaxationMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
}

// Where appends a list predicates to the OrderTaxationMutation builder.
func (m *OrderTaxationMutation) Where(ps ...predicate.OrderTaxation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderTaxationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderTaxation).
func (m *OrderTaxationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderTaxationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, ordertaxation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ordertaxation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ordertaxation.FieldDeletedAt)
	}
	if m.orders != nil {
		fields = append(fields, ordertaxation.FieldOrderID)
	}
	if m._type != nil {
		fields = append(fields, ordertaxation.FieldType)
	}
	if m.country_code != nil {
		fields = append(fields, ordertaxation.FieldCountryCode)
	}
	if m.number != nil {
		fields = append(fields, ordertaxation.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderTaxationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordertaxation.FieldCreatedAt:
		return m.CreatedAt()
	case ordertaxation.FieldUpdatedAt:
		return m.UpdatedAt()
	case ordertaxation.FieldDeletedAt:
		return m.DeletedAt()
	case ordertaxation.FieldOrderID:
		return m.OrderID()
	case ordertaxation.FieldType:
		return m.GetType()
	case ordertaxation.FieldCountryCode:
		return m.CountryCode()
	case ordertaxation.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderTaxationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordertaxation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ordertaxation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ordertaxation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ordertaxation.FieldOrderID:
		return m.OldOrderID(ctx)
	case ordertaxation.FieldType:
		return m.OldType(ctx)
	case ordertaxation.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case ordertaxation.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown OrderTaxation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderTaxationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordertaxation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ordertaxation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ordertaxation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ordertaxation.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case ordertaxation.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case ordertaxation.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case ordertaxation.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown OrderTaxation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderTaxationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderTaxationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderTaxationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderTaxation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderTaxationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordertaxation.FieldDeletedAt) {
		fields = append(fields, ordertaxation.FieldDeletedAt)
	}
	if m.FieldCleared(ordertaxation.FieldOrderID) {
		fields = append(fields, ordertaxation.FieldOrderID)
	}
	if m.FieldCleared(ordertaxation.FieldCountryCode) {
		fields = append(fields, ordertaxation.FieldCountryCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderTaxationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderTaxationMutation) ClearField(name string) error {
	switch name {
	case ordertaxation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ordertaxation.FieldOrderID:
		m.ClearOrderID()
		return nil
	case ordertaxation.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	}
	return fmt.Errorf("unknown OrderTaxation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderTaxationMutation) ResetField(name string) error {
	switch name {
	case ordertaxation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ordertaxation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ordertaxation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ordertaxation.FieldOrderID:
		m.ResetOrderID()
		return nil
	case ordertaxation.FieldType:
		m.ResetType()
		return nil
	case ordertaxation.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case ordertaxation.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown OrderTaxation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderTaxationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, ordertaxation.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderTaxationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordertaxation.EdgeOrders:
		if id := m.orders; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderTaxationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderTaxationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderTaxationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorders {
		edges = append(edges, ordertaxation.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderTaxationMutation) EdgeCleared(name string) bool {
	switch name {
	case ordertaxation.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderTaxationMutation) ClearEdge(name string) error {
	switch name {
	case ordertaxation.EdgeOrders:
		m.ClearOrders()
		return nil
	}
	return fmt.Errorf("unknown OrderTaxation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderTaxationMutation) ResetEdge(name string) error {
	switch name {
	case ordertaxation.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown OrderTaxation edge %s", name)
}

// PickupOrderMutation represents an operation that mutates the PickupOrder nodes in the graph.
type PickupOrderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	requested_pickup_at *time.Time
	status              *int8
	addstatus           *int8
	sender_address_info *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PickupOrder, error)
	predicates          []predicate.PickupOrder
}

var _ ent.Mutation = (*PickupOrderMutation)(nil)

// pickuporderOption allows management of the mutation configuration using functional options.
type pickuporderOption func(*PickupOrderMutation)

// newPickupOrderMutation creates new mutation for the PickupOrder entity.
func newPickupOrderMutation(c config, op Op, opts ...pickuporderOption) *PickupOrderMutation {
	m := &PickupOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePickupOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPickupOrderID sets the ID field of the mutation.
func withPickupOrderID(id int64) pickuporderOption {
	return func(m *PickupOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PickupOrder
		)
		m.oldValue = func(ctx context.Context) (*PickupOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PickupOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPickupOrder sets the old PickupOrder of the mutation.
func withPickupOrder(node *PickupOrder) pickuporderOption {
	return func(m *PickupOrderMutation) {
		m.oldValue = func(context.Context) (*PickupOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PickupOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PickupOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PickupOrder entities.
func (m *PickupOrderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PickupOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PickupOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PickupOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PickupOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PickupOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PickupOrder entity.
// If the PickupOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PickupOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PickupOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PickupOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PickupOrder entity.
// If the PickupOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PickupOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PickupOrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PickupOrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PickupOrder entity.
// If the PickupOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PickupOrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pickuporder.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PickupOrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pickuporder.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PickupOrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pickuporder.FieldDeletedAt)
}

// SetRequestedPickupAt sets the "requested_pickup_at" field.
func (m *PickupOrderMutation) SetRequestedPickupAt(t time.Time) {
	m.requested_pickup_at = &t
}

// RequestedPickupAt returns the value of the "requested_pickup_at" field in the mutation.
func (m *PickupOrderMutation) RequestedPickupAt() (r time.Time, exists bool) {
	v := m.requested_pickup_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedPickupAt returns the old "requested_pickup_at" field's value of the PickupOrder entity.
// If the PickupOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderMutation) OldRequestedPickupAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedPickupAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedPickupAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedPickupAt: %w", err)
	}
	return oldValue.RequestedPickupAt, nil
}

// ClearRequestedPickupAt clears the value of the "requested_pickup_at" field.
func (m *PickupOrderMutation) ClearRequestedPickupAt() {
	m.requested_pickup_at = nil
	m.clearedFields[pickuporder.FieldRequestedPickupAt] = struct{}{}
}

// RequestedPickupAtCleared returns if the "requested_pickup_at" field was cleared in this mutation.
func (m *PickupOrderMutation) RequestedPickupAtCleared() bool {
	_, ok := m.clearedFields[pickuporder.FieldRequestedPickupAt]
	return ok
}

// ResetRequestedPickupAt resets all changes to the "requested_pickup_at" field.
func (m *PickupOrderMutation) ResetRequestedPickupAt() {
	m.requested_pickup_at = nil
	delete(m.clearedFields, pickuporder.FieldRequestedPickupAt)
}

// SetStatus sets the "status" field.
func (m *PickupOrderMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PickupOrderMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PickupOrder entity.
// If the PickupOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *PickupOrderMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PickupOrderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PickupOrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSenderAddressInfo sets the "sender_address_info" field.
func (m *PickupOrderMutation) SetSenderAddressInfo(s string) {
	m.sender_address_info = &s
}

// SenderAddressInfo returns the value of the "sender_address_info" field in the mutation.
func (m *PickupOrderMutation) SenderAddressInfo() (r string, exists bool) {
	v := m.sender_address_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderAddressInfo returns the old "sender_address_info" field's value of the PickupOrder entity.
// If the PickupOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderMutation) OldSenderAddressInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderAddressInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderAddressInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderAddressInfo: %w", err)
	}
	return oldValue.SenderAddressInfo, nil
}

// ClearSenderAddressInfo clears the value of the "sender_address_info" field.
func (m *PickupOrderMutation) ClearSenderAddressInfo() {
	m.sender_address_info = nil
	m.clearedFields[pickuporder.FieldSenderAddressInfo] = struct{}{}
}

// SenderAddressInfoCleared returns if the "sender_address_info" field was cleared in this mutation.
func (m *PickupOrderMutation) SenderAddressInfoCleared() bool {
	_, ok := m.clearedFields[pickuporder.FieldSenderAddressInfo]
	return ok
}

// ResetSenderAddressInfo resets all changes to the "sender_address_info" field.
func (m *PickupOrderMutation) ResetSenderAddressInfo() {
	m.sender_address_info = nil
	delete(m.clearedFields, pickuporder.FieldSenderAddressInfo)
}

// Where appends a list predicates to the PickupOrderMutation builder.
func (m *PickupOrderMutation) Where(ps ...predicate.PickupOrder) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PickupOrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PickupOrder).
func (m *PickupOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PickupOrderMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pickuporder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pickuporder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pickuporder.FieldDeletedAt)
	}
	if m.requested_pickup_at != nil {
		fields = append(fields, pickuporder.FieldRequestedPickupAt)
	}
	if m.status != nil {
		fields = append(fields, pickuporder.FieldStatus)
	}
	if m.sender_address_info != nil {
		fields = append(fields, pickuporder.FieldSenderAddressInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PickupOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pickuporder.FieldCreatedAt:
		return m.CreatedAt()
	case pickuporder.FieldUpdatedAt:
		return m.UpdatedAt()
	case pickuporder.FieldDeletedAt:
		return m.DeletedAt()
	case pickuporder.FieldRequestedPickupAt:
		return m.RequestedPickupAt()
	case pickuporder.FieldStatus:
		return m.Status()
	case pickuporder.FieldSenderAddressInfo:
		return m.SenderAddressInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PickupOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pickuporder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pickuporder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pickuporder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pickuporder.FieldRequestedPickupAt:
		return m.OldRequestedPickupAt(ctx)
	case pickuporder.FieldStatus:
		return m.OldStatus(ctx)
	case pickuporder.FieldSenderAddressInfo:
		return m.OldSenderAddressInfo(ctx)
	}
	return nil, fmt.Errorf("unknown PickupOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PickupOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pickuporder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pickuporder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pickuporder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pickuporder.FieldRequestedPickupAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedPickupAt(v)
		return nil
	case pickuporder.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case pickuporder.FieldSenderAddressInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderAddressInfo(v)
		return nil
	}
	return fmt.Errorf("unknown PickupOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PickupOrderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, pickuporder.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PickupOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pickuporder.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PickupOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pickuporder.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PickupOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PickupOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pickuporder.FieldDeletedAt) {
		fields = append(fields, pickuporder.FieldDeletedAt)
	}
	if m.FieldCleared(pickuporder.FieldRequestedPickupAt) {
		fields = append(fields, pickuporder.FieldRequestedPickupAt)
	}
	if m.FieldCleared(pickuporder.FieldSenderAddressInfo) {
		fields = append(fields, pickuporder.FieldSenderAddressInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PickupOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PickupOrderMutation) ClearField(name string) error {
	switch name {
	case pickuporder.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case pickuporder.FieldRequestedPickupAt:
		m.ClearRequestedPickupAt()
		return nil
	case pickuporder.FieldSenderAddressInfo:
		m.ClearSenderAddressInfo()
		return nil
	}
	return fmt.Errorf("unknown PickupOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PickupOrderMutation) ResetField(name string) error {
	switch name {
	case pickuporder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pickuporder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pickuporder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pickuporder.FieldRequestedPickupAt:
		m.ResetRequestedPickupAt()
		return nil
	case pickuporder.FieldStatus:
		m.ResetStatus()
		return nil
	case pickuporder.FieldSenderAddressInfo:
		m.ResetSenderAddressInfo()
		return nil
	}
	return fmt.Errorf("unknown PickupOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PickupOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PickupOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PickupOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PickupOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PickupOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PickupOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PickupOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PickupOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PickupOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PickupOrder edge %s", name)
}

// PickupOrderItemMutation represents an operation that mutates the PickupOrderItem nodes in the graph.
type PickupOrderItemMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	pickup_order_id    *int64
	addpickup_order_id *int64
	product_id         *int64
	addproduct_id      *int64
	product_name       *string
	sku                *string
	barcode            *string
	qty                *int32
	addqty             *int32
	customer_code      *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*PickupOrderItem, error)
	predicates         []predicate.PickupOrderItem
}

var _ ent.Mutation = (*PickupOrderItemMutation)(nil)

// pickuporderitemOption allows management of the mutation configuration using functional options.
type pickuporderitemOption func(*PickupOrderItemMutation)

// newPickupOrderItemMutation creates new mutation for the PickupOrderItem entity.
func newPickupOrderItemMutation(c config, op Op, opts ...pickuporderitemOption) *PickupOrderItemMutation {
	m := &PickupOrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypePickupOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPickupOrderItemID sets the ID field of the mutation.
func withPickupOrderItemID(id int64) pickuporderitemOption {
	return func(m *PickupOrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *PickupOrderItem
		)
		m.oldValue = func(ctx context.Context) (*PickupOrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PickupOrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPickupOrderItem sets the old PickupOrderItem of the mutation.
func withPickupOrderItem(node *PickupOrderItem) pickuporderitemOption {
	return func(m *PickupOrderItemMutation) {
		m.oldValue = func(context.Context) (*PickupOrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PickupOrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PickupOrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PickupOrderItem entities.
func (m *PickupOrderItemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PickupOrderItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PickupOrderItemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PickupOrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PickupOrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PickupOrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PickupOrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PickupOrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PickupOrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PickupOrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PickupOrderItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PickupOrderItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PickupOrderItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pickuporderitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PickupOrderItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pickuporderitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PickupOrderItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pickuporderitem.FieldDeletedAt)
}

// SetPickupOrderID sets the "pickup_order_id" field.
func (m *PickupOrderItemMutation) SetPickupOrderID(i int64) {
	m.pickup_order_id = &i
	m.addpickup_order_id = nil
}

// PickupOrderID returns the value of the "pickup_order_id" field in the mutation.
func (m *PickupOrderItemMutation) PickupOrderID() (r int64, exists bool) {
	v := m.pickup_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupOrderID returns the old "pickup_order_id" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldPickupOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupOrderID: %w", err)
	}
	return oldValue.PickupOrderID, nil
}

// AddPickupOrderID adds i to the "pickup_order_id" field.
func (m *PickupOrderItemMutation) AddPickupOrderID(i int64) {
	if m.addpickup_order_id != nil {
		*m.addpickup_order_id += i
	} else {
		m.addpickup_order_id = &i
	}
}

// AddedPickupOrderID returns the value that was added to the "pickup_order_id" field in this mutation.
func (m *PickupOrderItemMutation) AddedPickupOrderID() (r int64, exists bool) {
	v := m.addpickup_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPickupOrderID resets all changes to the "pickup_order_id" field.
func (m *PickupOrderItemMutation) ResetPickupOrderID() {
	m.pickup_order_id = nil
	m.addpickup_order_id = nil
}

// SetProductID sets the "product_id" field.
func (m *PickupOrderItemMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *PickupOrderItemMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *PickupOrderItemMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *PickupOrderItemMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *PickupOrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetProductName sets the "product_name" field.
func (m *PickupOrderItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *PickupOrderItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *PickupOrderItemMutation) ResetProductName() {
	m.product_name = nil
}

// SetSku sets the "sku" field.
func (m *PickupOrderItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *PickupOrderItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *PickupOrderItemMutation) ResetSku() {
	m.sku = nil
}

// SetBarcode sets the "barcode" field.
func (m *PickupOrderItemMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *PickupOrderItemMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *PickupOrderItemMutation) ResetBarcode() {
	m.barcode = nil
}

// SetQty sets the "qty" field.
func (m *PickupOrderItemMutation) SetQty(i int32) {
	m.qty = &i
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *PickupOrderItemMutation) Qty() (r int32, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldQty(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds i to the "qty" field.
func (m *PickupOrderItemMutation) AddQty(i int32) {
	if m.addqty != nil {
		*m.addqty += i
	} else {
		m.addqty = &i
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *PickupOrderItemMutation) AddedQty() (r int32, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *PickupOrderItemMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetCustomerCode sets the "customer_code" field.
func (m *PickupOrderItemMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *PickupOrderItemMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the PickupOrderItem entity.
// If the PickupOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupOrderItemMutation) OldCustomerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *PickupOrderItemMutation) ResetCustomerCode() {
	m.customer_code = nil
}

// Where appends a list predicates to the PickupOrderItemMutation builder.
func (m *PickupOrderItemMutation) Where(ps ...predicate.PickupOrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PickupOrderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PickupOrderItem).
func (m *PickupOrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PickupOrderItemMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, pickuporderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pickuporderitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pickuporderitem.FieldDeletedAt)
	}
	if m.pickup_order_id != nil {
		fields = append(fields, pickuporderitem.FieldPickupOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, pickuporderitem.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, pickuporderitem.FieldProductName)
	}
	if m.sku != nil {
		fields = append(fields, pickuporderitem.FieldSku)
	}
	if m.barcode != nil {
		fields = append(fields, pickuporderitem.FieldBarcode)
	}
	if m.qty != nil {
		fields = append(fields, pickuporderitem.FieldQty)
	}
	if m.customer_code != nil {
		fields = append(fields, pickuporderitem.FieldCustomerCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PickupOrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pickuporderitem.FieldCreatedAt:
		return m.CreatedAt()
	case pickuporderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case pickuporderitem.FieldDeletedAt:
		return m.DeletedAt()
	case pickuporderitem.FieldPickupOrderID:
		return m.PickupOrderID()
	case pickuporderitem.FieldProductID:
		return m.ProductID()
	case pickuporderitem.FieldProductName:
		return m.ProductName()
	case pickuporderitem.FieldSku:
		return m.Sku()
	case pickuporderitem.FieldBarcode:
		return m.Barcode()
	case pickuporderitem.FieldQty:
		return m.Qty()
	case pickuporderitem.FieldCustomerCode:
		return m.CustomerCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PickupOrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pickuporderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pickuporderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pickuporderitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pickuporderitem.FieldPickupOrderID:
		return m.OldPickupOrderID(ctx)
	case pickuporderitem.FieldProductID:
		return m.OldProductID(ctx)
	case pickuporderitem.FieldProductName:
		return m.OldProductName(ctx)
	case pickuporderitem.FieldSku:
		return m.OldSku(ctx)
	case pickuporderitem.FieldBarcode:
		return m.OldBarcode(ctx)
	case pickuporderitem.FieldQty:
		return m.OldQty(ctx)
	case pickuporderitem.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	}
	return nil, fmt.Errorf("unknown PickupOrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PickupOrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pickuporderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pickuporderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pickuporderitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pickuporderitem.FieldPickupOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupOrderID(v)
		return nil
	case pickuporderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case pickuporderitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case pickuporderitem.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case pickuporderitem.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case pickuporderitem.FieldQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case pickuporderitem.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	}
	return fmt.Errorf("unknown PickupOrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PickupOrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addpickup_order_id != nil {
		fields = append(fields, pickuporderitem.FieldPickupOrderID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, pickuporderitem.FieldProductID)
	}
	if m.addqty != nil {
		fields = append(fields, pickuporderitem.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PickupOrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pickuporderitem.FieldPickupOrderID:
		return m.AddedPickupOrderID()
	case pickuporderitem.FieldProductID:
		return m.AddedProductID()
	case pickuporderitem.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PickupOrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pickuporderitem.FieldPickupOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPickupOrderID(v)
		return nil
	case pickuporderitem.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case pickuporderitem.FieldQty:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown PickupOrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PickupOrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pickuporderitem.FieldDeletedAt) {
		fields = append(fields, pickuporderitem.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PickupOrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PickupOrderItemMutation) ClearField(name string) error {
	switch name {
	case pickuporderitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PickupOrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PickupOrderItemMutation) ResetField(name string) error {
	switch name {
	case pickuporderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pickuporderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pickuporderitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pickuporderitem.FieldPickupOrderID:
		m.ResetPickupOrderID()
		return nil
	case pickuporderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case pickuporderitem.FieldProductName:
		m.ResetProductName()
		return nil
	case pickuporderitem.FieldSku:
		m.ResetSku()
		return nil
	case pickuporderitem.FieldBarcode:
		m.ResetBarcode()
		return nil
	case pickuporderitem.FieldQty:
		m.ResetQty()
		return nil
	case pickuporderitem.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	}
	return fmt.Errorf("unknown PickupOrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PickupOrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PickupOrderItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PickupOrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PickupOrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PickupOrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PickupOrderItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PickupOrderItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PickupOrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PickupOrderItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PickupOrderItem edge %s", name)
}

// PlatformProductMutation represents an operation that mutates the PlatformProduct nodes in the graph.
type PlatformProductMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	listing_id              *string
	collection_id           *string
	listing_sku             *string
	barcode                 *string
	name                    *string
	images                  *string
	vendor                  *string
	selling_price           *float64
	addselling_price        *float64
	currency                *string
	grams                   *int
	addgrams                *int
	platform_status         *int8
	addplatform_status      *int8
	clearedFields           map[string]struct{}
	tenant                  *int64
	clearedtenant           bool
	product_mappings        map[int64]struct{}
	removedproduct_mappings map[int64]struct{}
	clearedproduct_mappings bool
	stores                  *int64
	clearedstores           bool
	done                    bool
	oldValue                func(context.Context) (*PlatformProduct, error)
	predicates              []predicate.PlatformProduct
}

var _ ent.Mutation = (*PlatformProductMutation)(nil)

// platformproductOption allows management of the mutation configuration using functional options.
type platformproductOption func(*PlatformProductMutation)

// newPlatformProductMutation creates new mutation for the PlatformProduct entity.
func newPlatformProductMutation(c config, op Op, opts ...platformproductOption) *PlatformProductMutation {
	m := &PlatformProductMutation{
		config:        c,
		op:            op,
		typ:           TypePlatformProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlatformProductID sets the ID field of the mutation.
func withPlatformProductID(id int64) platformproductOption {
	return func(m *PlatformProductMutation) {
		var (
			err   error
			once  sync.Once
			value *PlatformProduct
		)
		m.oldValue = func(ctx context.Context) (*PlatformProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlatformProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlatformProduct sets the old PlatformProduct of the mutation.
func withPlatformProduct(node *PlatformProduct) platformproductOption {
	return func(m *PlatformProductMutation) {
		m.oldValue = func(context.Context) (*PlatformProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlatformProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlatformProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlatformProduct entities.
func (m *PlatformProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlatformProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlatformProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlatformProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlatformProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlatformProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlatformProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlatformProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlatformProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlatformProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlatformProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlatformProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlatformProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[platformproduct.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlatformProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[platformproduct.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlatformProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, platformproduct.FieldDeletedAt)
}

// SetStoreID sets the "store_id" field.
func (m *PlatformProductMutation) SetStoreID(i int64) {
	m.stores = &i
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *PlatformProductMutation) StoreID() (r int64, exists bool) {
	v := m.stores
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldStoreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *PlatformProductMutation) ClearStoreID() {
	m.stores = nil
	m.clearedFields[platformproduct.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *PlatformProductMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[platformproduct.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *PlatformProductMutation) ResetStoreID() {
	m.stores = nil
	delete(m.clearedFields, platformproduct.FieldStoreID)
}

// SetListingID sets the "listing_id" field.
func (m *PlatformProductMutation) SetListingID(s string) {
	m.listing_id = &s
}

// ListingID returns the value of the "listing_id" field in the mutation.
func (m *PlatformProductMutation) ListingID() (r string, exists bool) {
	v := m.listing_id
	if v == nil {
		return
	}
	return *v, true
}

// OldListingID returns the old "listing_id" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldListingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListingID: %w", err)
	}
	return oldValue.ListingID, nil
}

// ResetListingID resets all changes to the "listing_id" field.
func (m *PlatformProductMutation) ResetListingID() {
	m.listing_id = nil
}

// SetCollectionID sets the "collection_id" field.
func (m *PlatformProductMutation) SetCollectionID(s string) {
	m.collection_id = &s
}

// CollectionID returns the value of the "collection_id" field in the mutation.
func (m *PlatformProductMutation) CollectionID() (r string, exists bool) {
	v := m.collection_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCollectionID returns the old "collection_id" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldCollectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollectionID: %w", err)
	}
	return oldValue.CollectionID, nil
}

// ResetCollectionID resets all changes to the "collection_id" field.
func (m *PlatformProductMutation) ResetCollectionID() {
	m.collection_id = nil
}

// SetListingSku sets the "listing_sku" field.
func (m *PlatformProductMutation) SetListingSku(s string) {
	m.listing_sku = &s
}

// ListingSku returns the value of the "listing_sku" field in the mutation.
func (m *PlatformProductMutation) ListingSku() (r string, exists bool) {
	v := m.listing_sku
	if v == nil {
		return
	}
	return *v, true
}

// OldListingSku returns the old "listing_sku" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldListingSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListingSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListingSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListingSku: %w", err)
	}
	return oldValue.ListingSku, nil
}

// ResetListingSku resets all changes to the "listing_sku" field.
func (m *PlatformProductMutation) ResetListingSku() {
	m.listing_sku = nil
}

// SetBarcode sets the "barcode" field.
func (m *PlatformProductMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *PlatformProductMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *PlatformProductMutation) ResetBarcode() {
	m.barcode = nil
}

// SetName sets the "name" field.
func (m *PlatformProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlatformProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlatformProductMutation) ResetName() {
	m.name = nil
}

// SetImages sets the "images" field.
func (m *PlatformProductMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *PlatformProductMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *PlatformProductMutation) ClearImages() {
	m.images = nil
	m.clearedFields[platformproduct.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *PlatformProductMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[platformproduct.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *PlatformProductMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, platformproduct.FieldImages)
}

// SetVendor sets the "vendor" field.
func (m *PlatformProductMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *PlatformProductMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ClearVendor clears the value of the "vendor" field.
func (m *PlatformProductMutation) ClearVendor() {
	m.vendor = nil
	m.clearedFields[platformproduct.FieldVendor] = struct{}{}
}

// VendorCleared returns if the "vendor" field was cleared in this mutation.
func (m *PlatformProductMutation) VendorCleared() bool {
	_, ok := m.clearedFields[platformproduct.FieldVendor]
	return ok
}

// ResetVendor resets all changes to the "vendor" field.
func (m *PlatformProductMutation) ResetVendor() {
	m.vendor = nil
	delete(m.clearedFields, platformproduct.FieldVendor)
}

// SetSellingPrice sets the "selling_price" field.
func (m *PlatformProductMutation) SetSellingPrice(f float64) {
	m.selling_price = &f
	m.addselling_price = nil
}

// SellingPrice returns the value of the "selling_price" field in the mutation.
func (m *PlatformProductMutation) SellingPrice() (r float64, exists bool) {
	v := m.selling_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSellingPrice returns the old "selling_price" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldSellingPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellingPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellingPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellingPrice: %w", err)
	}
	return oldValue.SellingPrice, nil
}

// AddSellingPrice adds f to the "selling_price" field.
func (m *PlatformProductMutation) AddSellingPrice(f float64) {
	if m.addselling_price != nil {
		*m.addselling_price += f
	} else {
		m.addselling_price = &f
	}
}

// AddedSellingPrice returns the value that was added to the "selling_price" field in this mutation.
func (m *PlatformProductMutation) AddedSellingPrice() (r float64, exists bool) {
	v := m.addselling_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetSellingPrice resets all changes to the "selling_price" field.
func (m *PlatformProductMutation) ResetSellingPrice() {
	m.selling_price = nil
	m.addselling_price = nil
}

// SetCurrency sets the "currency" field.
func (m *PlatformProductMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PlatformProductMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PlatformProductMutation) ResetCurrency() {
	m.currency = nil
}

// SetGrams sets the "grams" field.
func (m *PlatformProductMutation) SetGrams(i int) {
	m.grams = &i
	m.addgrams = nil
}

// Grams returns the value of the "grams" field in the mutation.
func (m *PlatformProductMutation) Grams() (r int, exists bool) {
	v := m.grams
	if v == nil {
		return
	}
	return *v, true
}

// OldGrams returns the old "grams" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldGrams(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrams: %w", err)
	}
	return oldValue.Grams, nil
}

// AddGrams adds i to the "grams" field.
func (m *PlatformProductMutation) AddGrams(i int) {
	if m.addgrams != nil {
		*m.addgrams += i
	} else {
		m.addgrams = &i
	}
}

// AddedGrams returns the value that was added to the "grams" field in this mutation.
func (m *PlatformProductMutation) AddedGrams() (r int, exists bool) {
	v := m.addgrams
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrams resets all changes to the "grams" field.
func (m *PlatformProductMutation) ResetGrams() {
	m.grams = nil
	m.addgrams = nil
}

// SetPlatformStatus sets the "platform_status" field.
func (m *PlatformProductMutation) SetPlatformStatus(i int8) {
	m.platform_status = &i
	m.addplatform_status = nil
}

// PlatformStatus returns the value of the "platform_status" field in the mutation.
func (m *PlatformProductMutation) PlatformStatus() (r int8, exists bool) {
	v := m.platform_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformStatus returns the old "platform_status" field's value of the PlatformProduct entity.
// If the PlatformProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlatformProductMutation) OldPlatformStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformStatus: %w", err)
	}
	return oldValue.PlatformStatus, nil
}

// AddPlatformStatus adds i to the "platform_status" field.
func (m *PlatformProductMutation) AddPlatformStatus(i int8) {
	if m.addplatform_status != nil {
		*m.addplatform_status += i
	} else {
		m.addplatform_status = &i
	}
}

// AddedPlatformStatus returns the value that was added to the "platform_status" field in this mutation.
func (m *PlatformProductMutation) AddedPlatformStatus() (r int8, exists bool) {
	v := m.addplatform_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlatformStatus resets all changes to the "platform_status" field.
func (m *PlatformProductMutation) ResetPlatformStatus() {
	m.platform_status = nil
	m.addplatform_status = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *PlatformProductMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PlatformProductMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PlatformProductMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *PlatformProductMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PlatformProductMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PlatformProductMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddProductMappingIDs adds the "product_mappings" edge to the ProductMapping entity by ids.
func (m *PlatformProductMutation) AddProductMappingIDs(ids ...int64) {
	if m.product_mappings == nil {
		m.product_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		m.product_mappings[ids[i]] = struct{}{}
	}
}

// ClearProductMappings clears the "product_mappings" edge to the ProductMapping entity.
func (m *PlatformProductMutation) ClearProductMappings() {
	m.clearedproduct_mappings = true
}

// ProductMappingsCleared reports if the "product_mappings" edge to the ProductMapping entity was cleared.
func (m *PlatformProductMutation) ProductMappingsCleared() bool {
	return m.clearedproduct_mappings
}

// RemoveProductMappingIDs removes the "product_mappings" edge to the ProductMapping entity by IDs.
func (m *PlatformProductMutation) RemoveProductMappingIDs(ids ...int64) {
	if m.removedproduct_mappings == nil {
		m.removedproduct_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.product_mappings, ids[i])
		m.removedproduct_mappings[ids[i]] = struct{}{}
	}
}

// RemovedProductMappings returns the removed IDs of the "product_mappings" edge to the ProductMapping entity.
func (m *PlatformProductMutation) RemovedProductMappingsIDs() (ids []int64) {
	for id := range m.removedproduct_mappings {
		ids = append(ids, id)
	}
	return
}

// ProductMappingsIDs returns the "product_mappings" edge IDs in the mutation.
func (m *PlatformProductMutation) ProductMappingsIDs() (ids []int64) {
	for id := range m.product_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetProductMappings resets all changes to the "product_mappings" edge.
func (m *PlatformProductMutation) ResetProductMappings() {
	m.product_mappings = nil
	m.clearedproduct_mappings = false
	m.removedproduct_mappings = nil
}

// SetStoresID sets the "stores" edge to the Store entity by id.
func (m *PlatformProductMutation) SetStoresID(id int64) {
	m.stores = &id
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *PlatformProductMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *PlatformProductMutation) StoresCleared() bool {
	return m.StoreIDCleared() || m.clearedstores
}

// StoresID returns the "stores" edge ID in the mutation.
func (m *PlatformProductMutation) StoresID() (id int64, exists bool) {
	if m.stores != nil {
		return *m.stores, true
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoresID instead. It exists only for internal usage by the builders.
func (m *PlatformProductMutation) StoresIDs() (ids []int64) {
	if id := m.stores; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *PlatformProductMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
}

// Where appends a list predicates to the PlatformProductMutation builder.
func (m *PlatformProductMutation) Where(ps ...predicate.PlatformProduct) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlatformProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PlatformProduct).
func (m *PlatformProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlatformProductMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, platformproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, platformproduct.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, platformproduct.FieldDeletedAt)
	}
	if m.stores != nil {
		fields = append(fields, platformproduct.FieldStoreID)
	}
	if m.listing_id != nil {
		fields = append(fields, platformproduct.FieldListingID)
	}
	if m.collection_id != nil {
		fields = append(fields, platformproduct.FieldCollectionID)
	}
	if m.listing_sku != nil {
		fields = append(fields, platformproduct.FieldListingSku)
	}
	if m.barcode != nil {
		fields = append(fields, platformproduct.FieldBarcode)
	}
	if m.name != nil {
		fields = append(fields, platformproduct.FieldName)
	}
	if m.images != nil {
		fields = append(fields, platformproduct.FieldImages)
	}
	if m.vendor != nil {
		fields = append(fields, platformproduct.FieldVendor)
	}
	if m.selling_price != nil {
		fields = append(fields, platformproduct.FieldSellingPrice)
	}
	if m.currency != nil {
		fields = append(fields, platformproduct.FieldCurrency)
	}
	if m.grams != nil {
		fields = append(fields, platformproduct.FieldGrams)
	}
	if m.platform_status != nil {
		fields = append(fields, platformproduct.FieldPlatformStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlatformProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case platformproduct.FieldCreatedAt:
		return m.CreatedAt()
	case platformproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case platformproduct.FieldDeletedAt:
		return m.DeletedAt()
	case platformproduct.FieldStoreID:
		return m.StoreID()
	case platformproduct.FieldListingID:
		return m.ListingID()
	case platformproduct.FieldCollectionID:
		return m.CollectionID()
	case platformproduct.FieldListingSku:
		return m.ListingSku()
	case platformproduct.FieldBarcode:
		return m.Barcode()
	case platformproduct.FieldName:
		return m.Name()
	case platformproduct.FieldImages:
		return m.Images()
	case platformproduct.FieldVendor:
		return m.Vendor()
	case platformproduct.FieldSellingPrice:
		return m.SellingPrice()
	case platformproduct.FieldCurrency:
		return m.Currency()
	case platformproduct.FieldGrams:
		return m.Grams()
	case platformproduct.FieldPlatformStatus:
		return m.PlatformStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlatformProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case platformproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case platformproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case platformproduct.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case platformproduct.FieldStoreID:
		return m.OldStoreID(ctx)
	case platformproduct.FieldListingID:
		return m.OldListingID(ctx)
	case platformproduct.FieldCollectionID:
		return m.OldCollectionID(ctx)
	case platformproduct.FieldListingSku:
		return m.OldListingSku(ctx)
	case platformproduct.FieldBarcode:
		return m.OldBarcode(ctx)
	case platformproduct.FieldName:
		return m.OldName(ctx)
	case platformproduct.FieldImages:
		return m.OldImages(ctx)
	case platformproduct.FieldVendor:
		return m.OldVendor(ctx)
	case platformproduct.FieldSellingPrice:
		return m.OldSellingPrice(ctx)
	case platformproduct.FieldCurrency:
		return m.OldCurrency(ctx)
	case platformproduct.FieldGrams:
		return m.OldGrams(ctx)
	case platformproduct.FieldPlatformStatus:
		return m.OldPlatformStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PlatformProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case platformproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case platformproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case platformproduct.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case platformproduct.FieldStoreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case platformproduct.FieldListingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListingID(v)
		return nil
	case platformproduct.FieldCollectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollectionID(v)
		return nil
	case platformproduct.FieldListingSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListingSku(v)
		return nil
	case platformproduct.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case platformproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case platformproduct.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case platformproduct.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case platformproduct.FieldSellingPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellingPrice(v)
		return nil
	case platformproduct.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case platformproduct.FieldGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrams(v)
		return nil
	case platformproduct.FieldPlatformStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlatformProductMutation) AddedFields() []string {
	var fields []string
	if m.addselling_price != nil {
		fields = append(fields, platformproduct.FieldSellingPrice)
	}
	if m.addgrams != nil {
		fields = append(fields, platformproduct.FieldGrams)
	}
	if m.addplatform_status != nil {
		fields = append(fields, platformproduct.FieldPlatformStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlatformProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case platformproduct.FieldSellingPrice:
		return m.AddedSellingPrice()
	case platformproduct.FieldGrams:
		return m.AddedGrams()
	case platformproduct.FieldPlatformStatus:
		return m.AddedPlatformStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlatformProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case platformproduct.FieldSellingPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellingPrice(v)
		return nil
	case platformproduct.FieldGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrams(v)
		return nil
	case platformproduct.FieldPlatformStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlatformStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PlatformProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlatformProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(platformproduct.FieldDeletedAt) {
		fields = append(fields, platformproduct.FieldDeletedAt)
	}
	if m.FieldCleared(platformproduct.FieldStoreID) {
		fields = append(fields, platformproduct.FieldStoreID)
	}
	if m.FieldCleared(platformproduct.FieldImages) {
		fields = append(fields, platformproduct.FieldImages)
	}
	if m.FieldCleared(platformproduct.FieldVendor) {
		fields = append(fields, platformproduct.FieldVendor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlatformProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlatformProductMutation) ClearField(name string) error {
	switch name {
	case platformproduct.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case platformproduct.FieldStoreID:
		m.ClearStoreID()
		return nil
	case platformproduct.FieldImages:
		m.ClearImages()
		return nil
	case platformproduct.FieldVendor:
		m.ClearVendor()
		return nil
	}
	return fmt.Errorf("unknown PlatformProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlatformProductMutation) ResetField(name string) error {
	switch name {
	case platformproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case platformproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case platformproduct.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case platformproduct.FieldStoreID:
		m.ResetStoreID()
		return nil
	case platformproduct.FieldListingID:
		m.ResetListingID()
		return nil
	case platformproduct.FieldCollectionID:
		m.ResetCollectionID()
		return nil
	case platformproduct.FieldListingSku:
		m.ResetListingSku()
		return nil
	case platformproduct.FieldBarcode:
		m.ResetBarcode()
		return nil
	case platformproduct.FieldName:
		m.ResetName()
		return nil
	case platformproduct.FieldImages:
		m.ResetImages()
		return nil
	case platformproduct.FieldVendor:
		m.ResetVendor()
		return nil
	case platformproduct.FieldSellingPrice:
		m.ResetSellingPrice()
		return nil
	case platformproduct.FieldCurrency:
		m.ResetCurrency()
		return nil
	case platformproduct.FieldGrams:
		m.ResetGrams()
		return nil
	case platformproduct.FieldPlatformStatus:
		m.ResetPlatformStatus()
		return nil
	}
	return fmt.Errorf("unknown PlatformProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlatformProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, platformproduct.EdgeTenant)
	}
	if m.product_mappings != nil {
		edges = append(edges, platformproduct.EdgeProductMappings)
	}
	if m.stores != nil {
		edges = append(edges, platformproduct.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlatformProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case platformproduct.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case platformproduct.EdgeProductMappings:
		ids := make([]ent.Value, 0, len(m.product_mappings))
		for id := range m.product_mappings {
			ids = append(ids, id)
		}
		return ids
	case platformproduct.EdgeStores:
		if id := m.stores; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlatformProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproduct_mappings != nil {
		edges = append(edges, platformproduct.EdgeProductMappings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlatformProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case platformproduct.EdgeProductMappings:
		ids := make([]ent.Value, 0, len(m.removedproduct_mappings))
		for id := range m.removedproduct_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlatformProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, platformproduct.EdgeTenant)
	}
	if m.clearedproduct_mappings {
		edges = append(edges, platformproduct.EdgeProductMappings)
	}
	if m.clearedstores {
		edges = append(edges, platformproduct.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlatformProductMutation) EdgeCleared(name string) bool {
	switch name {
	case platformproduct.EdgeTenant:
		return m.clearedtenant
	case platformproduct.EdgeProductMappings:
		return m.clearedproduct_mappings
	case platformproduct.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlatformProductMutation) ClearEdge(name string) error {
	switch name {
	case platformproduct.EdgeTenant:
		m.ClearTenant()
		return nil
	case platformproduct.EdgeStores:
		m.ClearStores()
		return nil
	}
	return fmt.Errorf("unknown PlatformProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlatformProductMutation) ResetEdge(name string) error {
	switch name {
	case platformproduct.EdgeTenant:
		m.ResetTenant()
		return nil
	case platformproduct.EdgeProductMappings:
		m.ResetProductMappings()
		return nil
	case platformproduct.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown PlatformProduct edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	sku                      *string
	barcode                  *string
	customer_code            *string
	declared_name            *string
	declared_cn_name         *string
	declared_value_in_usd    *float64
	adddeclared_value_in_usd *float64
	declared_value_in_eur    *float64
	adddeclared_value_in_eur *float64
	currency                 *string
	hs_code                  *string
	material                 *string
	purpose                  *string
	with_barcode             *int8
	addwith_barcode          *int8
	barcode_service          *int8
	addbarcode_service       *int8
	barcode_template         *string
	images                   *string
	attributes               *string
	confirmed_attributes     *string
	grams                    *int
	addgrams                 *int
	inbound_grams            *int
	addinbound_grams         *int
	length                   *int
	addlength                *int
	width                    *int
	addwidth                 *int
	height                   *int
	addheight                *int
	max_agv_qty              *int
	addmax_agv_qty           *int
	status                   *int8
	addstatus                *int8
	created_by               *int64
	addcreated_by            *int64
	clearedFields            map[string]struct{}
	tenant                   *int64
	clearedtenant            bool
	inventories              map[int64]struct{}
	removedinventories       map[int64]struct{}
	clearedinventories       bool
	product_mappings         map[int64]struct{}
	removedproduct_mappings  map[int64]struct{}
	clearedproduct_mappings  bool
	done                     bool
	oldValue                 func(context.Context) (*Product, error)
	predicates               []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int64) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[product.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, product.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetBarcode sets the "barcode" field.
func (m *ProductMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *ProductMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *ProductMutation) ResetBarcode() {
	m.barcode = nil
}

// SetCustomerCode sets the "customer_code" field.
func (m *ProductMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *ProductMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCustomerCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *ProductMutation) ResetCustomerCode() {
	m.customer_code = nil
}

// SetDeclaredName sets the "declared_name" field.
func (m *ProductMutation) SetDeclaredName(s string) {
	m.declared_name = &s
}

// DeclaredName returns the value of the "declared_name" field in the mutation.
func (m *ProductMutation) DeclaredName() (r string, exists bool) {
	v := m.declared_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredName returns the old "declared_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeclaredName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredName: %w", err)
	}
	return oldValue.DeclaredName, nil
}

// ClearDeclaredName clears the value of the "declared_name" field.
func (m *ProductMutation) ClearDeclaredName() {
	m.declared_name = nil
	m.clearedFields[product.FieldDeclaredName] = struct{}{}
}

// DeclaredNameCleared returns if the "declared_name" field was cleared in this mutation.
func (m *ProductMutation) DeclaredNameCleared() bool {
	_, ok := m.clearedFields[product.FieldDeclaredName]
	return ok
}

// ResetDeclaredName resets all changes to the "declared_name" field.
func (m *ProductMutation) ResetDeclaredName() {
	m.declared_name = nil
	delete(m.clearedFields, product.FieldDeclaredName)
}

// SetDeclaredCnName sets the "declared_cn_name" field.
func (m *ProductMutation) SetDeclaredCnName(s string) {
	m.declared_cn_name = &s
}

// DeclaredCnName returns the value of the "declared_cn_name" field in the mutation.
func (m *ProductMutation) DeclaredCnName() (r string, exists bool) {
	v := m.declared_cn_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredCnName returns the old "declared_cn_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeclaredCnName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredCnName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredCnName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredCnName: %w", err)
	}
	return oldValue.DeclaredCnName, nil
}

// ClearDeclaredCnName clears the value of the "declared_cn_name" field.
func (m *ProductMutation) ClearDeclaredCnName() {
	m.declared_cn_name = nil
	m.clearedFields[product.FieldDeclaredCnName] = struct{}{}
}

// DeclaredCnNameCleared returns if the "declared_cn_name" field was cleared in this mutation.
func (m *ProductMutation) DeclaredCnNameCleared() bool {
	_, ok := m.clearedFields[product.FieldDeclaredCnName]
	return ok
}

// ResetDeclaredCnName resets all changes to the "declared_cn_name" field.
func (m *ProductMutation) ResetDeclaredCnName() {
	m.declared_cn_name = nil
	delete(m.clearedFields, product.FieldDeclaredCnName)
}

// SetDeclaredValueInUsd sets the "declared_value_in_usd" field.
func (m *ProductMutation) SetDeclaredValueInUsd(f float64) {
	m.declared_value_in_usd = &f
	m.adddeclared_value_in_usd = nil
}

// DeclaredValueInUsd returns the value of the "declared_value_in_usd" field in the mutation.
func (m *ProductMutation) DeclaredValueInUsd() (r float64, exists bool) {
	v := m.declared_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredValueInUsd returns the old "declared_value_in_usd" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeclaredValueInUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredValueInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredValueInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredValueInUsd: %w", err)
	}
	return oldValue.DeclaredValueInUsd, nil
}

// AddDeclaredValueInUsd adds f to the "declared_value_in_usd" field.
func (m *ProductMutation) AddDeclaredValueInUsd(f float64) {
	if m.adddeclared_value_in_usd != nil {
		*m.adddeclared_value_in_usd += f
	} else {
		m.adddeclared_value_in_usd = &f
	}
}

// AddedDeclaredValueInUsd returns the value that was added to the "declared_value_in_usd" field in this mutation.
func (m *ProductMutation) AddedDeclaredValueInUsd() (r float64, exists bool) {
	v := m.adddeclared_value_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeclaredValueInUsd resets all changes to the "declared_value_in_usd" field.
func (m *ProductMutation) ResetDeclaredValueInUsd() {
	m.declared_value_in_usd = nil
	m.adddeclared_value_in_usd = nil
}

// SetDeclaredValueInEur sets the "declared_value_in_eur" field.
func (m *ProductMutation) SetDeclaredValueInEur(f float64) {
	m.declared_value_in_eur = &f
	m.adddeclared_value_in_eur = nil
}

// DeclaredValueInEur returns the value of the "declared_value_in_eur" field in the mutation.
func (m *ProductMutation) DeclaredValueInEur() (r float64, exists bool) {
	v := m.declared_value_in_eur
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclaredValueInEur returns the old "declared_value_in_eur" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDeclaredValueInEur(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclaredValueInEur is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclaredValueInEur requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclaredValueInEur: %w", err)
	}
	return oldValue.DeclaredValueInEur, nil
}

// AddDeclaredValueInEur adds f to the "declared_value_in_eur" field.
func (m *ProductMutation) AddDeclaredValueInEur(f float64) {
	if m.adddeclared_value_in_eur != nil {
		*m.adddeclared_value_in_eur += f
	} else {
		m.adddeclared_value_in_eur = &f
	}
}

// AddedDeclaredValueInEur returns the value that was added to the "declared_value_in_eur" field in this mutation.
func (m *ProductMutation) AddedDeclaredValueInEur() (r float64, exists bool) {
	v := m.adddeclared_value_in_eur
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeclaredValueInEur resets all changes to the "declared_value_in_eur" field.
func (m *ProductMutation) ResetDeclaredValueInEur() {
	m.declared_value_in_eur = nil
	m.adddeclared_value_in_eur = nil
}

// SetCurrency sets the "currency" field.
func (m *ProductMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ProductMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ProductMutation) ResetCurrency() {
	m.currency = nil
}

// SetHsCode sets the "hs_code" field.
func (m *ProductMutation) SetHsCode(s string) {
	m.hs_code = &s
}

// HsCode returns the value of the "hs_code" field in the mutation.
func (m *ProductMutation) HsCode() (r string, exists bool) {
	v := m.hs_code
	if v == nil {
		return
	}
	return *v, true
}

// OldHsCode returns the old "hs_code" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldHsCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHsCode: %w", err)
	}
	return oldValue.HsCode, nil
}

// ResetHsCode resets all changes to the "hs_code" field.
func (m *ProductMutation) ResetHsCode() {
	m.hs_code = nil
}

// SetMaterial sets the "material" field.
func (m *ProductMutation) SetMaterial(s string) {
	m.material = &s
}

// Material returns the value of the "material" field in the mutation.
func (m *ProductMutation) Material() (r string, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMaterial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ResetMaterial resets all changes to the "material" field.
func (m *ProductMutation) ResetMaterial() {
	m.material = nil
}

// SetPurpose sets the "purpose" field.
func (m *ProductMutation) SetPurpose(s string) {
	m.purpose = &s
}

// Purpose returns the value of the "purpose" field in the mutation.
func (m *ProductMutation) Purpose() (r string, exists bool) {
	v := m.purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPurpose returns the old "purpose" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurpose: %w", err)
	}
	return oldValue.Purpose, nil
}

// ResetPurpose resets all changes to the "purpose" field.
func (m *ProductMutation) ResetPurpose() {
	m.purpose = nil
}

// SetWithBarcode sets the "with_barcode" field.
func (m *ProductMutation) SetWithBarcode(i int8) {
	m.with_barcode = &i
	m.addwith_barcode = nil
}

// WithBarcode returns the value of the "with_barcode" field in the mutation.
func (m *ProductMutation) WithBarcode() (r int8, exists bool) {
	v := m.with_barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldWithBarcode returns the old "with_barcode" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWithBarcode(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithBarcode: %w", err)
	}
	return oldValue.WithBarcode, nil
}

// AddWithBarcode adds i to the "with_barcode" field.
func (m *ProductMutation) AddWithBarcode(i int8) {
	if m.addwith_barcode != nil {
		*m.addwith_barcode += i
	} else {
		m.addwith_barcode = &i
	}
}

// AddedWithBarcode returns the value that was added to the "with_barcode" field in this mutation.
func (m *ProductMutation) AddedWithBarcode() (r int8, exists bool) {
	v := m.addwith_barcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithBarcode resets all changes to the "with_barcode" field.
func (m *ProductMutation) ResetWithBarcode() {
	m.with_barcode = nil
	m.addwith_barcode = nil
}

// SetBarcodeService sets the "barcode_service" field.
func (m *ProductMutation) SetBarcodeService(i int8) {
	m.barcode_service = &i
	m.addbarcode_service = nil
}

// BarcodeService returns the value of the "barcode_service" field in the mutation.
func (m *ProductMutation) BarcodeService() (r int8, exists bool) {
	v := m.barcode_service
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcodeService returns the old "barcode_service" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBarcodeService(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcodeService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcodeService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcodeService: %w", err)
	}
	return oldValue.BarcodeService, nil
}

// AddBarcodeService adds i to the "barcode_service" field.
func (m *ProductMutation) AddBarcodeService(i int8) {
	if m.addbarcode_service != nil {
		*m.addbarcode_service += i
	} else {
		m.addbarcode_service = &i
	}
}

// AddedBarcodeService returns the value that was added to the "barcode_service" field in this mutation.
func (m *ProductMutation) AddedBarcodeService() (r int8, exists bool) {
	v := m.addbarcode_service
	if v == nil {
		return
	}
	return *v, true
}

// ResetBarcodeService resets all changes to the "barcode_service" field.
func (m *ProductMutation) ResetBarcodeService() {
	m.barcode_service = nil
	m.addbarcode_service = nil
}

// SetBarcodeTemplate sets the "barcode_template" field.
func (m *ProductMutation) SetBarcodeTemplate(s string) {
	m.barcode_template = &s
}

// BarcodeTemplate returns the value of the "barcode_template" field in the mutation.
func (m *ProductMutation) BarcodeTemplate() (r string, exists bool) {
	v := m.barcode_template
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcodeTemplate returns the old "barcode_template" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBarcodeTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcodeTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcodeTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcodeTemplate: %w", err)
	}
	return oldValue.BarcodeTemplate, nil
}

// ClearBarcodeTemplate clears the value of the "barcode_template" field.
func (m *ProductMutation) ClearBarcodeTemplate() {
	m.barcode_template = nil
	m.clearedFields[product.FieldBarcodeTemplate] = struct{}{}
}

// BarcodeTemplateCleared returns if the "barcode_template" field was cleared in this mutation.
func (m *ProductMutation) BarcodeTemplateCleared() bool {
	_, ok := m.clearedFields[product.FieldBarcodeTemplate]
	return ok
}

// ResetBarcodeTemplate resets all changes to the "barcode_template" field.
func (m *ProductMutation) ResetBarcodeTemplate() {
	m.barcode_template = nil
	delete(m.clearedFields, product.FieldBarcodeTemplate)
}

// SetImages sets the "images" field.
func (m *ProductMutation) SetImages(s string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *ProductMutation) Images() (r string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *ProductMutation) ClearImages() {
	m.images = nil
	m.clearedFields[product.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *ProductMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[product.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *ProductMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, product.FieldImages)
}

// SetAttributes sets the "attributes" field.
func (m *ProductMutation) SetAttributes(s string) {
	m.attributes = &s
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ProductMutation) Attributes() (r string, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAttributes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ProductMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[product.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ProductMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[product.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ProductMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, product.FieldAttributes)
}

// SetConfirmedAttributes sets the "confirmed_attributes" field.
func (m *ProductMutation) SetConfirmedAttributes(s string) {
	m.confirmed_attributes = &s
}

// ConfirmedAttributes returns the value of the "confirmed_attributes" field in the mutation.
func (m *ProductMutation) ConfirmedAttributes() (r string, exists bool) {
	v := m.confirmed_attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedAttributes returns the old "confirmed_attributes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldConfirmedAttributes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedAttributes: %w", err)
	}
	return oldValue.ConfirmedAttributes, nil
}

// ClearConfirmedAttributes clears the value of the "confirmed_attributes" field.
func (m *ProductMutation) ClearConfirmedAttributes() {
	m.confirmed_attributes = nil
	m.clearedFields[product.FieldConfirmedAttributes] = struct{}{}
}

// ConfirmedAttributesCleared returns if the "confirmed_attributes" field was cleared in this mutation.
func (m *ProductMutation) ConfirmedAttributesCleared() bool {
	_, ok := m.clearedFields[product.FieldConfirmedAttributes]
	return ok
}

// ResetConfirmedAttributes resets all changes to the "confirmed_attributes" field.
func (m *ProductMutation) ResetConfirmedAttributes() {
	m.confirmed_attributes = nil
	delete(m.clearedFields, product.FieldConfirmedAttributes)
}

// SetGrams sets the "grams" field.
func (m *ProductMutation) SetGrams(i int) {
	m.grams = &i
	m.addgrams = nil
}

// Grams returns the value of the "grams" field in the mutation.
func (m *ProductMutation) Grams() (r int, exists bool) {
	v := m.grams
	if v == nil {
		return
	}
	return *v, true
}

// OldGrams returns the old "grams" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldGrams(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrams: %w", err)
	}
	return oldValue.Grams, nil
}

// AddGrams adds i to the "grams" field.
func (m *ProductMutation) AddGrams(i int) {
	if m.addgrams != nil {
		*m.addgrams += i
	} else {
		m.addgrams = &i
	}
}

// AddedGrams returns the value that was added to the "grams" field in this mutation.
func (m *ProductMutation) AddedGrams() (r int, exists bool) {
	v := m.addgrams
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrams resets all changes to the "grams" field.
func (m *ProductMutation) ResetGrams() {
	m.grams = nil
	m.addgrams = nil
}

// SetInboundGrams sets the "inbound_grams" field.
func (m *ProductMutation) SetInboundGrams(i int) {
	m.inbound_grams = &i
	m.addinbound_grams = nil
}

// InboundGrams returns the value of the "inbound_grams" field in the mutation.
func (m *ProductMutation) InboundGrams() (r int, exists bool) {
	v := m.inbound_grams
	if v == nil {
		return
	}
	return *v, true
}

// OldInboundGrams returns the old "inbound_grams" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldInboundGrams(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInboundGrams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInboundGrams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInboundGrams: %w", err)
	}
	return oldValue.InboundGrams, nil
}

// AddInboundGrams adds i to the "inbound_grams" field.
func (m *ProductMutation) AddInboundGrams(i int) {
	if m.addinbound_grams != nil {
		*m.addinbound_grams += i
	} else {
		m.addinbound_grams = &i
	}
}

// AddedInboundGrams returns the value that was added to the "inbound_grams" field in this mutation.
func (m *ProductMutation) AddedInboundGrams() (r int, exists bool) {
	v := m.addinbound_grams
	if v == nil {
		return
	}
	return *v, true
}

// ResetInboundGrams resets all changes to the "inbound_grams" field.
func (m *ProductMutation) ResetInboundGrams() {
	m.inbound_grams = nil
	m.addinbound_grams = nil
}

// SetLength sets the "length" field.
func (m *ProductMutation) SetLength(i int) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *ProductMutation) Length() (r int, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLength(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *ProductMutation) AddLength(i int) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *ProductMutation) AddedLength() (r int, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength resets all changes to the "length" field.
func (m *ProductMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the "width" field.
func (m *ProductMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ProductMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ProductMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ProductMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *ProductMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *ProductMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ProductMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *ProductMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ProductMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *ProductMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetMaxAgvQty sets the "max_agv_qty" field.
func (m *ProductMutation) SetMaxAgvQty(i int) {
	m.max_agv_qty = &i
	m.addmax_agv_qty = nil
}

// MaxAgvQty returns the value of the "max_agv_qty" field in the mutation.
func (m *ProductMutation) MaxAgvQty() (r int, exists bool) {
	v := m.max_agv_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAgvQty returns the old "max_agv_qty" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMaxAgvQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAgvQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAgvQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAgvQty: %w", err)
	}
	return oldValue.MaxAgvQty, nil
}

// AddMaxAgvQty adds i to the "max_agv_qty" field.
func (m *ProductMutation) AddMaxAgvQty(i int) {
	if m.addmax_agv_qty != nil {
		*m.addmax_agv_qty += i
	} else {
		m.addmax_agv_qty = &i
	}
}

// AddedMaxAgvQty returns the value that was added to the "max_agv_qty" field in this mutation.
func (m *ProductMutation) AddedMaxAgvQty() (r int, exists bool) {
	v := m.addmax_agv_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxAgvQty resets all changes to the "max_agv_qty" field.
func (m *ProductMutation) ResetMaxAgvQty() {
	m.max_agv_qty = nil
	m.addmax_agv_qty = nil
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProductMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProductMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProductMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProductMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProductMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProductMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ProductMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[product.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ProductMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProductMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, product.FieldCreatedBy)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *ProductMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *ProductMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddInventoryIDs adds the "inventories" edge to the Inventory entity by ids.
func (m *ProductMutation) AddInventoryIDs(ids ...int64) {
	if m.inventories == nil {
		m.inventories = make(map[int64]struct{})
	}
	for i := range ids {
		m.inventories[ids[i]] = struct{}{}
	}
}

// ClearInventories clears the "inventories" edge to the Inventory entity.
func (m *ProductMutation) ClearInventories() {
	m.clearedinventories = true
}

// InventoriesCleared reports if the "inventories" edge to the Inventory entity was cleared.
func (m *ProductMutation) InventoriesCleared() bool {
	return m.clearedinventories
}

// RemoveInventoryIDs removes the "inventories" edge to the Inventory entity by IDs.
func (m *ProductMutation) RemoveInventoryIDs(ids ...int64) {
	if m.removedinventories == nil {
		m.removedinventories = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.inventories, ids[i])
		m.removedinventories[ids[i]] = struct{}{}
	}
}

// RemovedInventories returns the removed IDs of the "inventories" edge to the Inventory entity.
func (m *ProductMutation) RemovedInventoriesIDs() (ids []int64) {
	for id := range m.removedinventories {
		ids = append(ids, id)
	}
	return
}

// InventoriesIDs returns the "inventories" edge IDs in the mutation.
func (m *ProductMutation) InventoriesIDs() (ids []int64) {
	for id := range m.inventories {
		ids = append(ids, id)
	}
	return
}

// ResetInventories resets all changes to the "inventories" edge.
func (m *ProductMutation) ResetInventories() {
	m.inventories = nil
	m.clearedinventories = false
	m.removedinventories = nil
}

// AddProductMappingIDs adds the "product_mappings" edge to the ProductMapping entity by ids.
func (m *ProductMutation) AddProductMappingIDs(ids ...int64) {
	if m.product_mappings == nil {
		m.product_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		m.product_mappings[ids[i]] = struct{}{}
	}
}

// ClearProductMappings clears the "product_mappings" edge to the ProductMapping entity.
func (m *ProductMutation) ClearProductMappings() {
	m.clearedproduct_mappings = true
}

// ProductMappingsCleared reports if the "product_mappings" edge to the ProductMapping entity was cleared.
func (m *ProductMutation) ProductMappingsCleared() bool {
	return m.clearedproduct_mappings
}

// RemoveProductMappingIDs removes the "product_mappings" edge to the ProductMapping entity by IDs.
func (m *ProductMutation) RemoveProductMappingIDs(ids ...int64) {
	if m.removedproduct_mappings == nil {
		m.removedproduct_mappings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.product_mappings, ids[i])
		m.removedproduct_mappings[ids[i]] = struct{}{}
	}
}

// RemovedProductMappings returns the removed IDs of the "product_mappings" edge to the ProductMapping entity.
func (m *ProductMutation) RemovedProductMappingsIDs() (ids []int64) {
	for id := range m.removedproduct_mappings {
		ids = append(ids, id)
	}
	return
}

// ProductMappingsIDs returns the "product_mappings" edge IDs in the mutation.
func (m *ProductMutation) ProductMappingsIDs() (ids []int64) {
	for id := range m.product_mappings {
		ids = append(ids, id)
	}
	return
}

// ResetProductMappings resets all changes to the "product_mappings" edge.
func (m *ProductMutation) ResetProductMappings() {
	m.product_mappings = nil
	m.clearedproduct_mappings = false
	m.removedproduct_mappings = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.barcode != nil {
		fields = append(fields, product.FieldBarcode)
	}
	if m.customer_code != nil {
		fields = append(fields, product.FieldCustomerCode)
	}
	if m.declared_name != nil {
		fields = append(fields, product.FieldDeclaredName)
	}
	if m.declared_cn_name != nil {
		fields = append(fields, product.FieldDeclaredCnName)
	}
	if m.declared_value_in_usd != nil {
		fields = append(fields, product.FieldDeclaredValueInUsd)
	}
	if m.declared_value_in_eur != nil {
		fields = append(fields, product.FieldDeclaredValueInEur)
	}
	if m.currency != nil {
		fields = append(fields, product.FieldCurrency)
	}
	if m.hs_code != nil {
		fields = append(fields, product.FieldHsCode)
	}
	if m.material != nil {
		fields = append(fields, product.FieldMaterial)
	}
	if m.purpose != nil {
		fields = append(fields, product.FieldPurpose)
	}
	if m.with_barcode != nil {
		fields = append(fields, product.FieldWithBarcode)
	}
	if m.barcode_service != nil {
		fields = append(fields, product.FieldBarcodeService)
	}
	if m.barcode_template != nil {
		fields = append(fields, product.FieldBarcodeTemplate)
	}
	if m.images != nil {
		fields = append(fields, product.FieldImages)
	}
	if m.attributes != nil {
		fields = append(fields, product.FieldAttributes)
	}
	if m.confirmed_attributes != nil {
		fields = append(fields, product.FieldConfirmedAttributes)
	}
	if m.grams != nil {
		fields = append(fields, product.FieldGrams)
	}
	if m.inbound_grams != nil {
		fields = append(fields, product.FieldInboundGrams)
	}
	if m.length != nil {
		fields = append(fields, product.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, product.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, product.FieldHeight)
	}
	if m.max_agv_qty != nil {
		fields = append(fields, product.FieldMaxAgvQty)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.created_by != nil {
		fields = append(fields, product.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldDeletedAt:
		return m.DeletedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldSku:
		return m.Sku()
	case product.FieldBarcode:
		return m.Barcode()
	case product.FieldCustomerCode:
		return m.CustomerCode()
	case product.FieldDeclaredName:
		return m.DeclaredName()
	case product.FieldDeclaredCnName:
		return m.DeclaredCnName()
	case product.FieldDeclaredValueInUsd:
		return m.DeclaredValueInUsd()
	case product.FieldDeclaredValueInEur:
		return m.DeclaredValueInEur()
	case product.FieldCurrency:
		return m.Currency()
	case product.FieldHsCode:
		return m.HsCode()
	case product.FieldMaterial:
		return m.Material()
	case product.FieldPurpose:
		return m.Purpose()
	case product.FieldWithBarcode:
		return m.WithBarcode()
	case product.FieldBarcodeService:
		return m.BarcodeService()
	case product.FieldBarcodeTemplate:
		return m.BarcodeTemplate()
	case product.FieldImages:
		return m.Images()
	case product.FieldAttributes:
		return m.Attributes()
	case product.FieldConfirmedAttributes:
		return m.ConfirmedAttributes()
	case product.FieldGrams:
		return m.Grams()
	case product.FieldInboundGrams:
		return m.InboundGrams()
	case product.FieldLength:
		return m.Length()
	case product.FieldWidth:
		return m.Width()
	case product.FieldHeight:
		return m.Height()
	case product.FieldMaxAgvQty:
		return m.MaxAgvQty()
	case product.FieldStatus:
		return m.Status()
	case product.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldBarcode:
		return m.OldBarcode(ctx)
	case product.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	case product.FieldDeclaredName:
		return m.OldDeclaredName(ctx)
	case product.FieldDeclaredCnName:
		return m.OldDeclaredCnName(ctx)
	case product.FieldDeclaredValueInUsd:
		return m.OldDeclaredValueInUsd(ctx)
	case product.FieldDeclaredValueInEur:
		return m.OldDeclaredValueInEur(ctx)
	case product.FieldCurrency:
		return m.OldCurrency(ctx)
	case product.FieldHsCode:
		return m.OldHsCode(ctx)
	case product.FieldMaterial:
		return m.OldMaterial(ctx)
	case product.FieldPurpose:
		return m.OldPurpose(ctx)
	case product.FieldWithBarcode:
		return m.OldWithBarcode(ctx)
	case product.FieldBarcodeService:
		return m.OldBarcodeService(ctx)
	case product.FieldBarcodeTemplate:
		return m.OldBarcodeTemplate(ctx)
	case product.FieldImages:
		return m.OldImages(ctx)
	case product.FieldAttributes:
		return m.OldAttributes(ctx)
	case product.FieldConfirmedAttributes:
		return m.OldConfirmedAttributes(ctx)
	case product.FieldGrams:
		return m.OldGrams(ctx)
	case product.FieldInboundGrams:
		return m.OldInboundGrams(ctx)
	case product.FieldLength:
		return m.OldLength(ctx)
	case product.FieldWidth:
		return m.OldWidth(ctx)
	case product.FieldHeight:
		return m.OldHeight(ctx)
	case product.FieldMaxAgvQty:
		return m.OldMaxAgvQty(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case product.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	case product.FieldDeclaredName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredName(v)
		return nil
	case product.FieldDeclaredCnName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredCnName(v)
		return nil
	case product.FieldDeclaredValueInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredValueInUsd(v)
		return nil
	case product.FieldDeclaredValueInEur:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclaredValueInEur(v)
		return nil
	case product.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case product.FieldHsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHsCode(v)
		return nil
	case product.FieldMaterial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	case product.FieldPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurpose(v)
		return nil
	case product.FieldWithBarcode:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithBarcode(v)
		return nil
	case product.FieldBarcodeService:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcodeService(v)
		return nil
	case product.FieldBarcodeTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcodeTemplate(v)
		return nil
	case product.FieldImages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case product.FieldAttributes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case product.FieldConfirmedAttributes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedAttributes(v)
		return nil
	case product.FieldGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrams(v)
		return nil
	case product.FieldInboundGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInboundGrams(v)
		return nil
	case product.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case product.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case product.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case product.FieldMaxAgvQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAgvQty(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.adddeclared_value_in_usd != nil {
		fields = append(fields, product.FieldDeclaredValueInUsd)
	}
	if m.adddeclared_value_in_eur != nil {
		fields = append(fields, product.FieldDeclaredValueInEur)
	}
	if m.addwith_barcode != nil {
		fields = append(fields, product.FieldWithBarcode)
	}
	if m.addbarcode_service != nil {
		fields = append(fields, product.FieldBarcodeService)
	}
	if m.addgrams != nil {
		fields = append(fields, product.FieldGrams)
	}
	if m.addinbound_grams != nil {
		fields = append(fields, product.FieldInboundGrams)
	}
	if m.addlength != nil {
		fields = append(fields, product.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, product.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, product.FieldHeight)
	}
	if m.addmax_agv_qty != nil {
		fields = append(fields, product.FieldMaxAgvQty)
	}
	if m.addstatus != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.addcreated_by != nil {
		fields = append(fields, product.FieldCreatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldDeclaredValueInUsd:
		return m.AddedDeclaredValueInUsd()
	case product.FieldDeclaredValueInEur:
		return m.AddedDeclaredValueInEur()
	case product.FieldWithBarcode:
		return m.AddedWithBarcode()
	case product.FieldBarcodeService:
		return m.AddedBarcodeService()
	case product.FieldGrams:
		return m.AddedGrams()
	case product.FieldInboundGrams:
		return m.AddedInboundGrams()
	case product.FieldLength:
		return m.AddedLength()
	case product.FieldWidth:
		return m.AddedWidth()
	case product.FieldHeight:
		return m.AddedHeight()
	case product.FieldMaxAgvQty:
		return m.AddedMaxAgvQty()
	case product.FieldStatus:
		return m.AddedStatus()
	case product.FieldCreatedBy:
		return m.AddedCreatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldDeclaredValueInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclaredValueInUsd(v)
		return nil
	case product.FieldDeclaredValueInEur:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclaredValueInEur(v)
		return nil
	case product.FieldWithBarcode:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithBarcode(v)
		return nil
	case product.FieldBarcodeService:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBarcodeService(v)
		return nil
	case product.FieldGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrams(v)
		return nil
	case product.FieldInboundGrams:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInboundGrams(v)
		return nil
	case product.FieldLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case product.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case product.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case product.FieldMaxAgvQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAgvQty(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case product.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDeletedAt) {
		fields = append(fields, product.FieldDeletedAt)
	}
	if m.FieldCleared(product.FieldDeclaredName) {
		fields = append(fields, product.FieldDeclaredName)
	}
	if m.FieldCleared(product.FieldDeclaredCnName) {
		fields = append(fields, product.FieldDeclaredCnName)
	}
	if m.FieldCleared(product.FieldBarcodeTemplate) {
		fields = append(fields, product.FieldBarcodeTemplate)
	}
	if m.FieldCleared(product.FieldImages) {
		fields = append(fields, product.FieldImages)
	}
	if m.FieldCleared(product.FieldAttributes) {
		fields = append(fields, product.FieldAttributes)
	}
	if m.FieldCleared(product.FieldConfirmedAttributes) {
		fields = append(fields, product.FieldConfirmedAttributes)
	}
	if m.FieldCleared(product.FieldCreatedBy) {
		fields = append(fields, product.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case product.FieldDeclaredName:
		m.ClearDeclaredName()
		return nil
	case product.FieldDeclaredCnName:
		m.ClearDeclaredCnName()
		return nil
	case product.FieldBarcodeTemplate:
		m.ClearBarcodeTemplate()
		return nil
	case product.FieldImages:
		m.ClearImages()
		return nil
	case product.FieldAttributes:
		m.ClearAttributes()
		return nil
	case product.FieldConfirmedAttributes:
		m.ClearConfirmedAttributes()
		return nil
	case product.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldBarcode:
		m.ResetBarcode()
		return nil
	case product.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	case product.FieldDeclaredName:
		m.ResetDeclaredName()
		return nil
	case product.FieldDeclaredCnName:
		m.ResetDeclaredCnName()
		return nil
	case product.FieldDeclaredValueInUsd:
		m.ResetDeclaredValueInUsd()
		return nil
	case product.FieldDeclaredValueInEur:
		m.ResetDeclaredValueInEur()
		return nil
	case product.FieldCurrency:
		m.ResetCurrency()
		return nil
	case product.FieldHsCode:
		m.ResetHsCode()
		return nil
	case product.FieldMaterial:
		m.ResetMaterial()
		return nil
	case product.FieldPurpose:
		m.ResetPurpose()
		return nil
	case product.FieldWithBarcode:
		m.ResetWithBarcode()
		return nil
	case product.FieldBarcodeService:
		m.ResetBarcodeService()
		return nil
	case product.FieldBarcodeTemplate:
		m.ResetBarcodeTemplate()
		return nil
	case product.FieldImages:
		m.ResetImages()
		return nil
	case product.FieldAttributes:
		m.ResetAttributes()
		return nil
	case product.FieldConfirmedAttributes:
		m.ResetConfirmedAttributes()
		return nil
	case product.FieldGrams:
		m.ResetGrams()
		return nil
	case product.FieldInboundGrams:
		m.ResetInboundGrams()
		return nil
	case product.FieldLength:
		m.ResetLength()
		return nil
	case product.FieldWidth:
		m.ResetWidth()
		return nil
	case product.FieldHeight:
		m.ResetHeight()
		return nil
	case product.FieldMaxAgvQty:
		m.ResetMaxAgvQty()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, product.EdgeTenant)
	}
	if m.inventories != nil {
		edges = append(edges, product.EdgeInventories)
	}
	if m.product_mappings != nil {
		edges = append(edges, product.EdgeProductMappings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeInventories:
		ids := make([]ent.Value, 0, len(m.inventories))
		for id := range m.inventories {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductMappings:
		ids := make([]ent.Value, 0, len(m.product_mappings))
		for id := range m.product_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinventories != nil {
		edges = append(edges, product.EdgeInventories)
	}
	if m.removedproduct_mappings != nil {
		edges = append(edges, product.EdgeProductMappings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeInventories:
		ids := make([]ent.Value, 0, len(m.removedinventories))
		for id := range m.removedinventories {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductMappings:
		ids := make([]ent.Value, 0, len(m.removedproduct_mappings))
		for id := range m.removedproduct_mappings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, product.EdgeTenant)
	}
	if m.clearedinventories {
		edges = append(edges, product.EdgeInventories)
	}
	if m.clearedproduct_mappings {
		edges = append(edges, product.EdgeProductMappings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTenant:
		return m.clearedtenant
	case product.EdgeInventories:
		return m.clearedinventories
	case product.EdgeProductMappings:
		return m.clearedproduct_mappings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ResetTenant()
		return nil
	case product.EdgeInventories:
		m.ResetInventories()
		return nil
	case product.EdgeProductMappings:
		m.ResetProductMappings()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductMappingMutation represents an operation that mutates the ProductMapping nodes in the graph.
type ProductMappingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	qty                      *int
	addqty                   *int
	created_by               *int64
	addcreated_by            *int64
	clearedFields            map[string]struct{}
	platform_products        *int64
	clearedplatform_products bool
	products                 *int64
	clearedproducts          bool
	done                     bool
	oldValue                 func(context.Context) (*ProductMapping, error)
	predicates               []predicate.ProductMapping
}

var _ ent.Mutation = (*ProductMappingMutation)(nil)

// productmappingOption allows management of the mutation configuration using functional options.
type productmappingOption func(*ProductMappingMutation)

// newProductMappingMutation creates new mutation for the ProductMapping entity.
func newProductMappingMutation(c config, op Op, opts ...productmappingOption) *ProductMappingMutation {
	m := &ProductMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeProductMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductMappingID sets the ID field of the mutation.
func withProductMappingID(id int64) productmappingOption {
	return func(m *ProductMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductMapping
		)
		m.oldValue = func(ctx context.Context) (*ProductMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductMapping sets the old ProductMapping of the mutation.
func withProductMapping(node *ProductMapping) productmappingOption {
	return func(m *ProductMappingMutation) {
		m.oldValue = func(context.Context) (*ProductMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductMapping entities.
func (m *ProductMappingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMappingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMappingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMappingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMappingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMappingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProductMappingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProductMappingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProductMappingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[productmapping.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProductMappingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[productmapping.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProductMappingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, productmapping.FieldDeletedAt)
}

// SetPlatformProductID sets the "platform_product_id" field.
func (m *ProductMappingMutation) SetPlatformProductID(i int64) {
	m.platform_products = &i
}

// PlatformProductID returns the value of the "platform_product_id" field in the mutation.
func (m *ProductMappingMutation) PlatformProductID() (r int64, exists bool) {
	v := m.platform_products
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformProductID returns the old "platform_product_id" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldPlatformProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformProductID: %w", err)
	}
	return oldValue.PlatformProductID, nil
}

// ClearPlatformProductID clears the value of the "platform_product_id" field.
func (m *ProductMappingMutation) ClearPlatformProductID() {
	m.platform_products = nil
	m.clearedFields[productmapping.FieldPlatformProductID] = struct{}{}
}

// PlatformProductIDCleared returns if the "platform_product_id" field was cleared in this mutation.
func (m *ProductMappingMutation) PlatformProductIDCleared() bool {
	_, ok := m.clearedFields[productmapping.FieldPlatformProductID]
	return ok
}

// ResetPlatformProductID resets all changes to the "platform_product_id" field.
func (m *ProductMappingMutation) ResetPlatformProductID() {
	m.platform_products = nil
	delete(m.clearedFields, productmapping.FieldPlatformProductID)
}

// SetProductID sets the "product_id" field.
func (m *ProductMappingMutation) SetProductID(i int64) {
	m.products = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductMappingMutation) ProductID() (r int64, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductMappingMutation) ClearProductID() {
	m.products = nil
	m.clearedFields[productmapping.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductMappingMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productmapping.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductMappingMutation) ResetProductID() {
	m.products = nil
	delete(m.clearedFields, productmapping.FieldProductID)
}

// SetQty sets the "qty" field.
func (m *ProductMappingMutation) SetQty(i int) {
	m.qty = &i
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *ProductMappingMutation) Qty() (r int, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldQty(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds i to the "qty" field.
func (m *ProductMappingMutation) AddQty(i int) {
	if m.addqty != nil {
		*m.addqty += i
	} else {
		m.addqty = &i
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *ProductMappingMutation) AddedQty() (r int, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "qty" field.
func (m *ProductMappingMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProductMappingMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProductMappingMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProductMapping entity.
// If the ProductMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMappingMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProductMappingMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProductMappingMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProductMappingMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetPlatformProductsID sets the "platform_products" edge to the PlatformProduct entity by id.
func (m *ProductMappingMutation) SetPlatformProductsID(id int64) {
	m.platform_products = &id
}

// ClearPlatformProducts clears the "platform_products" edge to the PlatformProduct entity.
func (m *ProductMappingMutation) ClearPlatformProducts() {
	m.clearedplatform_products = true
}

// PlatformProductsCleared reports if the "platform_products" edge to the PlatformProduct entity was cleared.
func (m *ProductMappingMutation) PlatformProductsCleared() bool {
	return m.PlatformProductIDCleared() || m.clearedplatform_products
}

// PlatformProductsID returns the "platform_products" edge ID in the mutation.
func (m *ProductMappingMutation) PlatformProductsID() (id int64, exists bool) {
	if m.platform_products != nil {
		return *m.platform_products, true
	}
	return
}

// PlatformProductsIDs returns the "platform_products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlatformProductsID instead. It exists only for internal usage by the builders.
func (m *ProductMappingMutation) PlatformProductsIDs() (ids []int64) {
	if id := m.platform_products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlatformProducts resets all changes to the "platform_products" edge.
func (m *ProductMappingMutation) ResetPlatformProducts() {
	m.platform_products = nil
	m.clearedplatform_products = false
}

// SetProductsID sets the "products" edge to the Product entity by id.
func (m *ProductMappingMutation) SetProductsID(id int64) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductMappingMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductMappingMutation) ProductsCleared() bool {
	return m.ProductIDCleared() || m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *ProductMappingMutation) ProductsID() (id int64, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ProductMappingMutation) ProductsIDs() (ids []int64) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductMappingMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// Where appends a list predicates to the ProductMappingMutation builder.
func (m *ProductMappingMutation) Where(ps ...predicate.ProductMapping) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMappingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductMapping).
func (m *ProductMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMappingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, productmapping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productmapping.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, productmapping.FieldDeletedAt)
	}
	if m.platform_products != nil {
		fields = append(fields, productmapping.FieldPlatformProductID)
	}
	if m.products != nil {
		fields = append(fields, productmapping.FieldProductID)
	}
	if m.qty != nil {
		fields = append(fields, productmapping.FieldQty)
	}
	if m.created_by != nil {
		fields = append(fields, productmapping.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productmapping.FieldCreatedAt:
		return m.CreatedAt()
	case productmapping.FieldUpdatedAt:
		return m.UpdatedAt()
	case productmapping.FieldDeletedAt:
		return m.DeletedAt()
	case productmapping.FieldPlatformProductID:
		return m.PlatformProductID()
	case productmapping.FieldProductID:
		return m.ProductID()
	case productmapping.FieldQty:
		return m.Qty()
	case productmapping.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productmapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productmapping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productmapping.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case productmapping.FieldPlatformProductID:
		return m.OldPlatformProductID(ctx)
	case productmapping.FieldProductID:
		return m.OldProductID(ctx)
	case productmapping.FieldQty:
		return m.OldQty(ctx)
	case productmapping.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ProductMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productmapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productmapping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productmapping.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case productmapping.FieldPlatformProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformProductID(v)
		return nil
	case productmapping.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case productmapping.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case productmapping.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMappingMutation) AddedFields() []string {
	var fields []string
	if m.addqty != nil {
		fields = append(fields, productmapping.FieldQty)
	}
	if m.addcreated_by != nil {
		fields = append(fields, productmapping.FieldCreatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productmapping.FieldQty:
		return m.AddedQty()
	case productmapping.FieldCreatedBy:
		return m.AddedCreatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productmapping.FieldQty:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case productmapping.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productmapping.FieldDeletedAt) {
		fields = append(fields, productmapping.FieldDeletedAt)
	}
	if m.FieldCleared(productmapping.FieldPlatformProductID) {
		fields = append(fields, productmapping.FieldPlatformProductID)
	}
	if m.FieldCleared(productmapping.FieldProductID) {
		fields = append(fields, productmapping.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMappingMutation) ClearField(name string) error {
	switch name {
	case productmapping.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case productmapping.FieldPlatformProductID:
		m.ClearPlatformProductID()
		return nil
	case productmapping.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMappingMutation) ResetField(name string) error {
	switch name {
	case productmapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productmapping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productmapping.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case productmapping.FieldPlatformProductID:
		m.ResetPlatformProductID()
		return nil
	case productmapping.FieldProductID:
		m.ResetProductID()
		return nil
	case productmapping.FieldQty:
		m.ResetQty()
		return nil
	case productmapping.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ProductMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.platform_products != nil {
		edges = append(edges, productmapping.EdgePlatformProducts)
	}
	if m.products != nil {
		edges = append(edges, productmapping.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productmapping.EdgePlatformProducts:
		if id := m.platform_products; id != nil {
			return []ent.Value{*id}
		}
	case productmapping.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplatform_products {
		edges = append(edges, productmapping.EdgePlatformProducts)
	}
	if m.clearedproducts {
		edges = append(edges, productmapping.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case productmapping.EdgePlatformProducts:
		return m.clearedplatform_products
	case productmapping.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMappingMutation) ClearEdge(name string) error {
	switch name {
	case productmapping.EdgePlatformProducts:
		m.ClearPlatformProducts()
		return nil
	case productmapping.EdgeProducts:
		m.ClearProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMappingMutation) ResetEdge(name string) error {
	switch name {
	case productmapping.EdgePlatformProducts:
		m.ResetPlatformProducts()
		return nil
	case productmapping.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductMapping edge %s", name)
}

// SequenceMutation represents an operation that mutates the Sequence nodes in the graph.
type SequenceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	prefix        *string
	value         *int64
	addvalue      *int64
	display_value *string
	clearedFields map[string]struct{}
	tenant        *int64
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*Sequence, error)
	predicates    []predicate.Sequence
}

var _ ent.Mutation = (*SequenceMutation)(nil)

// sequenceOption allows management of the mutation configuration using functional options.
type sequenceOption func(*SequenceMutation)

// newSequenceMutation creates new mutation for the Sequence entity.
func newSequenceMutation(c config, op Op, opts ...sequenceOption) *SequenceMutation {
	m := &SequenceMutation{
		config:        c,
		op:            op,
		typ:           TypeSequence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSequenceID sets the ID field of the mutation.
func withSequenceID(id int64) sequenceOption {
	return func(m *SequenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Sequence
		)
		m.oldValue = func(ctx context.Context) (*Sequence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sequence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSequence sets the old Sequence of the mutation.
func withSequence(node *Sequence) sequenceOption {
	return func(m *SequenceMutation) {
		m.oldValue = func(context.Context) (*Sequence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SequenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SequenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sequence entities.
func (m *SequenceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SequenceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SequenceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sequence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SequenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SequenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SequenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SequenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SequenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SequenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SequenceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SequenceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SequenceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sequence.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SequenceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sequence.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SequenceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sequence.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SequenceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SequenceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SequenceMutation) ResetName() {
	m.name = nil
}

// SetPrefix sets the "prefix" field.
func (m *SequenceMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *SequenceMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *SequenceMutation) ResetPrefix() {
	m.prefix = nil
}

// SetValue sets the "value" field.
func (m *SequenceMutation) SetValue(i int64) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *SequenceMutation) Value() (r int64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *SequenceMutation) AddValue(i int64) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *SequenceMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *SequenceMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetDisplayValue sets the "display_value" field.
func (m *SequenceMutation) SetDisplayValue(s string) {
	m.display_value = &s
}

// DisplayValue returns the value of the "display_value" field in the mutation.
func (m *SequenceMutation) DisplayValue() (r string, exists bool) {
	v := m.display_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayValue returns the old "display_value" field's value of the Sequence entity.
// If the Sequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SequenceMutation) OldDisplayValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayValue: %w", err)
	}
	return oldValue.DisplayValue, nil
}

// ClearDisplayValue clears the value of the "display_value" field.
func (m *SequenceMutation) ClearDisplayValue() {
	m.display_value = nil
	m.clearedFields[sequence.FieldDisplayValue] = struct{}{}
}

// DisplayValueCleared returns if the "display_value" field was cleared in this mutation.
func (m *SequenceMutation) DisplayValueCleared() bool {
	_, ok := m.clearedFields[sequence.FieldDisplayValue]
	return ok
}

// ResetDisplayValue resets all changes to the "display_value" field.
func (m *SequenceMutation) ResetDisplayValue() {
	m.display_value = nil
	delete(m.clearedFields, sequence.FieldDisplayValue)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *SequenceMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SequenceMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SequenceMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *SequenceMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SequenceMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SequenceMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SequenceMutation builder.
func (m *SequenceMutation) Where(ps ...predicate.Sequence) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SequenceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Sequence).
func (m *SequenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SequenceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, sequence.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sequence.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sequence.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, sequence.FieldName)
	}
	if m.prefix != nil {
		fields = append(fields, sequence.FieldPrefix)
	}
	if m.value != nil {
		fields = append(fields, sequence.FieldValue)
	}
	if m.display_value != nil {
		fields = append(fields, sequence.FieldDisplayValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SequenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sequence.FieldCreatedAt:
		return m.CreatedAt()
	case sequence.FieldUpdatedAt:
		return m.UpdatedAt()
	case sequence.FieldDeletedAt:
		return m.DeletedAt()
	case sequence.FieldName:
		return m.Name()
	case sequence.FieldPrefix:
		return m.Prefix()
	case sequence.FieldValue:
		return m.Value()
	case sequence.FieldDisplayValue:
		return m.DisplayValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SequenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sequence.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sequence.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sequence.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sequence.FieldName:
		return m.OldName(ctx)
	case sequence.FieldPrefix:
		return m.OldPrefix(ctx)
	case sequence.FieldValue:
		return m.OldValue(ctx)
	case sequence.FieldDisplayValue:
		return m.OldDisplayValue(ctx)
	}
	return nil, fmt.Errorf("unknown Sequence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SequenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sequence.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sequence.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sequence.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sequence.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sequence.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case sequence.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case sequence.FieldDisplayValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayValue(v)
		return nil
	}
	return fmt.Errorf("unknown Sequence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SequenceMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, sequence.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SequenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sequence.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SequenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sequence.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Sequence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SequenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sequence.FieldDeletedAt) {
		fields = append(fields, sequence.FieldDeletedAt)
	}
	if m.FieldCleared(sequence.FieldDisplayValue) {
		fields = append(fields, sequence.FieldDisplayValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SequenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SequenceMutation) ClearField(name string) error {
	switch name {
	case sequence.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sequence.FieldDisplayValue:
		m.ClearDisplayValue()
		return nil
	}
	return fmt.Errorf("unknown Sequence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SequenceMutation) ResetField(name string) error {
	switch name {
	case sequence.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sequence.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sequence.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sequence.FieldName:
		m.ResetName()
		return nil
	case sequence.FieldPrefix:
		m.ResetPrefix()
		return nil
	case sequence.FieldValue:
		m.ResetValue()
		return nil
	case sequence.FieldDisplayValue:
		m.ResetDisplayValue()
		return nil
	}
	return fmt.Errorf("unknown Sequence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SequenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, sequence.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SequenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sequence.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SequenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SequenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SequenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, sequence.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SequenceMutation) EdgeCleared(name string) bool {
	switch name {
	case sequence.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SequenceMutation) ClearEdge(name string) error {
	switch name {
	case sequence.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Sequence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SequenceMutation) ResetEdge(name string) error {
	switch name {
	case sequence.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown Sequence edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	store_url                *string
	platform                 *string
	name                     *string
	code                     *string
	email                    *string
	access_token             *string
	timezone_offset          *int8
	addtimezone_offset       *int8
	scope                    *string
	location_id              *string
	locations                *string
	store_currency           *string
	initial_status           *int8
	addinitial_status        *int8
	state                    *string
	timestamp                *int32
	addtimestamp             *int32
	nonce                    *string
	balance                  *float64
	addbalance               *float64
	currency                 *string
	handling_fee             *float64
	addhandling_fee          *float64
	shipping_option          *int8
	addshipping_option       *int8
	default_warehouse        *int64
	adddefault_warehouse     *int64
	prepay_tariff            *int8
	addprepay_tariff         *int8
	ioss_number              *string
	ioss_country_code        *string
	uk_vat_number            *string
	store_code               *string
	preset_channel_ids       *string
	test_channel_ids         *string
	first_inbound_at         *time.Time
	storage_unit_price       *float64
	addstorage_unit_price    *float64
	integration_at           *time.Time
	clearedFields            map[string]struct{}
	tenant                   *int64
	clearedtenant            bool
	orders                   map[int64]struct{}
	removedorders            map[int64]struct{}
	clearedorders            bool
	platform_products        map[int64]struct{}
	removedplatform_products map[int64]struct{}
	clearedplatform_products bool
	done                     bool
	oldValue                 func(context.Context) (*Store, error)
	predicates               []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id int64) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Store entities.
func (m *StoreMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoreMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[store.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoreMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[store.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, store.FieldDeletedAt)
}

// SetStoreURL sets the "store_url" field.
func (m *StoreMutation) SetStoreURL(s string) {
	m.store_url = &s
}

// StoreURL returns the value of the "store_url" field in the mutation.
func (m *StoreMutation) StoreURL() (r string, exists bool) {
	v := m.store_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreURL returns the old "store_url" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreURL: %w", err)
	}
	return oldValue.StoreURL, nil
}

// ResetStoreURL resets all changes to the "store_url" field.
func (m *StoreMutation) ResetStoreURL() {
	m.store_url = nil
}

// SetPlatform sets the "platform" field.
func (m *StoreMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *StoreMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *StoreMutation) ResetPlatform() {
	m.platform = nil
}

// SetName sets the "name" field.
func (m *StoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoreMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *StoreMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *StoreMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *StoreMutation) ResetCode() {
	m.code = nil
}

// SetEmail sets the "email" field.
func (m *StoreMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StoreMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StoreMutation) ResetEmail() {
	m.email = nil
}

// SetAccessToken sets the "access_token" field.
func (m *StoreMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *StoreMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *StoreMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetTimezoneOffset sets the "timezone_offset" field.
func (m *StoreMutation) SetTimezoneOffset(i int8) {
	m.timezone_offset = &i
	m.addtimezone_offset = nil
}

// TimezoneOffset returns the value of the "timezone_offset" field in the mutation.
func (m *StoreMutation) TimezoneOffset() (r int8, exists bool) {
	v := m.timezone_offset
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezoneOffset returns the old "timezone_offset" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldTimezoneOffset(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezoneOffset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezoneOffset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezoneOffset: %w", err)
	}
	return oldValue.TimezoneOffset, nil
}

// AddTimezoneOffset adds i to the "timezone_offset" field.
func (m *StoreMutation) AddTimezoneOffset(i int8) {
	if m.addtimezone_offset != nil {
		*m.addtimezone_offset += i
	} else {
		m.addtimezone_offset = &i
	}
}

// AddedTimezoneOffset returns the value that was added to the "timezone_offset" field in this mutation.
func (m *StoreMutation) AddedTimezoneOffset() (r int8, exists bool) {
	v := m.addtimezone_offset
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimezoneOffset resets all changes to the "timezone_offset" field.
func (m *StoreMutation) ResetTimezoneOffset() {
	m.timezone_offset = nil
	m.addtimezone_offset = nil
}

// SetScope sets the "scope" field.
func (m *StoreMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *StoreMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *StoreMutation) ResetScope() {
	m.scope = nil
}

// SetLocationID sets the "location_id" field.
func (m *StoreMutation) SetLocationID(s string) {
	m.location_id = &s
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *StoreMutation) LocationID() (r string, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLocationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *StoreMutation) ResetLocationID() {
	m.location_id = nil
}

// SetLocations sets the "locations" field.
func (m *StoreMutation) SetLocations(s string) {
	m.locations = &s
}

// Locations returns the value of the "locations" field in the mutation.
func (m *StoreMutation) Locations() (r string, exists bool) {
	v := m.locations
	if v == nil {
		return
	}
	return *v, true
}

// OldLocations returns the old "locations" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLocations(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocations: %w", err)
	}
	return oldValue.Locations, nil
}

// ClearLocations clears the value of the "locations" field.
func (m *StoreMutation) ClearLocations() {
	m.locations = nil
	m.clearedFields[store.FieldLocations] = struct{}{}
}

// LocationsCleared returns if the "locations" field was cleared in this mutation.
func (m *StoreMutation) LocationsCleared() bool {
	_, ok := m.clearedFields[store.FieldLocations]
	return ok
}

// ResetLocations resets all changes to the "locations" field.
func (m *StoreMutation) ResetLocations() {
	m.locations = nil
	delete(m.clearedFields, store.FieldLocations)
}

// SetStoreCurrency sets the "store_currency" field.
func (m *StoreMutation) SetStoreCurrency(s string) {
	m.store_currency = &s
}

// StoreCurrency returns the value of the "store_currency" field in the mutation.
func (m *StoreMutation) StoreCurrency() (r string, exists bool) {
	v := m.store_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreCurrency returns the old "store_currency" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreCurrency: %w", err)
	}
	return oldValue.StoreCurrency, nil
}

// ResetStoreCurrency resets all changes to the "store_currency" field.
func (m *StoreMutation) ResetStoreCurrency() {
	m.store_currency = nil
}

// SetInitialStatus sets the "initial_status" field.
func (m *StoreMutation) SetInitialStatus(i int8) {
	m.initial_status = &i
	m.addinitial_status = nil
}

// InitialStatus returns the value of the "initial_status" field in the mutation.
func (m *StoreMutation) InitialStatus() (r int8, exists bool) {
	v := m.initial_status
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialStatus returns the old "initial_status" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldInitialStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialStatus: %w", err)
	}
	return oldValue.InitialStatus, nil
}

// AddInitialStatus adds i to the "initial_status" field.
func (m *StoreMutation) AddInitialStatus(i int8) {
	if m.addinitial_status != nil {
		*m.addinitial_status += i
	} else {
		m.addinitial_status = &i
	}
}

// AddedInitialStatus returns the value that was added to the "initial_status" field in this mutation.
func (m *StoreMutation) AddedInitialStatus() (r int8, exists bool) {
	v := m.addinitial_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetInitialStatus resets all changes to the "initial_status" field.
func (m *StoreMutation) ResetInitialStatus() {
	m.initial_status = nil
	m.addinitial_status = nil
}

// SetState sets the "state" field.
func (m *StoreMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *StoreMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *StoreMutation) ResetState() {
	m.state = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *StoreMutation) SetTimestamp(i int32) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *StoreMutation) Timestamp() (r int32, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldTimestamp(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *StoreMutation) AddTimestamp(i int32) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *StoreMutation) AddedTimestamp() (r int32, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *StoreMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// SetNonce sets the "nonce" field.
func (m *StoreMutation) SetNonce(s string) {
	m.nonce = &s
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *StoreMutation) Nonce() (r string, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldNonce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *StoreMutation) ResetNonce() {
	m.nonce = nil
}

// SetBalance sets the "balance" field.
func (m *StoreMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *StoreMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *StoreMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *StoreMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *StoreMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCurrency sets the "currency" field.
func (m *StoreMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *StoreMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *StoreMutation) ResetCurrency() {
	m.currency = nil
}

// SetHandlingFee sets the "handling_fee" field.
func (m *StoreMutation) SetHandlingFee(f float64) {
	m.handling_fee = &f
	m.addhandling_fee = nil
}

// HandlingFee returns the value of the "handling_fee" field in the mutation.
func (m *StoreMutation) HandlingFee() (r float64, exists bool) {
	v := m.handling_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlingFee returns the old "handling_fee" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldHandlingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlingFee: %w", err)
	}
	return oldValue.HandlingFee, nil
}

// AddHandlingFee adds f to the "handling_fee" field.
func (m *StoreMutation) AddHandlingFee(f float64) {
	if m.addhandling_fee != nil {
		*m.addhandling_fee += f
	} else {
		m.addhandling_fee = &f
	}
}

// AddedHandlingFee returns the value that was added to the "handling_fee" field in this mutation.
func (m *StoreMutation) AddedHandlingFee() (r float64, exists bool) {
	v := m.addhandling_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandlingFee resets all changes to the "handling_fee" field.
func (m *StoreMutation) ResetHandlingFee() {
	m.handling_fee = nil
	m.addhandling_fee = nil
}

// SetShippingOption sets the "shipping_option" field.
func (m *StoreMutation) SetShippingOption(i int8) {
	m.shipping_option = &i
	m.addshipping_option = nil
}

// ShippingOption returns the value of the "shipping_option" field in the mutation.
func (m *StoreMutation) ShippingOption() (r int8, exists bool) {
	v := m.shipping_option
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingOption returns the old "shipping_option" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldShippingOption(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingOption: %w", err)
	}
	return oldValue.ShippingOption, nil
}

// AddShippingOption adds i to the "shipping_option" field.
func (m *StoreMutation) AddShippingOption(i int8) {
	if m.addshipping_option != nil {
		*m.addshipping_option += i
	} else {
		m.addshipping_option = &i
	}
}

// AddedShippingOption returns the value that was added to the "shipping_option" field in this mutation.
func (m *StoreMutation) AddedShippingOption() (r int8, exists bool) {
	v := m.addshipping_option
	if v == nil {
		return
	}
	return *v, true
}

// ResetShippingOption resets all changes to the "shipping_option" field.
func (m *StoreMutation) ResetShippingOption() {
	m.shipping_option = nil
	m.addshipping_option = nil
}

// SetDefaultWarehouse sets the "default_warehouse" field.
func (m *StoreMutation) SetDefaultWarehouse(i int64) {
	m.default_warehouse = &i
	m.adddefault_warehouse = nil
}

// DefaultWarehouse returns the value of the "default_warehouse" field in the mutation.
func (m *StoreMutation) DefaultWarehouse() (r int64, exists bool) {
	v := m.default_warehouse
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultWarehouse returns the old "default_warehouse" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDefaultWarehouse(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultWarehouse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultWarehouse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultWarehouse: %w", err)
	}
	return oldValue.DefaultWarehouse, nil
}

// AddDefaultWarehouse adds i to the "default_warehouse" field.
func (m *StoreMutation) AddDefaultWarehouse(i int64) {
	if m.adddefault_warehouse != nil {
		*m.adddefault_warehouse += i
	} else {
		m.adddefault_warehouse = &i
	}
}

// AddedDefaultWarehouse returns the value that was added to the "default_warehouse" field in this mutation.
func (m *StoreMutation) AddedDefaultWarehouse() (r int64, exists bool) {
	v := m.adddefault_warehouse
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultWarehouse resets all changes to the "default_warehouse" field.
func (m *StoreMutation) ResetDefaultWarehouse() {
	m.default_warehouse = nil
	m.adddefault_warehouse = nil
}

// SetPrepayTariff sets the "prepay_tariff" field.
func (m *StoreMutation) SetPrepayTariff(i int8) {
	m.prepay_tariff = &i
	m.addprepay_tariff = nil
}

// PrepayTariff returns the value of the "prepay_tariff" field in the mutation.
func (m *StoreMutation) PrepayTariff() (r int8, exists bool) {
	v := m.prepay_tariff
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepayTariff returns the old "prepay_tariff" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldPrepayTariff(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepayTariff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepayTariff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepayTariff: %w", err)
	}
	return oldValue.PrepayTariff, nil
}

// AddPrepayTariff adds i to the "prepay_tariff" field.
func (m *StoreMutation) AddPrepayTariff(i int8) {
	if m.addprepay_tariff != nil {
		*m.addprepay_tariff += i
	} else {
		m.addprepay_tariff = &i
	}
}

// AddedPrepayTariff returns the value that was added to the "prepay_tariff" field in this mutation.
func (m *StoreMutation) AddedPrepayTariff() (r int8, exists bool) {
	v := m.addprepay_tariff
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrepayTariff resets all changes to the "prepay_tariff" field.
func (m *StoreMutation) ResetPrepayTariff() {
	m.prepay_tariff = nil
	m.addprepay_tariff = nil
}

// SetIossNumber sets the "ioss_number" field.
func (m *StoreMutation) SetIossNumber(s string) {
	m.ioss_number = &s
}

// IossNumber returns the value of the "ioss_number" field in the mutation.
func (m *StoreMutation) IossNumber() (r string, exists bool) {
	v := m.ioss_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIossNumber returns the old "ioss_number" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIossNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossNumber: %w", err)
	}
	return oldValue.IossNumber, nil
}

// ResetIossNumber resets all changes to the "ioss_number" field.
func (m *StoreMutation) ResetIossNumber() {
	m.ioss_number = nil
}

// SetIossCountryCode sets the "ioss_country_code" field.
func (m *StoreMutation) SetIossCountryCode(s string) {
	m.ioss_country_code = &s
}

// IossCountryCode returns the value of the "ioss_country_code" field in the mutation.
func (m *StoreMutation) IossCountryCode() (r string, exists bool) {
	v := m.ioss_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIossCountryCode returns the old "ioss_country_code" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIossCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossCountryCode: %w", err)
	}
	return oldValue.IossCountryCode, nil
}

// ResetIossCountryCode resets all changes to the "ioss_country_code" field.
func (m *StoreMutation) ResetIossCountryCode() {
	m.ioss_country_code = nil
}

// SetUkVatNumber sets the "uk_vat_number" field.
func (m *StoreMutation) SetUkVatNumber(s string) {
	m.uk_vat_number = &s
}

// UkVatNumber returns the value of the "uk_vat_number" field in the mutation.
func (m *StoreMutation) UkVatNumber() (r string, exists bool) {
	v := m.uk_vat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldUkVatNumber returns the old "uk_vat_number" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUkVatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUkVatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUkVatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUkVatNumber: %w", err)
	}
	return oldValue.UkVatNumber, nil
}

// ResetUkVatNumber resets all changes to the "uk_vat_number" field.
func (m *StoreMutation) ResetUkVatNumber() {
	m.uk_vat_number = nil
}

// SetStoreCode sets the "store_code" field.
func (m *StoreMutation) SetStoreCode(s string) {
	m.store_code = &s
}

// StoreCode returns the value of the "store_code" field in the mutation.
func (m *StoreMutation) StoreCode() (r string, exists bool) {
	v := m.store_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreCode returns the old "store_code" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStoreCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreCode: %w", err)
	}
	return oldValue.StoreCode, nil
}

// ResetStoreCode resets all changes to the "store_code" field.
func (m *StoreMutation) ResetStoreCode() {
	m.store_code = nil
}

// SetPresetChannelIds sets the "preset_channel_ids" field.
func (m *StoreMutation) SetPresetChannelIds(s string) {
	m.preset_channel_ids = &s
}

// PresetChannelIds returns the value of the "preset_channel_ids" field in the mutation.
func (m *StoreMutation) PresetChannelIds() (r string, exists bool) {
	v := m.preset_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldPresetChannelIds returns the old "preset_channel_ids" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldPresetChannelIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresetChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresetChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresetChannelIds: %w", err)
	}
	return oldValue.PresetChannelIds, nil
}

// ClearPresetChannelIds clears the value of the "preset_channel_ids" field.
func (m *StoreMutation) ClearPresetChannelIds() {
	m.preset_channel_ids = nil
	m.clearedFields[store.FieldPresetChannelIds] = struct{}{}
}

// PresetChannelIdsCleared returns if the "preset_channel_ids" field was cleared in this mutation.
func (m *StoreMutation) PresetChannelIdsCleared() bool {
	_, ok := m.clearedFields[store.FieldPresetChannelIds]
	return ok
}

// ResetPresetChannelIds resets all changes to the "preset_channel_ids" field.
func (m *StoreMutation) ResetPresetChannelIds() {
	m.preset_channel_ids = nil
	delete(m.clearedFields, store.FieldPresetChannelIds)
}

// SetTestChannelIds sets the "test_channel_ids" field.
func (m *StoreMutation) SetTestChannelIds(s string) {
	m.test_channel_ids = &s
}

// TestChannelIds returns the value of the "test_channel_ids" field in the mutation.
func (m *StoreMutation) TestChannelIds() (r string, exists bool) {
	v := m.test_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldTestChannelIds returns the old "test_channel_ids" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldTestChannelIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestChannelIds: %w", err)
	}
	return oldValue.TestChannelIds, nil
}

// ClearTestChannelIds clears the value of the "test_channel_ids" field.
func (m *StoreMutation) ClearTestChannelIds() {
	m.test_channel_ids = nil
	m.clearedFields[store.FieldTestChannelIds] = struct{}{}
}

// TestChannelIdsCleared returns if the "test_channel_ids" field was cleared in this mutation.
func (m *StoreMutation) TestChannelIdsCleared() bool {
	_, ok := m.clearedFields[store.FieldTestChannelIds]
	return ok
}

// ResetTestChannelIds resets all changes to the "test_channel_ids" field.
func (m *StoreMutation) ResetTestChannelIds() {
	m.test_channel_ids = nil
	delete(m.clearedFields, store.FieldTestChannelIds)
}

// SetFirstInboundAt sets the "first_inbound_at" field.
func (m *StoreMutation) SetFirstInboundAt(t time.Time) {
	m.first_inbound_at = &t
}

// FirstInboundAt returns the value of the "first_inbound_at" field in the mutation.
func (m *StoreMutation) FirstInboundAt() (r time.Time, exists bool) {
	v := m.first_inbound_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstInboundAt returns the old "first_inbound_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldFirstInboundAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstInboundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstInboundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstInboundAt: %w", err)
	}
	return oldValue.FirstInboundAt, nil
}

// ClearFirstInboundAt clears the value of the "first_inbound_at" field.
func (m *StoreMutation) ClearFirstInboundAt() {
	m.first_inbound_at = nil
	m.clearedFields[store.FieldFirstInboundAt] = struct{}{}
}

// FirstInboundAtCleared returns if the "first_inbound_at" field was cleared in this mutation.
func (m *StoreMutation) FirstInboundAtCleared() bool {
	_, ok := m.clearedFields[store.FieldFirstInboundAt]
	return ok
}

// ResetFirstInboundAt resets all changes to the "first_inbound_at" field.
func (m *StoreMutation) ResetFirstInboundAt() {
	m.first_inbound_at = nil
	delete(m.clearedFields, store.FieldFirstInboundAt)
}

// SetStorageUnitPrice sets the "storage_unit_price" field.
func (m *StoreMutation) SetStorageUnitPrice(f float64) {
	m.storage_unit_price = &f
	m.addstorage_unit_price = nil
}

// StorageUnitPrice returns the value of the "storage_unit_price" field in the mutation.
func (m *StoreMutation) StorageUnitPrice() (r float64, exists bool) {
	v := m.storage_unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageUnitPrice returns the old "storage_unit_price" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStorageUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageUnitPrice: %w", err)
	}
	return oldValue.StorageUnitPrice, nil
}

// AddStorageUnitPrice adds f to the "storage_unit_price" field.
func (m *StoreMutation) AddStorageUnitPrice(f float64) {
	if m.addstorage_unit_price != nil {
		*m.addstorage_unit_price += f
	} else {
		m.addstorage_unit_price = &f
	}
}

// AddedStorageUnitPrice returns the value that was added to the "storage_unit_price" field in this mutation.
func (m *StoreMutation) AddedStorageUnitPrice() (r float64, exists bool) {
	v := m.addstorage_unit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStorageUnitPrice resets all changes to the "storage_unit_price" field.
func (m *StoreMutation) ResetStorageUnitPrice() {
	m.storage_unit_price = nil
	m.addstorage_unit_price = nil
}

// SetIntegrationAt sets the "integration_at" field.
func (m *StoreMutation) SetIntegrationAt(t time.Time) {
	m.integration_at = &t
}

// IntegrationAt returns the value of the "integration_at" field in the mutation.
func (m *StoreMutation) IntegrationAt() (r time.Time, exists bool) {
	v := m.integration_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIntegrationAt returns the old "integration_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldIntegrationAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntegrationAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntegrationAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntegrationAt: %w", err)
	}
	return oldValue.IntegrationAt, nil
}

// ClearIntegrationAt clears the value of the "integration_at" field.
func (m *StoreMutation) ClearIntegrationAt() {
	m.integration_at = nil
	m.clearedFields[store.FieldIntegrationAt] = struct{}{}
}

// IntegrationAtCleared returns if the "integration_at" field was cleared in this mutation.
func (m *StoreMutation) IntegrationAtCleared() bool {
	_, ok := m.clearedFields[store.FieldIntegrationAt]
	return ok
}

// ResetIntegrationAt resets all changes to the "integration_at" field.
func (m *StoreMutation) ResetIntegrationAt() {
	m.integration_at = nil
	delete(m.clearedFields, store.FieldIntegrationAt)
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *StoreMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *StoreMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *StoreMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *StoreMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *StoreMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *StoreMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *StoreMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *StoreMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *StoreMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *StoreMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *StoreMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *StoreMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddPlatformProductIDs adds the "platform_products" edge to the PlatformProduct entity by ids.
func (m *StoreMutation) AddPlatformProductIDs(ids ...int64) {
	if m.platform_products == nil {
		m.platform_products = make(map[int64]struct{})
	}
	for i := range ids {
		m.platform_products[ids[i]] = struct{}{}
	}
}

// ClearPlatformProducts clears the "platform_products" edge to the PlatformProduct entity.
func (m *StoreMutation) ClearPlatformProducts() {
	m.clearedplatform_products = true
}

// PlatformProductsCleared reports if the "platform_products" edge to the PlatformProduct entity was cleared.
func (m *StoreMutation) PlatformProductsCleared() bool {
	return m.clearedplatform_products
}

// RemovePlatformProductIDs removes the "platform_products" edge to the PlatformProduct entity by IDs.
func (m *StoreMutation) RemovePlatformProductIDs(ids ...int64) {
	if m.removedplatform_products == nil {
		m.removedplatform_products = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.platform_products, ids[i])
		m.removedplatform_products[ids[i]] = struct{}{}
	}
}

// RemovedPlatformProducts returns the removed IDs of the "platform_products" edge to the PlatformProduct entity.
func (m *StoreMutation) RemovedPlatformProductsIDs() (ids []int64) {
	for id := range m.removedplatform_products {
		ids = append(ids, id)
	}
	return
}

// PlatformProductsIDs returns the "platform_products" edge IDs in the mutation.
func (m *StoreMutation) PlatformProductsIDs() (ids []int64) {
	for id := range m.platform_products {
		ids = append(ids, id)
	}
	return
}

// ResetPlatformProducts resets all changes to the "platform_products" edge.
func (m *StoreMutation) ResetPlatformProducts() {
	m.platform_products = nil
	m.clearedplatform_products = false
	m.removedplatform_products = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.created_at != nil {
		fields = append(fields, store.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.store_url != nil {
		fields = append(fields, store.FieldStoreURL)
	}
	if m.platform != nil {
		fields = append(fields, store.FieldPlatform)
	}
	if m.name != nil {
		fields = append(fields, store.FieldName)
	}
	if m.code != nil {
		fields = append(fields, store.FieldCode)
	}
	if m.email != nil {
		fields = append(fields, store.FieldEmail)
	}
	if m.access_token != nil {
		fields = append(fields, store.FieldAccessToken)
	}
	if m.timezone_offset != nil {
		fields = append(fields, store.FieldTimezoneOffset)
	}
	if m.scope != nil {
		fields = append(fields, store.FieldScope)
	}
	if m.location_id != nil {
		fields = append(fields, store.FieldLocationID)
	}
	if m.locations != nil {
		fields = append(fields, store.FieldLocations)
	}
	if m.store_currency != nil {
		fields = append(fields, store.FieldStoreCurrency)
	}
	if m.initial_status != nil {
		fields = append(fields, store.FieldInitialStatus)
	}
	if m.state != nil {
		fields = append(fields, store.FieldState)
	}
	if m.timestamp != nil {
		fields = append(fields, store.FieldTimestamp)
	}
	if m.nonce != nil {
		fields = append(fields, store.FieldNonce)
	}
	if m.balance != nil {
		fields = append(fields, store.FieldBalance)
	}
	if m.currency != nil {
		fields = append(fields, store.FieldCurrency)
	}
	if m.handling_fee != nil {
		fields = append(fields, store.FieldHandlingFee)
	}
	if m.shipping_option != nil {
		fields = append(fields, store.FieldShippingOption)
	}
	if m.default_warehouse != nil {
		fields = append(fields, store.FieldDefaultWarehouse)
	}
	if m.prepay_tariff != nil {
		fields = append(fields, store.FieldPrepayTariff)
	}
	if m.ioss_number != nil {
		fields = append(fields, store.FieldIossNumber)
	}
	if m.ioss_country_code != nil {
		fields = append(fields, store.FieldIossCountryCode)
	}
	if m.uk_vat_number != nil {
		fields = append(fields, store.FieldUkVatNumber)
	}
	if m.store_code != nil {
		fields = append(fields, store.FieldStoreCode)
	}
	if m.preset_channel_ids != nil {
		fields = append(fields, store.FieldPresetChannelIds)
	}
	if m.test_channel_ids != nil {
		fields = append(fields, store.FieldTestChannelIds)
	}
	if m.first_inbound_at != nil {
		fields = append(fields, store.FieldFirstInboundAt)
	}
	if m.storage_unit_price != nil {
		fields = append(fields, store.FieldStorageUnitPrice)
	}
	if m.integration_at != nil {
		fields = append(fields, store.FieldIntegrationAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldCreatedAt:
		return m.CreatedAt()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	case store.FieldDeletedAt:
		return m.DeletedAt()
	case store.FieldStoreURL:
		return m.StoreURL()
	case store.FieldPlatform:
		return m.Platform()
	case store.FieldName:
		return m.Name()
	case store.FieldCode:
		return m.Code()
	case store.FieldEmail:
		return m.Email()
	case store.FieldAccessToken:
		return m.AccessToken()
	case store.FieldTimezoneOffset:
		return m.TimezoneOffset()
	case store.FieldScope:
		return m.Scope()
	case store.FieldLocationID:
		return m.LocationID()
	case store.FieldLocations:
		return m.Locations()
	case store.FieldStoreCurrency:
		return m.StoreCurrency()
	case store.FieldInitialStatus:
		return m.InitialStatus()
	case store.FieldState:
		return m.State()
	case store.FieldTimestamp:
		return m.Timestamp()
	case store.FieldNonce:
		return m.Nonce()
	case store.FieldBalance:
		return m.Balance()
	case store.FieldCurrency:
		return m.Currency()
	case store.FieldHandlingFee:
		return m.HandlingFee()
	case store.FieldShippingOption:
		return m.ShippingOption()
	case store.FieldDefaultWarehouse:
		return m.DefaultWarehouse()
	case store.FieldPrepayTariff:
		return m.PrepayTariff()
	case store.FieldIossNumber:
		return m.IossNumber()
	case store.FieldIossCountryCode:
		return m.IossCountryCode()
	case store.FieldUkVatNumber:
		return m.UkVatNumber()
	case store.FieldStoreCode:
		return m.StoreCode()
	case store.FieldPresetChannelIds:
		return m.PresetChannelIds()
	case store.FieldTestChannelIds:
		return m.TestChannelIds()
	case store.FieldFirstInboundAt:
		return m.FirstInboundAt()
	case store.FieldStorageUnitPrice:
		return m.StorageUnitPrice()
	case store.FieldIntegrationAt:
		return m.IntegrationAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case store.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case store.FieldStoreURL:
		return m.OldStoreURL(ctx)
	case store.FieldPlatform:
		return m.OldPlatform(ctx)
	case store.FieldName:
		return m.OldName(ctx)
	case store.FieldCode:
		return m.OldCode(ctx)
	case store.FieldEmail:
		return m.OldEmail(ctx)
	case store.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case store.FieldTimezoneOffset:
		return m.OldTimezoneOffset(ctx)
	case store.FieldScope:
		return m.OldScope(ctx)
	case store.FieldLocationID:
		return m.OldLocationID(ctx)
	case store.FieldLocations:
		return m.OldLocations(ctx)
	case store.FieldStoreCurrency:
		return m.OldStoreCurrency(ctx)
	case store.FieldInitialStatus:
		return m.OldInitialStatus(ctx)
	case store.FieldState:
		return m.OldState(ctx)
	case store.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case store.FieldNonce:
		return m.OldNonce(ctx)
	case store.FieldBalance:
		return m.OldBalance(ctx)
	case store.FieldCurrency:
		return m.OldCurrency(ctx)
	case store.FieldHandlingFee:
		return m.OldHandlingFee(ctx)
	case store.FieldShippingOption:
		return m.OldShippingOption(ctx)
	case store.FieldDefaultWarehouse:
		return m.OldDefaultWarehouse(ctx)
	case store.FieldPrepayTariff:
		return m.OldPrepayTariff(ctx)
	case store.FieldIossNumber:
		return m.OldIossNumber(ctx)
	case store.FieldIossCountryCode:
		return m.OldIossCountryCode(ctx)
	case store.FieldUkVatNumber:
		return m.OldUkVatNumber(ctx)
	case store.FieldStoreCode:
		return m.OldStoreCode(ctx)
	case store.FieldPresetChannelIds:
		return m.OldPresetChannelIds(ctx)
	case store.FieldTestChannelIds:
		return m.OldTestChannelIds(ctx)
	case store.FieldFirstInboundAt:
		return m.OldFirstInboundAt(ctx)
	case store.FieldStorageUnitPrice:
		return m.OldStorageUnitPrice(ctx)
	case store.FieldIntegrationAt:
		return m.OldIntegrationAt(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case store.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case store.FieldStoreURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreURL(v)
		return nil
	case store.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case store.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case store.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case store.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case store.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case store.FieldTimezoneOffset:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezoneOffset(v)
		return nil
	case store.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case store.FieldLocationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case store.FieldLocations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocations(v)
		return nil
	case store.FieldStoreCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreCurrency(v)
		return nil
	case store.FieldInitialStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialStatus(v)
		return nil
	case store.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case store.FieldTimestamp:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case store.FieldNonce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case store.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case store.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case store.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlingFee(v)
		return nil
	case store.FieldShippingOption:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingOption(v)
		return nil
	case store.FieldDefaultWarehouse:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultWarehouse(v)
		return nil
	case store.FieldPrepayTariff:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepayTariff(v)
		return nil
	case store.FieldIossNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossNumber(v)
		return nil
	case store.FieldIossCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossCountryCode(v)
		return nil
	case store.FieldUkVatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUkVatNumber(v)
		return nil
	case store.FieldStoreCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreCode(v)
		return nil
	case store.FieldPresetChannelIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresetChannelIds(v)
		return nil
	case store.FieldTestChannelIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestChannelIds(v)
		return nil
	case store.FieldFirstInboundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstInboundAt(v)
		return nil
	case store.FieldStorageUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageUnitPrice(v)
		return nil
	case store.FieldIntegrationAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntegrationAt(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.addtimezone_offset != nil {
		fields = append(fields, store.FieldTimezoneOffset)
	}
	if m.addinitial_status != nil {
		fields = append(fields, store.FieldInitialStatus)
	}
	if m.addtimestamp != nil {
		fields = append(fields, store.FieldTimestamp)
	}
	if m.addbalance != nil {
		fields = append(fields, store.FieldBalance)
	}
	if m.addhandling_fee != nil {
		fields = append(fields, store.FieldHandlingFee)
	}
	if m.addshipping_option != nil {
		fields = append(fields, store.FieldShippingOption)
	}
	if m.adddefault_warehouse != nil {
		fields = append(fields, store.FieldDefaultWarehouse)
	}
	if m.addprepay_tariff != nil {
		fields = append(fields, store.FieldPrepayTariff)
	}
	if m.addstorage_unit_price != nil {
		fields = append(fields, store.FieldStorageUnitPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldTimezoneOffset:
		return m.AddedTimezoneOffset()
	case store.FieldInitialStatus:
		return m.AddedInitialStatus()
	case store.FieldTimestamp:
		return m.AddedTimestamp()
	case store.FieldBalance:
		return m.AddedBalance()
	case store.FieldHandlingFee:
		return m.AddedHandlingFee()
	case store.FieldShippingOption:
		return m.AddedShippingOption()
	case store.FieldDefaultWarehouse:
		return m.AddedDefaultWarehouse()
	case store.FieldPrepayTariff:
		return m.AddedPrepayTariff()
	case store.FieldStorageUnitPrice:
		return m.AddedStorageUnitPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldTimezoneOffset:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimezoneOffset(v)
		return nil
	case store.FieldInitialStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialStatus(v)
		return nil
	case store.FieldTimestamp:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	case store.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case store.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandlingFee(v)
		return nil
	case store.FieldShippingOption:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingOption(v)
		return nil
	case store.FieldDefaultWarehouse:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultWarehouse(v)
		return nil
	case store.FieldPrepayTariff:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrepayTariff(v)
		return nil
	case store.FieldStorageUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageUnitPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(store.FieldDeletedAt) {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.FieldCleared(store.FieldLocations) {
		fields = append(fields, store.FieldLocations)
	}
	if m.FieldCleared(store.FieldPresetChannelIds) {
		fields = append(fields, store.FieldPresetChannelIds)
	}
	if m.FieldCleared(store.FieldTestChannelIds) {
		fields = append(fields, store.FieldTestChannelIds)
	}
	if m.FieldCleared(store.FieldFirstInboundAt) {
		fields = append(fields, store.FieldFirstInboundAt)
	}
	if m.FieldCleared(store.FieldIntegrationAt) {
		fields = append(fields, store.FieldIntegrationAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	switch name {
	case store.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case store.FieldLocations:
		m.ClearLocations()
		return nil
	case store.FieldPresetChannelIds:
		m.ClearPresetChannelIds()
		return nil
	case store.FieldTestChannelIds:
		m.ClearTestChannelIds()
		return nil
	case store.FieldFirstInboundAt:
		m.ClearFirstInboundAt()
		return nil
	case store.FieldIntegrationAt:
		m.ClearIntegrationAt()
		return nil
	}
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case store.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case store.FieldStoreURL:
		m.ResetStoreURL()
		return nil
	case store.FieldPlatform:
		m.ResetPlatform()
		return nil
	case store.FieldName:
		m.ResetName()
		return nil
	case store.FieldCode:
		m.ResetCode()
		return nil
	case store.FieldEmail:
		m.ResetEmail()
		return nil
	case store.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case store.FieldTimezoneOffset:
		m.ResetTimezoneOffset()
		return nil
	case store.FieldScope:
		m.ResetScope()
		return nil
	case store.FieldLocationID:
		m.ResetLocationID()
		return nil
	case store.FieldLocations:
		m.ResetLocations()
		return nil
	case store.FieldStoreCurrency:
		m.ResetStoreCurrency()
		return nil
	case store.FieldInitialStatus:
		m.ResetInitialStatus()
		return nil
	case store.FieldState:
		m.ResetState()
		return nil
	case store.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case store.FieldNonce:
		m.ResetNonce()
		return nil
	case store.FieldBalance:
		m.ResetBalance()
		return nil
	case store.FieldCurrency:
		m.ResetCurrency()
		return nil
	case store.FieldHandlingFee:
		m.ResetHandlingFee()
		return nil
	case store.FieldShippingOption:
		m.ResetShippingOption()
		return nil
	case store.FieldDefaultWarehouse:
		m.ResetDefaultWarehouse()
		return nil
	case store.FieldPrepayTariff:
		m.ResetPrepayTariff()
		return nil
	case store.FieldIossNumber:
		m.ResetIossNumber()
		return nil
	case store.FieldIossCountryCode:
		m.ResetIossCountryCode()
		return nil
	case store.FieldUkVatNumber:
		m.ResetUkVatNumber()
		return nil
	case store.FieldStoreCode:
		m.ResetStoreCode()
		return nil
	case store.FieldPresetChannelIds:
		m.ResetPresetChannelIds()
		return nil
	case store.FieldTestChannelIds:
		m.ResetTestChannelIds()
		return nil
	case store.FieldFirstInboundAt:
		m.ResetFirstInboundAt()
		return nil
	case store.FieldStorageUnitPrice:
		m.ResetStorageUnitPrice()
		return nil
	case store.FieldIntegrationAt:
		m.ResetIntegrationAt()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, store.EdgeTenant)
	}
	if m.orders != nil {
		edges = append(edges, store.EdgeOrders)
	}
	if m.platform_products != nil {
		edges = append(edges, store.EdgePlatformProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case store.EdgePlatformProducts:
		ids := make([]ent.Value, 0, len(m.platform_products))
		for id := range m.platform_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorders != nil {
		edges = append(edges, store.EdgeOrders)
	}
	if m.removedplatform_products != nil {
		edges = append(edges, store.EdgePlatformProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case store.EdgePlatformProducts:
		ids := make([]ent.Value, 0, len(m.removedplatform_products))
		for id := range m.removedplatform_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, store.EdgeTenant)
	}
	if m.clearedorders {
		edges = append(edges, store.EdgeOrders)
	}
	if m.clearedplatform_products {
		edges = append(edges, store.EdgePlatformProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeTenant:
		return m.clearedtenant
	case store.EdgeOrders:
		return m.clearedorders
	case store.EdgePlatformProducts:
		return m.clearedplatform_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	case store.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeTenant:
		m.ResetTenant()
		return nil
	case store.EdgeOrders:
		m.ResetOrders()
		return nil
	case store.EdgePlatformProducts:
		m.ResetPlatformProducts()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}

// TaskScheduleMutation represents an operation that mutates the TaskSchedule nodes in the graph.
type TaskScheduleMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	platform        *string
	store_id        *int64
	addstore_id     *int64
	func_name       *string
	description     *string
	locked          *bool
	locked_times    *int64
	addlocked_times *int64
	remark          *string
	last_access_at  *time.Time
	status          *int8
	addstatus       *int8
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TaskSchedule, error)
	predicates      []predicate.TaskSchedule
}

var _ ent.Mutation = (*TaskScheduleMutation)(nil)

// taskscheduleOption allows management of the mutation configuration using functional options.
type taskscheduleOption func(*TaskScheduleMutation)

// newTaskScheduleMutation creates new mutation for the TaskSchedule entity.
func newTaskScheduleMutation(c config, op Op, opts ...taskscheduleOption) *TaskScheduleMutation {
	m := &TaskScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskScheduleID sets the ID field of the mutation.
func withTaskScheduleID(id int64) taskscheduleOption {
	return func(m *TaskScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskSchedule
		)
		m.oldValue = func(ctx context.Context) (*TaskSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskSchedule sets the old TaskSchedule of the mutation.
func withTaskSchedule(node *TaskSchedule) taskscheduleOption {
	return func(m *TaskScheduleMutation) {
		m.oldValue = func(context.Context) (*TaskSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskSchedule entities.
func (m *TaskScheduleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskScheduleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskScheduleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskScheduleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskScheduleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskScheduleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[taskschedule.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskScheduleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[taskschedule.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskScheduleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, taskschedule.FieldDeletedAt)
}

// SetPlatform sets the "platform" field.
func (m *TaskScheduleMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *TaskScheduleMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *TaskScheduleMutation) ResetPlatform() {
	m.platform = nil
}

// SetStoreID sets the "store_id" field.
func (m *TaskScheduleMutation) SetStoreID(i int64) {
	m.store_id = &i
	m.addstore_id = nil
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *TaskScheduleMutation) StoreID() (r int64, exists bool) {
	v := m.store_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldStoreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// AddStoreID adds i to the "store_id" field.
func (m *TaskScheduleMutation) AddStoreID(i int64) {
	if m.addstore_id != nil {
		*m.addstore_id += i
	} else {
		m.addstore_id = &i
	}
}

// AddedStoreID returns the value that was added to the "store_id" field in this mutation.
func (m *TaskScheduleMutation) AddedStoreID() (r int64, exists bool) {
	v := m.addstore_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStoreID clears the value of the "store_id" field.
func (m *TaskScheduleMutation) ClearStoreID() {
	m.store_id = nil
	m.addstore_id = nil
	m.clearedFields[taskschedule.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *TaskScheduleMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[taskschedule.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *TaskScheduleMutation) ResetStoreID() {
	m.store_id = nil
	m.addstore_id = nil
	delete(m.clearedFields, taskschedule.FieldStoreID)
}

// SetFuncName sets the "func_name" field.
func (m *TaskScheduleMutation) SetFuncName(s string) {
	m.func_name = &s
}

// FuncName returns the value of the "func_name" field in the mutation.
func (m *TaskScheduleMutation) FuncName() (r string, exists bool) {
	v := m.func_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFuncName returns the old "func_name" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldFuncName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuncName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuncName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuncName: %w", err)
	}
	return oldValue.FuncName, nil
}

// ResetFuncName resets all changes to the "func_name" field.
func (m *TaskScheduleMutation) ResetFuncName() {
	m.func_name = nil
}

// SetDescription sets the "description" field.
func (m *TaskScheduleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskScheduleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskScheduleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[taskschedule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskScheduleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[taskschedule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskScheduleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, taskschedule.FieldDescription)
}

// SetLocked sets the "locked" field.
func (m *TaskScheduleMutation) SetLocked(b bool) {
	m.locked = &b
}

// Locked returns the value of the "locked" field in the mutation.
func (m *TaskScheduleMutation) Locked() (r bool, exists bool) {
	v := m.locked
	if v == nil {
		return
	}
	return *v, true
}

// OldLocked returns the old "locked" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldLocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocked: %w", err)
	}
	return oldValue.Locked, nil
}

// ResetLocked resets all changes to the "locked" field.
func (m *TaskScheduleMutation) ResetLocked() {
	m.locked = nil
}

// SetLockedTimes sets the "locked_times" field.
func (m *TaskScheduleMutation) SetLockedTimes(i int64) {
	m.locked_times = &i
	m.addlocked_times = nil
}

// LockedTimes returns the value of the "locked_times" field in the mutation.
func (m *TaskScheduleMutation) LockedTimes() (r int64, exists bool) {
	v := m.locked_times
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedTimes returns the old "locked_times" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldLockedTimes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedTimes: %w", err)
	}
	return oldValue.LockedTimes, nil
}

// AddLockedTimes adds i to the "locked_times" field.
func (m *TaskScheduleMutation) AddLockedTimes(i int64) {
	if m.addlocked_times != nil {
		*m.addlocked_times += i
	} else {
		m.addlocked_times = &i
	}
}

// AddedLockedTimes returns the value that was added to the "locked_times" field in this mutation.
func (m *TaskScheduleMutation) AddedLockedTimes() (r int64, exists bool) {
	v := m.addlocked_times
	if v == nil {
		return
	}
	return *v, true
}

// ResetLockedTimes resets all changes to the "locked_times" field.
func (m *TaskScheduleMutation) ResetLockedTimes() {
	m.locked_times = nil
	m.addlocked_times = nil
}

// SetRemark sets the "remark" field.
func (m *TaskScheduleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TaskScheduleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TaskScheduleMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[taskschedule.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TaskScheduleMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[taskschedule.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TaskScheduleMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, taskschedule.FieldRemark)
}

// SetLastAccessAt sets the "last_access_at" field.
func (m *TaskScheduleMutation) SetLastAccessAt(t time.Time) {
	m.last_access_at = &t
}

// LastAccessAt returns the value of the "last_access_at" field in the mutation.
func (m *TaskScheduleMutation) LastAccessAt() (r time.Time, exists bool) {
	v := m.last_access_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessAt returns the old "last_access_at" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldLastAccessAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessAt: %w", err)
	}
	return oldValue.LastAccessAt, nil
}

// ClearLastAccessAt clears the value of the "last_access_at" field.
func (m *TaskScheduleMutation) ClearLastAccessAt() {
	m.last_access_at = nil
	m.clearedFields[taskschedule.FieldLastAccessAt] = struct{}{}
}

// LastAccessAtCleared returns if the "last_access_at" field was cleared in this mutation.
func (m *TaskScheduleMutation) LastAccessAtCleared() bool {
	_, ok := m.clearedFields[taskschedule.FieldLastAccessAt]
	return ok
}

// ResetLastAccessAt resets all changes to the "last_access_at" field.
func (m *TaskScheduleMutation) ResetLastAccessAt() {
	m.last_access_at = nil
	delete(m.clearedFields, taskschedule.FieldLastAccessAt)
}

// SetStatus sets the "status" field.
func (m *TaskScheduleMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskScheduleMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TaskSchedule entity.
// If the TaskSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskScheduleMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TaskScheduleMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TaskScheduleMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskScheduleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the TaskScheduleMutation builder.
func (m *TaskScheduleMutation) Where(ps ...predicate.TaskSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskSchedule).
func (m *TaskScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskScheduleMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, taskschedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskschedule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, taskschedule.FieldDeletedAt)
	}
	if m.platform != nil {
		fields = append(fields, taskschedule.FieldPlatform)
	}
	if m.store_id != nil {
		fields = append(fields, taskschedule.FieldStoreID)
	}
	if m.func_name != nil {
		fields = append(fields, taskschedule.FieldFuncName)
	}
	if m.description != nil {
		fields = append(fields, taskschedule.FieldDescription)
	}
	if m.locked != nil {
		fields = append(fields, taskschedule.FieldLocked)
	}
	if m.locked_times != nil {
		fields = append(fields, taskschedule.FieldLockedTimes)
	}
	if m.remark != nil {
		fields = append(fields, taskschedule.FieldRemark)
	}
	if m.last_access_at != nil {
		fields = append(fields, taskschedule.FieldLastAccessAt)
	}
	if m.status != nil {
		fields = append(fields, taskschedule.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskschedule.FieldCreatedAt:
		return m.CreatedAt()
	case taskschedule.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskschedule.FieldDeletedAt:
		return m.DeletedAt()
	case taskschedule.FieldPlatform:
		return m.Platform()
	case taskschedule.FieldStoreID:
		return m.StoreID()
	case taskschedule.FieldFuncName:
		return m.FuncName()
	case taskschedule.FieldDescription:
		return m.Description()
	case taskschedule.FieldLocked:
		return m.Locked()
	case taskschedule.FieldLockedTimes:
		return m.LockedTimes()
	case taskschedule.FieldRemark:
		return m.Remark()
	case taskschedule.FieldLastAccessAt:
		return m.LastAccessAt()
	case taskschedule.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskschedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskschedule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case taskschedule.FieldPlatform:
		return m.OldPlatform(ctx)
	case taskschedule.FieldStoreID:
		return m.OldStoreID(ctx)
	case taskschedule.FieldFuncName:
		return m.OldFuncName(ctx)
	case taskschedule.FieldDescription:
		return m.OldDescription(ctx)
	case taskschedule.FieldLocked:
		return m.OldLocked(ctx)
	case taskschedule.FieldLockedTimes:
		return m.OldLockedTimes(ctx)
	case taskschedule.FieldRemark:
		return m.OldRemark(ctx)
	case taskschedule.FieldLastAccessAt:
		return m.OldLastAccessAt(ctx)
	case taskschedule.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown TaskSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskschedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskschedule.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case taskschedule.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case taskschedule.FieldStoreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case taskschedule.FieldFuncName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuncName(v)
		return nil
	case taskschedule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case taskschedule.FieldLocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocked(v)
		return nil
	case taskschedule.FieldLockedTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedTimes(v)
		return nil
	case taskschedule.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case taskschedule.FieldLastAccessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessAt(v)
		return nil
	case taskschedule.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TaskSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addstore_id != nil {
		fields = append(fields, taskschedule.FieldStoreID)
	}
	if m.addlocked_times != nil {
		fields = append(fields, taskschedule.FieldLockedTimes)
	}
	if m.addstatus != nil {
		fields = append(fields, taskschedule.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taskschedule.FieldStoreID:
		return m.AddedStoreID()
	case taskschedule.FieldLockedTimes:
		return m.AddedLockedTimes()
	case taskschedule.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taskschedule.FieldStoreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreID(v)
		return nil
	case taskschedule.FieldLockedTimes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLockedTimes(v)
		return nil
	case taskschedule.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown TaskSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(taskschedule.FieldDeletedAt) {
		fields = append(fields, taskschedule.FieldDeletedAt)
	}
	if m.FieldCleared(taskschedule.FieldStoreID) {
		fields = append(fields, taskschedule.FieldStoreID)
	}
	if m.FieldCleared(taskschedule.FieldDescription) {
		fields = append(fields, taskschedule.FieldDescription)
	}
	if m.FieldCleared(taskschedule.FieldRemark) {
		fields = append(fields, taskschedule.FieldRemark)
	}
	if m.FieldCleared(taskschedule.FieldLastAccessAt) {
		fields = append(fields, taskschedule.FieldLastAccessAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskScheduleMutation) ClearField(name string) error {
	switch name {
	case taskschedule.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case taskschedule.FieldStoreID:
		m.ClearStoreID()
		return nil
	case taskschedule.FieldDescription:
		m.ClearDescription()
		return nil
	case taskschedule.FieldRemark:
		m.ClearRemark()
		return nil
	case taskschedule.FieldLastAccessAt:
		m.ClearLastAccessAt()
		return nil
	}
	return fmt.Errorf("unknown TaskSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskScheduleMutation) ResetField(name string) error {
	switch name {
	case taskschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskschedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskschedule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case taskschedule.FieldPlatform:
		m.ResetPlatform()
		return nil
	case taskschedule.FieldStoreID:
		m.ResetStoreID()
		return nil
	case taskschedule.FieldFuncName:
		m.ResetFuncName()
		return nil
	case taskschedule.FieldDescription:
		m.ResetDescription()
		return nil
	case taskschedule.FieldLocked:
		m.ResetLocked()
		return nil
	case taskschedule.FieldLockedTimes:
		m.ResetLockedTimes()
		return nil
	case taskschedule.FieldRemark:
		m.ResetRemark()
		return nil
	case taskschedule.FieldLastAccessAt:
		m.ResetLastAccessAt()
		return nil
	case taskschedule.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown TaskSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskScheduleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskScheduleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskScheduleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskScheduleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TaskSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskScheduleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TaskSchedule edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	code                  *string
	balance               *float64
	addbalance            *float64
	currency              *string
	handling_fee          *float64
	addhandling_fee       *float64
	shipping_option       *int8
	addshipping_option    *int8
	prepay_tariff         *int8
	addprepay_tariff      *int8
	ioss_number           *string
	ioss_country_code     *string
	uk_vat_number         *string
	default_warehouse     *int64
	adddefault_warehouse  *int64
	preset_channel_ids    *string
	test_channel_ids      *string
	first_inbound_at      *time.Time
	storage_unit_price    *float64
	addstorage_unit_price *float64
	cs_user_id            *int64
	addcs_user_id         *int64
	sales_user_id         *int64
	addsales_user_id      *int64
	inviter_user_id       *int64
	addinviter_user_id    *int64
	platform              *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*Tenant, error)
	predicates            []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int64) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TenantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TenantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TenantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tenant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TenantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TenantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tenant.FieldDeletedAt)
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// SetBalance sets the "balance" field.
func (m *TenantMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TenantMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *TenantMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TenantMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TenantMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetCurrency sets the "currency" field.
func (m *TenantMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *TenantMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *TenantMutation) ResetCurrency() {
	m.currency = nil
}

// SetHandlingFee sets the "handling_fee" field.
func (m *TenantMutation) SetHandlingFee(f float64) {
	m.handling_fee = &f
	m.addhandling_fee = nil
}

// HandlingFee returns the value of the "handling_fee" field in the mutation.
func (m *TenantMutation) HandlingFee() (r float64, exists bool) {
	v := m.handling_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlingFee returns the old "handling_fee" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldHandlingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlingFee: %w", err)
	}
	return oldValue.HandlingFee, nil
}

// AddHandlingFee adds f to the "handling_fee" field.
func (m *TenantMutation) AddHandlingFee(f float64) {
	if m.addhandling_fee != nil {
		*m.addhandling_fee += f
	} else {
		m.addhandling_fee = &f
	}
}

// AddedHandlingFee returns the value that was added to the "handling_fee" field in this mutation.
func (m *TenantMutation) AddedHandlingFee() (r float64, exists bool) {
	v := m.addhandling_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandlingFee resets all changes to the "handling_fee" field.
func (m *TenantMutation) ResetHandlingFee() {
	m.handling_fee = nil
	m.addhandling_fee = nil
}

// SetShippingOption sets the "shipping_option" field.
func (m *TenantMutation) SetShippingOption(i int8) {
	m.shipping_option = &i
	m.addshipping_option = nil
}

// ShippingOption returns the value of the "shipping_option" field in the mutation.
func (m *TenantMutation) ShippingOption() (r int8, exists bool) {
	v := m.shipping_option
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingOption returns the old "shipping_option" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldShippingOption(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingOption: %w", err)
	}
	return oldValue.ShippingOption, nil
}

// AddShippingOption adds i to the "shipping_option" field.
func (m *TenantMutation) AddShippingOption(i int8) {
	if m.addshipping_option != nil {
		*m.addshipping_option += i
	} else {
		m.addshipping_option = &i
	}
}

// AddedShippingOption returns the value that was added to the "shipping_option" field in this mutation.
func (m *TenantMutation) AddedShippingOption() (r int8, exists bool) {
	v := m.addshipping_option
	if v == nil {
		return
	}
	return *v, true
}

// ResetShippingOption resets all changes to the "shipping_option" field.
func (m *TenantMutation) ResetShippingOption() {
	m.shipping_option = nil
	m.addshipping_option = nil
}

// SetPrepayTariff sets the "prepay_tariff" field.
func (m *TenantMutation) SetPrepayTariff(i int8) {
	m.prepay_tariff = &i
	m.addprepay_tariff = nil
}

// PrepayTariff returns the value of the "prepay_tariff" field in the mutation.
func (m *TenantMutation) PrepayTariff() (r int8, exists bool) {
	v := m.prepay_tariff
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepayTariff returns the old "prepay_tariff" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPrepayTariff(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepayTariff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepayTariff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepayTariff: %w", err)
	}
	return oldValue.PrepayTariff, nil
}

// AddPrepayTariff adds i to the "prepay_tariff" field.
func (m *TenantMutation) AddPrepayTariff(i int8) {
	if m.addprepay_tariff != nil {
		*m.addprepay_tariff += i
	} else {
		m.addprepay_tariff = &i
	}
}

// AddedPrepayTariff returns the value that was added to the "prepay_tariff" field in this mutation.
func (m *TenantMutation) AddedPrepayTariff() (r int8, exists bool) {
	v := m.addprepay_tariff
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrepayTariff resets all changes to the "prepay_tariff" field.
func (m *TenantMutation) ResetPrepayTariff() {
	m.prepay_tariff = nil
	m.addprepay_tariff = nil
}

// SetIossNumber sets the "ioss_number" field.
func (m *TenantMutation) SetIossNumber(s string) {
	m.ioss_number = &s
}

// IossNumber returns the value of the "ioss_number" field in the mutation.
func (m *TenantMutation) IossNumber() (r string, exists bool) {
	v := m.ioss_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIossNumber returns the old "ioss_number" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldIossNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossNumber: %w", err)
	}
	return oldValue.IossNumber, nil
}

// ResetIossNumber resets all changes to the "ioss_number" field.
func (m *TenantMutation) ResetIossNumber() {
	m.ioss_number = nil
}

// SetIossCountryCode sets the "ioss_country_code" field.
func (m *TenantMutation) SetIossCountryCode(s string) {
	m.ioss_country_code = &s
}

// IossCountryCode returns the value of the "ioss_country_code" field in the mutation.
func (m *TenantMutation) IossCountryCode() (r string, exists bool) {
	v := m.ioss_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIossCountryCode returns the old "ioss_country_code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldIossCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIossCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIossCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIossCountryCode: %w", err)
	}
	return oldValue.IossCountryCode, nil
}

// ResetIossCountryCode resets all changes to the "ioss_country_code" field.
func (m *TenantMutation) ResetIossCountryCode() {
	m.ioss_country_code = nil
}

// SetUkVatNumber sets the "uk_vat_number" field.
func (m *TenantMutation) SetUkVatNumber(s string) {
	m.uk_vat_number = &s
}

// UkVatNumber returns the value of the "uk_vat_number" field in the mutation.
func (m *TenantMutation) UkVatNumber() (r string, exists bool) {
	v := m.uk_vat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldUkVatNumber returns the old "uk_vat_number" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUkVatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUkVatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUkVatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUkVatNumber: %w", err)
	}
	return oldValue.UkVatNumber, nil
}

// ResetUkVatNumber resets all changes to the "uk_vat_number" field.
func (m *TenantMutation) ResetUkVatNumber() {
	m.uk_vat_number = nil
}

// SetDefaultWarehouse sets the "default_warehouse" field.
func (m *TenantMutation) SetDefaultWarehouse(i int64) {
	m.default_warehouse = &i
	m.adddefault_warehouse = nil
}

// DefaultWarehouse returns the value of the "default_warehouse" field in the mutation.
func (m *TenantMutation) DefaultWarehouse() (r int64, exists bool) {
	v := m.default_warehouse
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultWarehouse returns the old "default_warehouse" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDefaultWarehouse(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultWarehouse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultWarehouse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultWarehouse: %w", err)
	}
	return oldValue.DefaultWarehouse, nil
}

// AddDefaultWarehouse adds i to the "default_warehouse" field.
func (m *TenantMutation) AddDefaultWarehouse(i int64) {
	if m.adddefault_warehouse != nil {
		*m.adddefault_warehouse += i
	} else {
		m.adddefault_warehouse = &i
	}
}

// AddedDefaultWarehouse returns the value that was added to the "default_warehouse" field in this mutation.
func (m *TenantMutation) AddedDefaultWarehouse() (r int64, exists bool) {
	v := m.adddefault_warehouse
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultWarehouse resets all changes to the "default_warehouse" field.
func (m *TenantMutation) ResetDefaultWarehouse() {
	m.default_warehouse = nil
	m.adddefault_warehouse = nil
}

// SetPresetChannelIds sets the "preset_channel_ids" field.
func (m *TenantMutation) SetPresetChannelIds(s string) {
	m.preset_channel_ids = &s
}

// PresetChannelIds returns the value of the "preset_channel_ids" field in the mutation.
func (m *TenantMutation) PresetChannelIds() (r string, exists bool) {
	v := m.preset_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldPresetChannelIds returns the old "preset_channel_ids" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPresetChannelIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPresetChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPresetChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresetChannelIds: %w", err)
	}
	return oldValue.PresetChannelIds, nil
}

// ClearPresetChannelIds clears the value of the "preset_channel_ids" field.
func (m *TenantMutation) ClearPresetChannelIds() {
	m.preset_channel_ids = nil
	m.clearedFields[tenant.FieldPresetChannelIds] = struct{}{}
}

// PresetChannelIdsCleared returns if the "preset_channel_ids" field was cleared in this mutation.
func (m *TenantMutation) PresetChannelIdsCleared() bool {
	_, ok := m.clearedFields[tenant.FieldPresetChannelIds]
	return ok
}

// ResetPresetChannelIds resets all changes to the "preset_channel_ids" field.
func (m *TenantMutation) ResetPresetChannelIds() {
	m.preset_channel_ids = nil
	delete(m.clearedFields, tenant.FieldPresetChannelIds)
}

// SetTestChannelIds sets the "test_channel_ids" field.
func (m *TenantMutation) SetTestChannelIds(s string) {
	m.test_channel_ids = &s
}

// TestChannelIds returns the value of the "test_channel_ids" field in the mutation.
func (m *TenantMutation) TestChannelIds() (r string, exists bool) {
	v := m.test_channel_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldTestChannelIds returns the old "test_channel_ids" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTestChannelIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestChannelIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestChannelIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestChannelIds: %w", err)
	}
	return oldValue.TestChannelIds, nil
}

// ClearTestChannelIds clears the value of the "test_channel_ids" field.
func (m *TenantMutation) ClearTestChannelIds() {
	m.test_channel_ids = nil
	m.clearedFields[tenant.FieldTestChannelIds] = struct{}{}
}

// TestChannelIdsCleared returns if the "test_channel_ids" field was cleared in this mutation.
func (m *TenantMutation) TestChannelIdsCleared() bool {
	_, ok := m.clearedFields[tenant.FieldTestChannelIds]
	return ok
}

// ResetTestChannelIds resets all changes to the "test_channel_ids" field.
func (m *TenantMutation) ResetTestChannelIds() {
	m.test_channel_ids = nil
	delete(m.clearedFields, tenant.FieldTestChannelIds)
}

// SetFirstInboundAt sets the "first_inbound_at" field.
func (m *TenantMutation) SetFirstInboundAt(t time.Time) {
	m.first_inbound_at = &t
}

// FirstInboundAt returns the value of the "first_inbound_at" field in the mutation.
func (m *TenantMutation) FirstInboundAt() (r time.Time, exists bool) {
	v := m.first_inbound_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstInboundAt returns the old "first_inbound_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldFirstInboundAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstInboundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstInboundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstInboundAt: %w", err)
	}
	return oldValue.FirstInboundAt, nil
}

// ClearFirstInboundAt clears the value of the "first_inbound_at" field.
func (m *TenantMutation) ClearFirstInboundAt() {
	m.first_inbound_at = nil
	m.clearedFields[tenant.FieldFirstInboundAt] = struct{}{}
}

// FirstInboundAtCleared returns if the "first_inbound_at" field was cleared in this mutation.
func (m *TenantMutation) FirstInboundAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldFirstInboundAt]
	return ok
}

// ResetFirstInboundAt resets all changes to the "first_inbound_at" field.
func (m *TenantMutation) ResetFirstInboundAt() {
	m.first_inbound_at = nil
	delete(m.clearedFields, tenant.FieldFirstInboundAt)
}

// SetStorageUnitPrice sets the "storage_unit_price" field.
func (m *TenantMutation) SetStorageUnitPrice(f float64) {
	m.storage_unit_price = &f
	m.addstorage_unit_price = nil
}

// StorageUnitPrice returns the value of the "storage_unit_price" field in the mutation.
func (m *TenantMutation) StorageUnitPrice() (r float64, exists bool) {
	v := m.storage_unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageUnitPrice returns the old "storage_unit_price" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStorageUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageUnitPrice: %w", err)
	}
	return oldValue.StorageUnitPrice, nil
}

// AddStorageUnitPrice adds f to the "storage_unit_price" field.
func (m *TenantMutation) AddStorageUnitPrice(f float64) {
	if m.addstorage_unit_price != nil {
		*m.addstorage_unit_price += f
	} else {
		m.addstorage_unit_price = &f
	}
}

// AddedStorageUnitPrice returns the value that was added to the "storage_unit_price" field in this mutation.
func (m *TenantMutation) AddedStorageUnitPrice() (r float64, exists bool) {
	v := m.addstorage_unit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetStorageUnitPrice resets all changes to the "storage_unit_price" field.
func (m *TenantMutation) ResetStorageUnitPrice() {
	m.storage_unit_price = nil
	m.addstorage_unit_price = nil
}

// SetCsUserID sets the "cs_user_id" field.
func (m *TenantMutation) SetCsUserID(i int64) {
	m.cs_user_id = &i
	m.addcs_user_id = nil
}

// CsUserID returns the value of the "cs_user_id" field in the mutation.
func (m *TenantMutation) CsUserID() (r int64, exists bool) {
	v := m.cs_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCsUserID returns the old "cs_user_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCsUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCsUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCsUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCsUserID: %w", err)
	}
	return oldValue.CsUserID, nil
}

// AddCsUserID adds i to the "cs_user_id" field.
func (m *TenantMutation) AddCsUserID(i int64) {
	if m.addcs_user_id != nil {
		*m.addcs_user_id += i
	} else {
		m.addcs_user_id = &i
	}
}

// AddedCsUserID returns the value that was added to the "cs_user_id" field in this mutation.
func (m *TenantMutation) AddedCsUserID() (r int64, exists bool) {
	v := m.addcs_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCsUserID clears the value of the "cs_user_id" field.
func (m *TenantMutation) ClearCsUserID() {
	m.cs_user_id = nil
	m.addcs_user_id = nil
	m.clearedFields[tenant.FieldCsUserID] = struct{}{}
}

// CsUserIDCleared returns if the "cs_user_id" field was cleared in this mutation.
func (m *TenantMutation) CsUserIDCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCsUserID]
	return ok
}

// ResetCsUserID resets all changes to the "cs_user_id" field.
func (m *TenantMutation) ResetCsUserID() {
	m.cs_user_id = nil
	m.addcs_user_id = nil
	delete(m.clearedFields, tenant.FieldCsUserID)
}

// SetSalesUserID sets the "sales_user_id" field.
func (m *TenantMutation) SetSalesUserID(i int64) {
	m.sales_user_id = &i
	m.addsales_user_id = nil
}

// SalesUserID returns the value of the "sales_user_id" field in the mutation.
func (m *TenantMutation) SalesUserID() (r int64, exists bool) {
	v := m.sales_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesUserID returns the old "sales_user_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldSalesUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesUserID: %w", err)
	}
	return oldValue.SalesUserID, nil
}

// AddSalesUserID adds i to the "sales_user_id" field.
func (m *TenantMutation) AddSalesUserID(i int64) {
	if m.addsales_user_id != nil {
		*m.addsales_user_id += i
	} else {
		m.addsales_user_id = &i
	}
}

// AddedSalesUserID returns the value that was added to the "sales_user_id" field in this mutation.
func (m *TenantMutation) AddedSalesUserID() (r int64, exists bool) {
	v := m.addsales_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesUserID clears the value of the "sales_user_id" field.
func (m *TenantMutation) ClearSalesUserID() {
	m.sales_user_id = nil
	m.addsales_user_id = nil
	m.clearedFields[tenant.FieldSalesUserID] = struct{}{}
}

// SalesUserIDCleared returns if the "sales_user_id" field was cleared in this mutation.
func (m *TenantMutation) SalesUserIDCleared() bool {
	_, ok := m.clearedFields[tenant.FieldSalesUserID]
	return ok
}

// ResetSalesUserID resets all changes to the "sales_user_id" field.
func (m *TenantMutation) ResetSalesUserID() {
	m.sales_user_id = nil
	m.addsales_user_id = nil
	delete(m.clearedFields, tenant.FieldSalesUserID)
}

// SetInviterUserID sets the "inviter_user_id" field.
func (m *TenantMutation) SetInviterUserID(i int64) {
	m.inviter_user_id = &i
	m.addinviter_user_id = nil
}

// InviterUserID returns the value of the "inviter_user_id" field in the mutation.
func (m *TenantMutation) InviterUserID() (r int64, exists bool) {
	v := m.inviter_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterUserID returns the old "inviter_user_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldInviterUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterUserID: %w", err)
	}
	return oldValue.InviterUserID, nil
}

// AddInviterUserID adds i to the "inviter_user_id" field.
func (m *TenantMutation) AddInviterUserID(i int64) {
	if m.addinviter_user_id != nil {
		*m.addinviter_user_id += i
	} else {
		m.addinviter_user_id = &i
	}
}

// AddedInviterUserID returns the value that was added to the "inviter_user_id" field in this mutation.
func (m *TenantMutation) AddedInviterUserID() (r int64, exists bool) {
	v := m.addinviter_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInviterUserID clears the value of the "inviter_user_id" field.
func (m *TenantMutation) ClearInviterUserID() {
	m.inviter_user_id = nil
	m.addinviter_user_id = nil
	m.clearedFields[tenant.FieldInviterUserID] = struct{}{}
}

// InviterUserIDCleared returns if the "inviter_user_id" field was cleared in this mutation.
func (m *TenantMutation) InviterUserIDCleared() bool {
	_, ok := m.clearedFields[tenant.FieldInviterUserID]
	return ok
}

// ResetInviterUserID resets all changes to the "inviter_user_id" field.
func (m *TenantMutation) ResetInviterUserID() {
	m.inviter_user_id = nil
	m.addinviter_user_id = nil
	delete(m.clearedFields, tenant.FieldInviterUserID)
}

// SetPlatform sets the "platform" field.
func (m *TenantMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *TenantMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *TenantMutation) ResetPlatform() {
	m.platform = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.balance != nil {
		fields = append(fields, tenant.FieldBalance)
	}
	if m.currency != nil {
		fields = append(fields, tenant.FieldCurrency)
	}
	if m.handling_fee != nil {
		fields = append(fields, tenant.FieldHandlingFee)
	}
	if m.shipping_option != nil {
		fields = append(fields, tenant.FieldShippingOption)
	}
	if m.prepay_tariff != nil {
		fields = append(fields, tenant.FieldPrepayTariff)
	}
	if m.ioss_number != nil {
		fields = append(fields, tenant.FieldIossNumber)
	}
	if m.ioss_country_code != nil {
		fields = append(fields, tenant.FieldIossCountryCode)
	}
	if m.uk_vat_number != nil {
		fields = append(fields, tenant.FieldUkVatNumber)
	}
	if m.default_warehouse != nil {
		fields = append(fields, tenant.FieldDefaultWarehouse)
	}
	if m.preset_channel_ids != nil {
		fields = append(fields, tenant.FieldPresetChannelIds)
	}
	if m.test_channel_ids != nil {
		fields = append(fields, tenant.FieldTestChannelIds)
	}
	if m.first_inbound_at != nil {
		fields = append(fields, tenant.FieldFirstInboundAt)
	}
	if m.storage_unit_price != nil {
		fields = append(fields, tenant.FieldStorageUnitPrice)
	}
	if m.cs_user_id != nil {
		fields = append(fields, tenant.FieldCsUserID)
	}
	if m.sales_user_id != nil {
		fields = append(fields, tenant.FieldSalesUserID)
	}
	if m.inviter_user_id != nil {
		fields = append(fields, tenant.FieldInviterUserID)
	}
	if m.platform != nil {
		fields = append(fields, tenant.FieldPlatform)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenant.FieldDeletedAt:
		return m.DeletedAt()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldBalance:
		return m.Balance()
	case tenant.FieldCurrency:
		return m.Currency()
	case tenant.FieldHandlingFee:
		return m.HandlingFee()
	case tenant.FieldShippingOption:
		return m.ShippingOption()
	case tenant.FieldPrepayTariff:
		return m.PrepayTariff()
	case tenant.FieldIossNumber:
		return m.IossNumber()
	case tenant.FieldIossCountryCode:
		return m.IossCountryCode()
	case tenant.FieldUkVatNumber:
		return m.UkVatNumber()
	case tenant.FieldDefaultWarehouse:
		return m.DefaultWarehouse()
	case tenant.FieldPresetChannelIds:
		return m.PresetChannelIds()
	case tenant.FieldTestChannelIds:
		return m.TestChannelIds()
	case tenant.FieldFirstInboundAt:
		return m.FirstInboundAt()
	case tenant.FieldStorageUnitPrice:
		return m.StorageUnitPrice()
	case tenant.FieldCsUserID:
		return m.CsUserID()
	case tenant.FieldSalesUserID:
		return m.SalesUserID()
	case tenant.FieldInviterUserID:
		return m.InviterUserID()
	case tenant.FieldPlatform:
		return m.Platform()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldBalance:
		return m.OldBalance(ctx)
	case tenant.FieldCurrency:
		return m.OldCurrency(ctx)
	case tenant.FieldHandlingFee:
		return m.OldHandlingFee(ctx)
	case tenant.FieldShippingOption:
		return m.OldShippingOption(ctx)
	case tenant.FieldPrepayTariff:
		return m.OldPrepayTariff(ctx)
	case tenant.FieldIossNumber:
		return m.OldIossNumber(ctx)
	case tenant.FieldIossCountryCode:
		return m.OldIossCountryCode(ctx)
	case tenant.FieldUkVatNumber:
		return m.OldUkVatNumber(ctx)
	case tenant.FieldDefaultWarehouse:
		return m.OldDefaultWarehouse(ctx)
	case tenant.FieldPresetChannelIds:
		return m.OldPresetChannelIds(ctx)
	case tenant.FieldTestChannelIds:
		return m.OldTestChannelIds(ctx)
	case tenant.FieldFirstInboundAt:
		return m.OldFirstInboundAt(ctx)
	case tenant.FieldStorageUnitPrice:
		return m.OldStorageUnitPrice(ctx)
	case tenant.FieldCsUserID:
		return m.OldCsUserID(ctx)
	case tenant.FieldSalesUserID:
		return m.OldSalesUserID(ctx)
	case tenant.FieldInviterUserID:
		return m.OldInviterUserID(ctx)
	case tenant.FieldPlatform:
		return m.OldPlatform(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case tenant.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case tenant.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlingFee(v)
		return nil
	case tenant.FieldShippingOption:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingOption(v)
		return nil
	case tenant.FieldPrepayTariff:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepayTariff(v)
		return nil
	case tenant.FieldIossNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossNumber(v)
		return nil
	case tenant.FieldIossCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIossCountryCode(v)
		return nil
	case tenant.FieldUkVatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUkVatNumber(v)
		return nil
	case tenant.FieldDefaultWarehouse:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultWarehouse(v)
		return nil
	case tenant.FieldPresetChannelIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresetChannelIds(v)
		return nil
	case tenant.FieldTestChannelIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestChannelIds(v)
		return nil
	case tenant.FieldFirstInboundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstInboundAt(v)
		return nil
	case tenant.FieldStorageUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageUnitPrice(v)
		return nil
	case tenant.FieldCsUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCsUserID(v)
		return nil
	case tenant.FieldSalesUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesUserID(v)
		return nil
	case tenant.FieldInviterUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterUserID(v)
		return nil
	case tenant.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, tenant.FieldBalance)
	}
	if m.addhandling_fee != nil {
		fields = append(fields, tenant.FieldHandlingFee)
	}
	if m.addshipping_option != nil {
		fields = append(fields, tenant.FieldShippingOption)
	}
	if m.addprepay_tariff != nil {
		fields = append(fields, tenant.FieldPrepayTariff)
	}
	if m.adddefault_warehouse != nil {
		fields = append(fields, tenant.FieldDefaultWarehouse)
	}
	if m.addstorage_unit_price != nil {
		fields = append(fields, tenant.FieldStorageUnitPrice)
	}
	if m.addcs_user_id != nil {
		fields = append(fields, tenant.FieldCsUserID)
	}
	if m.addsales_user_id != nil {
		fields = append(fields, tenant.FieldSalesUserID)
	}
	if m.addinviter_user_id != nil {
		fields = append(fields, tenant.FieldInviterUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldBalance:
		return m.AddedBalance()
	case tenant.FieldHandlingFee:
		return m.AddedHandlingFee()
	case tenant.FieldShippingOption:
		return m.AddedShippingOption()
	case tenant.FieldPrepayTariff:
		return m.AddedPrepayTariff()
	case tenant.FieldDefaultWarehouse:
		return m.AddedDefaultWarehouse()
	case tenant.FieldStorageUnitPrice:
		return m.AddedStorageUnitPrice()
	case tenant.FieldCsUserID:
		return m.AddedCsUserID()
	case tenant.FieldSalesUserID:
		return m.AddedSalesUserID()
	case tenant.FieldInviterUserID:
		return m.AddedInviterUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case tenant.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandlingFee(v)
		return nil
	case tenant.FieldShippingOption:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingOption(v)
		return nil
	case tenant.FieldPrepayTariff:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrepayTariff(v)
		return nil
	case tenant.FieldDefaultWarehouse:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultWarehouse(v)
		return nil
	case tenant.FieldStorageUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageUnitPrice(v)
		return nil
	case tenant.FieldCsUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCsUserID(v)
		return nil
	case tenant.FieldSalesUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesUserID(v)
		return nil
	case tenant.FieldInviterUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInviterUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDeletedAt) {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.FieldCleared(tenant.FieldPresetChannelIds) {
		fields = append(fields, tenant.FieldPresetChannelIds)
	}
	if m.FieldCleared(tenant.FieldTestChannelIds) {
		fields = append(fields, tenant.FieldTestChannelIds)
	}
	if m.FieldCleared(tenant.FieldFirstInboundAt) {
		fields = append(fields, tenant.FieldFirstInboundAt)
	}
	if m.FieldCleared(tenant.FieldCsUserID) {
		fields = append(fields, tenant.FieldCsUserID)
	}
	if m.FieldCleared(tenant.FieldSalesUserID) {
		fields = append(fields, tenant.FieldSalesUserID)
	}
	if m.FieldCleared(tenant.FieldInviterUserID) {
		fields = append(fields, tenant.FieldInviterUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tenant.FieldPresetChannelIds:
		m.ClearPresetChannelIds()
		return nil
	case tenant.FieldTestChannelIds:
		m.ClearTestChannelIds()
		return nil
	case tenant.FieldFirstInboundAt:
		m.ClearFirstInboundAt()
		return nil
	case tenant.FieldCsUserID:
		m.ClearCsUserID()
		return nil
	case tenant.FieldSalesUserID:
		m.ClearSalesUserID()
		return nil
	case tenant.FieldInviterUserID:
		m.ClearInviterUserID()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldBalance:
		m.ResetBalance()
		return nil
	case tenant.FieldCurrency:
		m.ResetCurrency()
		return nil
	case tenant.FieldHandlingFee:
		m.ResetHandlingFee()
		return nil
	case tenant.FieldShippingOption:
		m.ResetShippingOption()
		return nil
	case tenant.FieldPrepayTariff:
		m.ResetPrepayTariff()
		return nil
	case tenant.FieldIossNumber:
		m.ResetIossNumber()
		return nil
	case tenant.FieldIossCountryCode:
		m.ResetIossCountryCode()
		return nil
	case tenant.FieldUkVatNumber:
		m.ResetUkVatNumber()
		return nil
	case tenant.FieldDefaultWarehouse:
		m.ResetDefaultWarehouse()
		return nil
	case tenant.FieldPresetChannelIds:
		m.ResetPresetChannelIds()
		return nil
	case tenant.FieldTestChannelIds:
		m.ResetTestChannelIds()
		return nil
	case tenant.FieldFirstInboundAt:
		m.ResetFirstInboundAt()
		return nil
	case tenant.FieldStorageUnitPrice:
		m.ResetStorageUnitPrice()
		return nil
	case tenant.FieldCsUserID:
		m.ResetCsUserID()
		return nil
	case tenant.FieldSalesUserID:
		m.ResetSalesUserID()
		return nil
	case tenant.FieldInviterUserID:
		m.ResetInviterUserID()
		return nil
	case tenant.FieldPlatform:
		m.ResetPlatform()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	platform           *string
	token              *string
	refresh_token      *string
	pin                *string
	trace_id           *string
	token_type         *string
	status             *int8
	addstatus          *int8
	expired_at         *string
	refresh_expired_at *string
	response_at        *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Token, error)
	predicates         []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[token.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, token.FieldDeletedAt)
}

// SetPlatform sets the "platform" field.
func (m *TokenMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *TokenMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *TokenMutation) ResetPlatform() {
	m.platform = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *TokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *TokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *TokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetPin sets the "pin" field.
func (m *TokenMutation) SetPin(s string) {
	m.pin = &s
}

// Pin returns the value of the "pin" field in the mutation.
func (m *TokenMutation) Pin() (r string, exists bool) {
	v := m.pin
	if v == nil {
		return
	}
	return *v, true
}

// OldPin returns the old "pin" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldPin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPin: %w", err)
	}
	return oldValue.Pin, nil
}

// ResetPin resets all changes to the "pin" field.
func (m *TokenMutation) ResetPin() {
	m.pin = nil
}

// SetTraceID sets the "trace_id" field.
func (m *TokenMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *TokenMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *TokenMutation) ResetTraceID() {
	m.trace_id = nil
}

// SetTokenType sets the "token_type" field.
func (m *TokenMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *TokenMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *TokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetStatus sets the "status" field.
func (m *TokenMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TokenMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TokenMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(s string) {
	m.expired_at = &s
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r string, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetRefreshExpiredAt sets the "refresh_expired_at" field.
func (m *TokenMutation) SetRefreshExpiredAt(s string) {
	m.refresh_expired_at = &s
}

// RefreshExpiredAt returns the value of the "refresh_expired_at" field in the mutation.
func (m *TokenMutation) RefreshExpiredAt() (r string, exists bool) {
	v := m.refresh_expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshExpiredAt returns the old "refresh_expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldRefreshExpiredAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshExpiredAt: %w", err)
	}
	return oldValue.RefreshExpiredAt, nil
}

// ResetRefreshExpiredAt resets all changes to the "refresh_expired_at" field.
func (m *TokenMutation) ResetRefreshExpiredAt() {
	m.refresh_expired_at = nil
}

// SetResponseAt sets the "response_at" field.
func (m *TokenMutation) SetResponseAt(s string) {
	m.response_at = &s
}

// ResponseAt returns the value of the "response_at" field in the mutation.
func (m *TokenMutation) ResponseAt() (r string, exists bool) {
	v := m.response_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseAt returns the old "response_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldResponseAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseAt: %w", err)
	}
	return oldValue.ResponseAt, nil
}

// ResetResponseAt resets all changes to the "response_at" field.
func (m *TokenMutation) ResetResponseAt() {
	m.response_at = nil
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, token.FieldDeletedAt)
	}
	if m.platform != nil {
		fields = append(fields, token.FieldPlatform)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, token.FieldRefreshToken)
	}
	if m.pin != nil {
		fields = append(fields, token.FieldPin)
	}
	if m.trace_id != nil {
		fields = append(fields, token.FieldTraceID)
	}
	if m.token_type != nil {
		fields = append(fields, token.FieldTokenType)
	}
	if m.status != nil {
		fields = append(fields, token.FieldStatus)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	if m.refresh_expired_at != nil {
		fields = append(fields, token.FieldRefreshExpiredAt)
	}
	if m.response_at != nil {
		fields = append(fields, token.FieldResponseAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldDeletedAt:
		return m.DeletedAt()
	case token.FieldPlatform:
		return m.Platform()
	case token.FieldToken:
		return m.Token()
	case token.FieldRefreshToken:
		return m.RefreshToken()
	case token.FieldPin:
		return m.Pin()
	case token.FieldTraceID:
		return m.TraceID()
	case token.FieldTokenType:
		return m.TokenType()
	case token.FieldStatus:
		return m.Status()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	case token.FieldRefreshExpiredAt:
		return m.RefreshExpiredAt()
	case token.FieldResponseAt:
		return m.ResponseAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case token.FieldPlatform:
		return m.OldPlatform(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case token.FieldPin:
		return m.OldPin(ctx)
	case token.FieldTraceID:
		return m.OldTraceID(ctx)
	case token.FieldTokenType:
		return m.OldTokenType(ctx)
	case token.FieldStatus:
		return m.OldStatus(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case token.FieldRefreshExpiredAt:
		return m.OldRefreshExpiredAt(ctx)
	case token.FieldResponseAt:
		return m.OldResponseAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case token.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case token.FieldPin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPin(v)
		return nil
	case token.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case token.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case token.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case token.FieldRefreshExpiredAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshExpiredAt(v)
		return nil
	case token.FieldResponseAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, token.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldDeletedAt) {
		fields = append(fields, token.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case token.FieldPlatform:
		m.ResetPlatform()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case token.FieldPin:
		m.ResetPin()
		return nil
	case token.FieldTraceID:
		m.ResetTraceID()
		return nil
	case token.FieldTokenType:
		m.ResetTokenType()
		return nil
	case token.FieldStatus:
		m.ResetStatus()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case token.FieldRefreshExpiredAt:
		m.ResetRefreshExpiredAt()
		return nil
	case token.FieldResponseAt:
		m.ResetResponseAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Token edge %s", name)
}

// TrackMappingMutation represents an operation that mutates the TrackMapping nodes in the graph.
type TrackMappingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	tracking_number     *string
	tracking_url        *string
	ext_tracking_number *string
	track_details       *string
	last_updated_at     *time.Time
	courier_platform    *string
	status              *int32
	addstatus           *int32
	flag                *int8
	addflag             *int8
	clearedFields       map[string]struct{}
	orders              *int64
	clearedorders       bool
	done                bool
	oldValue            func(context.Context) (*TrackMapping, error)
	predicates          []predicate.TrackMapping
}

var _ ent.Mutation = (*TrackMappingMutation)(nil)

// trackmappingOption allows management of the mutation configuration using functional options.
type trackmappingOption func(*TrackMappingMutation)

// newTrackMappingMutation creates new mutation for the TrackMapping entity.
func newTrackMappingMutation(c config, op Op, opts ...trackmappingOption) *TrackMappingMutation {
	m := &TrackMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeTrackMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrackMappingID sets the ID field of the mutation.
func withTrackMappingID(id int64) trackmappingOption {
	return func(m *TrackMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *TrackMapping
		)
		m.oldValue = func(ctx context.Context) (*TrackMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrackMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrackMapping sets the old TrackMapping of the mutation.
func withTrackMapping(node *TrackMapping) trackmappingOption {
	return func(m *TrackMappingMutation) {
		m.oldValue = func(context.Context) (*TrackMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrackMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrackMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrackMapping entities.
func (m *TrackMappingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrackMappingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrackMappingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrackMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TrackMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrackMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrackMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrackMappingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrackMappingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrackMappingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TrackMappingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TrackMappingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TrackMappingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[trackmapping.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TrackMappingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[trackmapping.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TrackMappingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, trackmapping.FieldDeletedAt)
}

// SetOrderID sets the "order_id" field.
func (m *TrackMappingMutation) SetOrderID(i int64) {
	m.orders = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *TrackMappingMutation) OrderID() (r int64, exists bool) {
	v := m.orders
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *TrackMappingMutation) ClearOrderID() {
	m.orders = nil
	m.clearedFields[trackmapping.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *TrackMappingMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[trackmapping.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *TrackMappingMutation) ResetOrderID() {
	m.orders = nil
	delete(m.clearedFields, trackmapping.FieldOrderID)
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *TrackMappingMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *TrackMappingMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *TrackMappingMutation) ResetTrackingNumber() {
	m.tracking_number = nil
}

// SetTrackingURL sets the "tracking_url" field.
func (m *TrackMappingMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *TrackMappingMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *TrackMappingMutation) ResetTrackingURL() {
	m.tracking_url = nil
}

// SetExtTrackingNumber sets the "ext_tracking_number" field.
func (m *TrackMappingMutation) SetExtTrackingNumber(s string) {
	m.ext_tracking_number = &s
}

// ExtTrackingNumber returns the value of the "ext_tracking_number" field in the mutation.
func (m *TrackMappingMutation) ExtTrackingNumber() (r string, exists bool) {
	v := m.ext_tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldExtTrackingNumber returns the old "ext_tracking_number" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldExtTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtTrackingNumber: %w", err)
	}
	return oldValue.ExtTrackingNumber, nil
}

// ResetExtTrackingNumber resets all changes to the "ext_tracking_number" field.
func (m *TrackMappingMutation) ResetExtTrackingNumber() {
	m.ext_tracking_number = nil
}

// SetTrackDetails sets the "track_details" field.
func (m *TrackMappingMutation) SetTrackDetails(s string) {
	m.track_details = &s
}

// TrackDetails returns the value of the "track_details" field in the mutation.
func (m *TrackMappingMutation) TrackDetails() (r string, exists bool) {
	v := m.track_details
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackDetails returns the old "track_details" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldTrackDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackDetails: %w", err)
	}
	return oldValue.TrackDetails, nil
}

// ClearTrackDetails clears the value of the "track_details" field.
func (m *TrackMappingMutation) ClearTrackDetails() {
	m.track_details = nil
	m.clearedFields[trackmapping.FieldTrackDetails] = struct{}{}
}

// TrackDetailsCleared returns if the "track_details" field was cleared in this mutation.
func (m *TrackMappingMutation) TrackDetailsCleared() bool {
	_, ok := m.clearedFields[trackmapping.FieldTrackDetails]
	return ok
}

// ResetTrackDetails resets all changes to the "track_details" field.
func (m *TrackMappingMutation) ResetTrackDetails() {
	m.track_details = nil
	delete(m.clearedFields, trackmapping.FieldTrackDetails)
}

// SetLastUpdatedAt sets the "last_updated_at" field.
func (m *TrackMappingMutation) SetLastUpdatedAt(t time.Time) {
	m.last_updated_at = &t
}

// LastUpdatedAt returns the value of the "last_updated_at" field in the mutation.
func (m *TrackMappingMutation) LastUpdatedAt() (r time.Time, exists bool) {
	v := m.last_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdatedAt returns the old "last_updated_at" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldLastUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdatedAt: %w", err)
	}
	return oldValue.LastUpdatedAt, nil
}

// ClearLastUpdatedAt clears the value of the "last_updated_at" field.
func (m *TrackMappingMutation) ClearLastUpdatedAt() {
	m.last_updated_at = nil
	m.clearedFields[trackmapping.FieldLastUpdatedAt] = struct{}{}
}

// LastUpdatedAtCleared returns if the "last_updated_at" field was cleared in this mutation.
func (m *TrackMappingMutation) LastUpdatedAtCleared() bool {
	_, ok := m.clearedFields[trackmapping.FieldLastUpdatedAt]
	return ok
}

// ResetLastUpdatedAt resets all changes to the "last_updated_at" field.
func (m *TrackMappingMutation) ResetLastUpdatedAt() {
	m.last_updated_at = nil
	delete(m.clearedFields, trackmapping.FieldLastUpdatedAt)
}

// SetCourierPlatform sets the "courier_platform" field.
func (m *TrackMappingMutation) SetCourierPlatform(s string) {
	m.courier_platform = &s
}

// CourierPlatform returns the value of the "courier_platform" field in the mutation.
func (m *TrackMappingMutation) CourierPlatform() (r string, exists bool) {
	v := m.courier_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldCourierPlatform returns the old "courier_platform" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldCourierPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourierPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourierPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourierPlatform: %w", err)
	}
	return oldValue.CourierPlatform, nil
}

// ResetCourierPlatform resets all changes to the "courier_platform" field.
func (m *TrackMappingMutation) ResetCourierPlatform() {
	m.courier_platform = nil
}

// SetStatus sets the "status" field.
func (m *TrackMappingMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TrackMappingMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TrackMappingMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TrackMappingMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TrackMappingMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetFlag sets the "flag" field.
func (m *TrackMappingMutation) SetFlag(i int8) {
	m.flag = &i
	m.addflag = nil
}

// Flag returns the value of the "flag" field in the mutation.
func (m *TrackMappingMutation) Flag() (r int8, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the TrackMapping entity.
// If the TrackMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMappingMutation) OldFlag(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// AddFlag adds i to the "flag" field.
func (m *TrackMappingMutation) AddFlag(i int8) {
	if m.addflag != nil {
		*m.addflag += i
	} else {
		m.addflag = &i
	}
}

// AddedFlag returns the value that was added to the "flag" field in this mutation.
func (m *TrackMappingMutation) AddedFlag() (r int8, exists bool) {
	v := m.addflag
	if v == nil {
		return
	}
	return *v, true
}

// ResetFlag resets all changes to the "flag" field.
func (m *TrackMappingMutation) ResetFlag() {
	m.flag = nil
	m.addflag = nil
}

// SetOrdersID sets the "orders" edge to the Order entity by id.
func (m *TrackMappingMutation) SetOrdersID(id int64) {
	m.orders = &id
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *TrackMappingMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *TrackMappingMutation) OrdersCleared() bool {
	return m.OrderIDCleared() || m.clearedorders
}

// OrdersID returns the "orders" edge ID in the mutation.
func (m *TrackMappingMutation) OrdersID() (id int64, exists bool) {
	if m.orders != nil {
		return *m.orders, true
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrdersID instead. It exists only for internal usage by the builders.
func (m *TrackMappingMutation) OrdersIDs() (ids []int64) {
	if id := m.orders; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *TrackMappingMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
}

// Where appends a list predicates to the TrackMappingMutation builder.
func (m *TrackMappingMutation) Where(ps ...predicate.TrackMapping) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TrackMappingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TrackMapping).
func (m *TrackMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrackMappingMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, trackmapping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trackmapping.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, trackmapping.FieldDeletedAt)
	}
	if m.orders != nil {
		fields = append(fields, trackmapping.FieldOrderID)
	}
	if m.tracking_number != nil {
		fields = append(fields, trackmapping.FieldTrackingNumber)
	}
	if m.tracking_url != nil {
		fields = append(fields, trackmapping.FieldTrackingURL)
	}
	if m.ext_tracking_number != nil {
		fields = append(fields, trackmapping.FieldExtTrackingNumber)
	}
	if m.track_details != nil {
		fields = append(fields, trackmapping.FieldTrackDetails)
	}
	if m.last_updated_at != nil {
		fields = append(fields, trackmapping.FieldLastUpdatedAt)
	}
	if m.courier_platform != nil {
		fields = append(fields, trackmapping.FieldCourierPlatform)
	}
	if m.status != nil {
		fields = append(fields, trackmapping.FieldStatus)
	}
	if m.flag != nil {
		fields = append(fields, trackmapping.FieldFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrackMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trackmapping.FieldCreatedAt:
		return m.CreatedAt()
	case trackmapping.FieldUpdatedAt:
		return m.UpdatedAt()
	case trackmapping.FieldDeletedAt:
		return m.DeletedAt()
	case trackmapping.FieldOrderID:
		return m.OrderID()
	case trackmapping.FieldTrackingNumber:
		return m.TrackingNumber()
	case trackmapping.FieldTrackingURL:
		return m.TrackingURL()
	case trackmapping.FieldExtTrackingNumber:
		return m.ExtTrackingNumber()
	case trackmapping.FieldTrackDetails:
		return m.TrackDetails()
	case trackmapping.FieldLastUpdatedAt:
		return m.LastUpdatedAt()
	case trackmapping.FieldCourierPlatform:
		return m.CourierPlatform()
	case trackmapping.FieldStatus:
		return m.Status()
	case trackmapping.FieldFlag:
		return m.Flag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrackMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trackmapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trackmapping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trackmapping.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case trackmapping.FieldOrderID:
		return m.OldOrderID(ctx)
	case trackmapping.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case trackmapping.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case trackmapping.FieldExtTrackingNumber:
		return m.OldExtTrackingNumber(ctx)
	case trackmapping.FieldTrackDetails:
		return m.OldTrackDetails(ctx)
	case trackmapping.FieldLastUpdatedAt:
		return m.OldLastUpdatedAt(ctx)
	case trackmapping.FieldCourierPlatform:
		return m.OldCourierPlatform(ctx)
	case trackmapping.FieldStatus:
		return m.OldStatus(ctx)
	case trackmapping.FieldFlag:
		return m.OldFlag(ctx)
	}
	return nil, fmt.Errorf("unknown TrackMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrackMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trackmapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trackmapping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trackmapping.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case trackmapping.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case trackmapping.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case trackmapping.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case trackmapping.FieldExtTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtTrackingNumber(v)
		return nil
	case trackmapping.FieldTrackDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackDetails(v)
		return nil
	case trackmapping.FieldLastUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdatedAt(v)
		return nil
	case trackmapping.FieldCourierPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourierPlatform(v)
		return nil
	case trackmapping.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case trackmapping.FieldFlag:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	}
	return fmt.Errorf("unknown TrackMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrackMappingMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, trackmapping.FieldStatus)
	}
	if m.addflag != nil {
		fields = append(fields, trackmapping.FieldFlag)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrackMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trackmapping.FieldStatus:
		return m.AddedStatus()
	case trackmapping.FieldFlag:
		return m.AddedFlag()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrackMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trackmapping.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case trackmapping.FieldFlag:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlag(v)
		return nil
	}
	return fmt.Errorf("unknown TrackMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrackMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trackmapping.FieldDeletedAt) {
		fields = append(fields, trackmapping.FieldDeletedAt)
	}
	if m.FieldCleared(trackmapping.FieldOrderID) {
		fields = append(fields, trackmapping.FieldOrderID)
	}
	if m.FieldCleared(trackmapping.FieldTrackDetails) {
		fields = append(fields, trackmapping.FieldTrackDetails)
	}
	if m.FieldCleared(trackmapping.FieldLastUpdatedAt) {
		fields = append(fields, trackmapping.FieldLastUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrackMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrackMappingMutation) ClearField(name string) error {
	switch name {
	case trackmapping.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case trackmapping.FieldOrderID:
		m.ClearOrderID()
		return nil
	case trackmapping.FieldTrackDetails:
		m.ClearTrackDetails()
		return nil
	case trackmapping.FieldLastUpdatedAt:
		m.ClearLastUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TrackMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrackMappingMutation) ResetField(name string) error {
	switch name {
	case trackmapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trackmapping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trackmapping.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case trackmapping.FieldOrderID:
		m.ResetOrderID()
		return nil
	case trackmapping.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case trackmapping.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case trackmapping.FieldExtTrackingNumber:
		m.ResetExtTrackingNumber()
		return nil
	case trackmapping.FieldTrackDetails:
		m.ResetTrackDetails()
		return nil
	case trackmapping.FieldLastUpdatedAt:
		m.ResetLastUpdatedAt()
		return nil
	case trackmapping.FieldCourierPlatform:
		m.ResetCourierPlatform()
		return nil
	case trackmapping.FieldStatus:
		m.ResetStatus()
		return nil
	case trackmapping.FieldFlag:
		m.ResetFlag()
		return nil
	}
	return fmt.Errorf("unknown TrackMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrackMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, trackmapping.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrackMappingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trackmapping.EdgeOrders:
		if id := m.orders; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrackMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrackMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrackMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorders {
		edges = append(edges, trackmapping.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrackMappingMutation) EdgeCleared(name string) bool {
	switch name {
	case trackmapping.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrackMappingMutation) ClearEdge(name string) error {
	switch name {
	case trackmapping.EdgeOrders:
		m.ClearOrders()
		return nil
	}
	return fmt.Errorf("unknown TrackMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrackMappingMutation) ResetEdge(name string) error {
	switch name {
	case trackmapping.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown TrackMapping edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	order_id              *int64
	addorder_id           *int64
	transaction_type      *string
	transaction_amount    *float64
	addtransaction_amount *float64
	balance               *float64
	addbalance            *float64
	remark                *string
	status                *int8
	addstatus             *int8
	created_by            *int8
	addcreated_by         *int8
	updated_by            *int8
	addupdated_by         *int8
	clearedFields         map[string]struct{}
	tenant                *int64
	clearedtenant         bool
	details               map[int64]struct{}
	removeddetails        map[int64]struct{}
	cleareddetails        bool
	done                  bool
	oldValue              func(context.Context) (*Transaction, error)
	predicates            []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int64) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransactionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransactionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransactionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transaction.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransactionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransactionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transaction.FieldDeletedAt)
}

// SetOrderID sets the "order_id" field.
func (m *TransactionMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *TransactionMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *TransactionMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *TransactionMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *TransactionMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionMutation) SetTransactionType(s string) {
	m.transaction_type = &s
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionMutation) TransactionType() (r string, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetTransactionAmount sets the "transaction_amount" field.
func (m *TransactionMutation) SetTransactionAmount(f float64) {
	m.transaction_amount = &f
	m.addtransaction_amount = nil
}

// TransactionAmount returns the value of the "transaction_amount" field in the mutation.
func (m *TransactionMutation) TransactionAmount() (r float64, exists bool) {
	v := m.transaction_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionAmount returns the old "transaction_amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionAmount: %w", err)
	}
	return oldValue.TransactionAmount, nil
}

// AddTransactionAmount adds f to the "transaction_amount" field.
func (m *TransactionMutation) AddTransactionAmount(f float64) {
	if m.addtransaction_amount != nil {
		*m.addtransaction_amount += f
	} else {
		m.addtransaction_amount = &f
	}
}

// AddedTransactionAmount returns the value that was added to the "transaction_amount" field in this mutation.
func (m *TransactionMutation) AddedTransactionAmount() (r float64, exists bool) {
	v := m.addtransaction_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTransactionAmount resets all changes to the "transaction_amount" field.
func (m *TransactionMutation) ResetTransactionAmount() {
	m.transaction_amount = nil
	m.addtransaction_amount = nil
}

// SetBalance sets the "balance" field.
func (m *TransactionMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *TransactionMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *TransactionMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *TransactionMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *TransactionMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetRemark sets the "remark" field.
func (m *TransactionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TransactionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *TransactionMutation) ResetRemark() {
	m.remark = nil
}

// SetStatus sets the "status" field.
func (m *TransactionMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TransactionMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TransactionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TransactionMutation) SetCreatedBy(i int8) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TransactionMutation) CreatedBy() (r int8, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedBy(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *TransactionMutation) AddCreatedBy(i int8) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TransactionMutation) AddedCreatedBy() (r int8, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TransactionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TransactionMutation) SetUpdatedBy(i int8) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TransactionMutation) UpdatedBy() (r int8, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedBy(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *TransactionMutation) AddUpdatedBy(i int8) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TransactionMutation) AddedUpdatedBy() (r int8, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TransactionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *TransactionMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TransactionMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TransactionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *TransactionMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TransactionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddDetailIDs adds the "details" edge to the TransactionDetail entity by ids.
func (m *TransactionMutation) AddDetailIDs(ids ...int64) {
	if m.details == nil {
		m.details = make(map[int64]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the TransactionDetail entity.
func (m *TransactionMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the TransactionDetail entity was cleared.
func (m *TransactionMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the TransactionDetail entity by IDs.
func (m *TransactionMutation) RemoveDetailIDs(ids ...int64) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the TransactionDetail entity.
func (m *TransactionMutation) RemovedDetailsIDs() (ids []int64) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *TransactionMutation) DetailsIDs() (ids []int64) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *TransactionMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transaction.FieldDeletedAt)
	}
	if m.order_id != nil {
		fields = append(fields, transaction.FieldOrderID)
	}
	if m.transaction_type != nil {
		fields = append(fields, transaction.FieldTransactionType)
	}
	if m.transaction_amount != nil {
		fields = append(fields, transaction.FieldTransactionAmount)
	}
	if m.balance != nil {
		fields = append(fields, transaction.FieldBalance)
	}
	if m.remark != nil {
		fields = append(fields, transaction.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.created_by != nil {
		fields = append(fields, transaction.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, transaction.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case transaction.FieldDeletedAt:
		return m.DeletedAt()
	case transaction.FieldOrderID:
		return m.OrderID()
	case transaction.FieldTransactionType:
		return m.TransactionType()
	case transaction.FieldTransactionAmount:
		return m.TransactionAmount()
	case transaction.FieldBalance:
		return m.Balance()
	case transaction.FieldRemark:
		return m.Remark()
	case transaction.FieldStatus:
		return m.Status()
	case transaction.FieldCreatedBy:
		return m.CreatedBy()
	case transaction.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transaction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transaction.FieldOrderID:
		return m.OldOrderID(ctx)
	case transaction.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transaction.FieldTransactionAmount:
		return m.OldTransactionAmount(ctx)
	case transaction.FieldBalance:
		return m.OldBalance(ctx)
	case transaction.FieldRemark:
		return m.OldRemark(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	case transaction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case transaction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transaction.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transaction.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case transaction.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transaction.FieldTransactionAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionAmount(v)
		return nil
	case transaction.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case transaction.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transaction.FieldCreatedBy:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case transaction.FieldUpdatedBy:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, transaction.FieldOrderID)
	}
	if m.addtransaction_amount != nil {
		fields = append(fields, transaction.FieldTransactionAmount)
	}
	if m.addbalance != nil {
		fields = append(fields, transaction.FieldBalance)
	}
	if m.addstatus != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.addcreated_by != nil {
		fields = append(fields, transaction.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, transaction.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldOrderID:
		return m.AddedOrderID()
	case transaction.FieldTransactionAmount:
		return m.AddedTransactionAmount()
	case transaction.FieldBalance:
		return m.AddedBalance()
	case transaction.FieldStatus:
		return m.AddedStatus()
	case transaction.FieldCreatedBy:
		return m.AddedCreatedBy()
	case transaction.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case transaction.FieldTransactionAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionAmount(v)
		return nil
	case transaction.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case transaction.FieldCreatedBy:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case transaction.FieldUpdatedBy:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldDeletedAt) {
		fields = append(fields, transaction.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transaction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transaction.FieldOrderID:
		m.ResetOrderID()
		return nil
	case transaction.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transaction.FieldTransactionAmount:
		m.ResetTransactionAmount()
		return nil
	case transaction.FieldBalance:
		m.ResetBalance()
		return nil
	case transaction.FieldRemark:
		m.ResetRemark()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transaction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case transaction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, transaction.EdgeTenant)
	}
	if m.details != nil {
		edges = append(edges, transaction.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddetails != nil {
		edges = append(edges, transaction.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, transaction.EdgeTenant)
	}
	if m.cleareddetails {
		edges = append(edges, transaction.EdgeDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeTenant:
		return m.clearedtenant
	case transaction.EdgeDetails:
		return m.cleareddetails
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeTenant:
		m.ResetTenant()
		return nil
	case transaction.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionDetailMutation represents an operation that mutates the TransactionDetail nodes in the graph.
type TransactionDetailMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	order_id            *int64
	addorder_id         *int64
	transaction_id      *int64
	addtransaction_id   *int64
	transaction_type    *string
	delivery_cost       *float64
	adddelivery_cost    *float64
	misc_fee            *float64
	addmisc_fee         *float64
	fuel_fee            *float64
	addfuel_fee         *float64
	registration_fee    *float64
	addregistration_fee *float64
	processing_fee      *float64
	addprocessing_fee   *float64
	package_fee         *float64
	addpackage_fee      *float64
	handling_fee        *float64
	addhandling_fee     *float64
	vat                 *float64
	addvat              *float64
	amount              *float64
	addamount           *float64
	weight              *int
	addweight           *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*TransactionDetail, error)
	predicates          []predicate.TransactionDetail
}

var _ ent.Mutation = (*TransactionDetailMutation)(nil)

// transactiondetailOption allows management of the mutation configuration using functional options.
type transactiondetailOption func(*TransactionDetailMutation)

// newTransactionDetailMutation creates new mutation for the TransactionDetail entity.
func newTransactionDetailMutation(c config, op Op, opts ...transactiondetailOption) *TransactionDetailMutation {
	m := &TransactionDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionDetailID sets the ID field of the mutation.
func withTransactionDetailID(id int64) transactiondetailOption {
	return func(m *TransactionDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionDetail
		)
		m.oldValue = func(ctx context.Context) (*TransactionDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionDetail sets the old TransactionDetail of the mutation.
func withTransactionDetail(node *TransactionDetail) transactiondetailOption {
	return func(m *TransactionDetailMutation) {
		m.oldValue = func(context.Context) (*TransactionDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransactionDetail entities.
func (m *TransactionDetailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionDetailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransactionDetailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransactionDetailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransactionDetailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transactiondetail.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransactionDetailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transactiondetail.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransactionDetailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transactiondetail.FieldDeletedAt)
}

// SetOrderID sets the "order_id" field.
func (m *TransactionDetailMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *TransactionDetailMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *TransactionDetailMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *TransactionDetailMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *TransactionDetailMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *TransactionDetailMutation) SetTransactionID(i int64) {
	m.transaction_id = &i
	m.addtransaction_id = nil
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *TransactionDetailMutation) TransactionID() (r int64, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldTransactionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// AddTransactionID adds i to the "transaction_id" field.
func (m *TransactionDetailMutation) AddTransactionID(i int64) {
	if m.addtransaction_id != nil {
		*m.addtransaction_id += i
	} else {
		m.addtransaction_id = &i
	}
}

// AddedTransactionID returns the value that was added to the "transaction_id" field in this mutation.
func (m *TransactionDetailMutation) AddedTransactionID() (r int64, exists bool) {
	v := m.addtransaction_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *TransactionDetailMutation) ResetTransactionID() {
	m.transaction_id = nil
	m.addtransaction_id = nil
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionDetailMutation) SetTransactionType(s string) {
	m.transaction_type = &s
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionDetailMutation) TransactionType() (r string, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldTransactionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionDetailMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetDeliveryCost sets the "delivery_cost" field.
func (m *TransactionDetailMutation) SetDeliveryCost(f float64) {
	m.delivery_cost = &f
	m.adddelivery_cost = nil
}

// DeliveryCost returns the value of the "delivery_cost" field in the mutation.
func (m *TransactionDetailMutation) DeliveryCost() (r float64, exists bool) {
	v := m.delivery_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryCost returns the old "delivery_cost" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldDeliveryCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryCost: %w", err)
	}
	return oldValue.DeliveryCost, nil
}

// AddDeliveryCost adds f to the "delivery_cost" field.
func (m *TransactionDetailMutation) AddDeliveryCost(f float64) {
	if m.adddelivery_cost != nil {
		*m.adddelivery_cost += f
	} else {
		m.adddelivery_cost = &f
	}
}

// AddedDeliveryCost returns the value that was added to the "delivery_cost" field in this mutation.
func (m *TransactionDetailMutation) AddedDeliveryCost() (r float64, exists bool) {
	v := m.adddelivery_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeliveryCost resets all changes to the "delivery_cost" field.
func (m *TransactionDetailMutation) ResetDeliveryCost() {
	m.delivery_cost = nil
	m.adddelivery_cost = nil
}

// SetMiscFee sets the "misc_fee" field.
func (m *TransactionDetailMutation) SetMiscFee(f float64) {
	m.misc_fee = &f
	m.addmisc_fee = nil
}

// MiscFee returns the value of the "misc_fee" field in the mutation.
func (m *TransactionDetailMutation) MiscFee() (r float64, exists bool) {
	v := m.misc_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldMiscFee returns the old "misc_fee" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldMiscFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiscFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiscFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiscFee: %w", err)
	}
	return oldValue.MiscFee, nil
}

// AddMiscFee adds f to the "misc_fee" field.
func (m *TransactionDetailMutation) AddMiscFee(f float64) {
	if m.addmisc_fee != nil {
		*m.addmisc_fee += f
	} else {
		m.addmisc_fee = &f
	}
}

// AddedMiscFee returns the value that was added to the "misc_fee" field in this mutation.
func (m *TransactionDetailMutation) AddedMiscFee() (r float64, exists bool) {
	v := m.addmisc_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetMiscFee resets all changes to the "misc_fee" field.
func (m *TransactionDetailMutation) ResetMiscFee() {
	m.misc_fee = nil
	m.addmisc_fee = nil
}

// SetFuelFee sets the "fuel_fee" field.
func (m *TransactionDetailMutation) SetFuelFee(f float64) {
	m.fuel_fee = &f
	m.addfuel_fee = nil
}

// FuelFee returns the value of the "fuel_fee" field in the mutation.
func (m *TransactionDetailMutation) FuelFee() (r float64, exists bool) {
	v := m.fuel_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelFee returns the old "fuel_fee" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldFuelFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelFee: %w", err)
	}
	return oldValue.FuelFee, nil
}

// AddFuelFee adds f to the "fuel_fee" field.
func (m *TransactionDetailMutation) AddFuelFee(f float64) {
	if m.addfuel_fee != nil {
		*m.addfuel_fee += f
	} else {
		m.addfuel_fee = &f
	}
}

// AddedFuelFee returns the value that was added to the "fuel_fee" field in this mutation.
func (m *TransactionDetailMutation) AddedFuelFee() (r float64, exists bool) {
	v := m.addfuel_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFuelFee resets all changes to the "fuel_fee" field.
func (m *TransactionDetailMutation) ResetFuelFee() {
	m.fuel_fee = nil
	m.addfuel_fee = nil
}

// SetRegistrationFee sets the "registration_fee" field.
func (m *TransactionDetailMutation) SetRegistrationFee(f float64) {
	m.registration_fee = &f
	m.addregistration_fee = nil
}

// RegistrationFee returns the value of the "registration_fee" field in the mutation.
func (m *TransactionDetailMutation) RegistrationFee() (r float64, exists bool) {
	v := m.registration_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationFee returns the old "registration_fee" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldRegistrationFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationFee: %w", err)
	}
	return oldValue.RegistrationFee, nil
}

// AddRegistrationFee adds f to the "registration_fee" field.
func (m *TransactionDetailMutation) AddRegistrationFee(f float64) {
	if m.addregistration_fee != nil {
		*m.addregistration_fee += f
	} else {
		m.addregistration_fee = &f
	}
}

// AddedRegistrationFee returns the value that was added to the "registration_fee" field in this mutation.
func (m *TransactionDetailMutation) AddedRegistrationFee() (r float64, exists bool) {
	v := m.addregistration_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegistrationFee resets all changes to the "registration_fee" field.
func (m *TransactionDetailMutation) ResetRegistrationFee() {
	m.registration_fee = nil
	m.addregistration_fee = nil
}

// SetProcessingFee sets the "processing_fee" field.
func (m *TransactionDetailMutation) SetProcessingFee(f float64) {
	m.processing_fee = &f
	m.addprocessing_fee = nil
}

// ProcessingFee returns the value of the "processing_fee" field in the mutation.
func (m *TransactionDetailMutation) ProcessingFee() (r float64, exists bool) {
	v := m.processing_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessingFee returns the old "processing_fee" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldProcessingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessingFee: %w", err)
	}
	return oldValue.ProcessingFee, nil
}

// AddProcessingFee adds f to the "processing_fee" field.
func (m *TransactionDetailMutation) AddProcessingFee(f float64) {
	if m.addprocessing_fee != nil {
		*m.addprocessing_fee += f
	} else {
		m.addprocessing_fee = &f
	}
}

// AddedProcessingFee returns the value that was added to the "processing_fee" field in this mutation.
func (m *TransactionDetailMutation) AddedProcessingFee() (r float64, exists bool) {
	v := m.addprocessing_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcessingFee resets all changes to the "processing_fee" field.
func (m *TransactionDetailMutation) ResetProcessingFee() {
	m.processing_fee = nil
	m.addprocessing_fee = nil
}

// SetPackageFee sets the "package_fee" field.
func (m *TransactionDetailMutation) SetPackageFee(f float64) {
	m.package_fee = &f
	m.addpackage_fee = nil
}

// PackageFee returns the value of the "package_fee" field in the mutation.
func (m *TransactionDetailMutation) PackageFee() (r float64, exists bool) {
	v := m.package_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageFee returns the old "package_fee" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldPackageFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageFee: %w", err)
	}
	return oldValue.PackageFee, nil
}

// AddPackageFee adds f to the "package_fee" field.
func (m *TransactionDetailMutation) AddPackageFee(f float64) {
	if m.addpackage_fee != nil {
		*m.addpackage_fee += f
	} else {
		m.addpackage_fee = &f
	}
}

// AddedPackageFee returns the value that was added to the "package_fee" field in this mutation.
func (m *TransactionDetailMutation) AddedPackageFee() (r float64, exists bool) {
	v := m.addpackage_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetPackageFee resets all changes to the "package_fee" field.
func (m *TransactionDetailMutation) ResetPackageFee() {
	m.package_fee = nil
	m.addpackage_fee = nil
}

// SetHandlingFee sets the "handling_fee" field.
func (m *TransactionDetailMutation) SetHandlingFee(f float64) {
	m.handling_fee = &f
	m.addhandling_fee = nil
}

// HandlingFee returns the value of the "handling_fee" field in the mutation.
func (m *TransactionDetailMutation) HandlingFee() (r float64, exists bool) {
	v := m.handling_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldHandlingFee returns the old "handling_fee" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldHandlingFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandlingFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandlingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandlingFee: %w", err)
	}
	return oldValue.HandlingFee, nil
}

// AddHandlingFee adds f to the "handling_fee" field.
func (m *TransactionDetailMutation) AddHandlingFee(f float64) {
	if m.addhandling_fee != nil {
		*m.addhandling_fee += f
	} else {
		m.addhandling_fee = &f
	}
}

// AddedHandlingFee returns the value that was added to the "handling_fee" field in this mutation.
func (m *TransactionDetailMutation) AddedHandlingFee() (r float64, exists bool) {
	v := m.addhandling_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandlingFee resets all changes to the "handling_fee" field.
func (m *TransactionDetailMutation) ResetHandlingFee() {
	m.handling_fee = nil
	m.addhandling_fee = nil
}

// SetVat sets the "vat" field.
func (m *TransactionDetailMutation) SetVat(f float64) {
	m.vat = &f
	m.addvat = nil
}

// Vat returns the value of the "vat" field in the mutation.
func (m *TransactionDetailMutation) Vat() (r float64, exists bool) {
	v := m.vat
	if v == nil {
		return
	}
	return *v, true
}

// OldVat returns the old "vat" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldVat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVat: %w", err)
	}
	return oldValue.Vat, nil
}

// AddVat adds f to the "vat" field.
func (m *TransactionDetailMutation) AddVat(f float64) {
	if m.addvat != nil {
		*m.addvat += f
	} else {
		m.addvat = &f
	}
}

// AddedVat returns the value that was added to the "vat" field in this mutation.
func (m *TransactionDetailMutation) AddedVat() (r float64, exists bool) {
	v := m.addvat
	if v == nil {
		return
	}
	return *v, true
}

// ResetVat resets all changes to the "vat" field.
func (m *TransactionDetailMutation) ResetVat() {
	m.vat = nil
	m.addvat = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionDetailMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionDetailMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransactionDetailMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionDetailMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionDetailMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetWeight sets the "weight" field.
func (m *TransactionDetailMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *TransactionDetailMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the TransactionDetail entity.
// If the TransactionDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionDetailMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *TransactionDetailMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *TransactionDetailMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *TransactionDetailMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// Where appends a list predicates to the TransactionDetailMutation builder.
func (m *TransactionDetailMutation) Where(ps ...predicate.TransactionDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransactionDetail).
func (m *TransactionDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionDetailMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, transactiondetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transactiondetail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transactiondetail.FieldDeletedAt)
	}
	if m.order_id != nil {
		fields = append(fields, transactiondetail.FieldOrderID)
	}
	if m.transaction_id != nil {
		fields = append(fields, transactiondetail.FieldTransactionID)
	}
	if m.transaction_type != nil {
		fields = append(fields, transactiondetail.FieldTransactionType)
	}
	if m.delivery_cost != nil {
		fields = append(fields, transactiondetail.FieldDeliveryCost)
	}
	if m.misc_fee != nil {
		fields = append(fields, transactiondetail.FieldMiscFee)
	}
	if m.fuel_fee != nil {
		fields = append(fields, transactiondetail.FieldFuelFee)
	}
	if m.registration_fee != nil {
		fields = append(fields, transactiondetail.FieldRegistrationFee)
	}
	if m.processing_fee != nil {
		fields = append(fields, transactiondetail.FieldProcessingFee)
	}
	if m.package_fee != nil {
		fields = append(fields, transactiondetail.FieldPackageFee)
	}
	if m.handling_fee != nil {
		fields = append(fields, transactiondetail.FieldHandlingFee)
	}
	if m.vat != nil {
		fields = append(fields, transactiondetail.FieldVat)
	}
	if m.amount != nil {
		fields = append(fields, transactiondetail.FieldAmount)
	}
	if m.weight != nil {
		fields = append(fields, transactiondetail.FieldWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactiondetail.FieldCreatedAt:
		return m.CreatedAt()
	case transactiondetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case transactiondetail.FieldDeletedAt:
		return m.DeletedAt()
	case transactiondetail.FieldOrderID:
		return m.OrderID()
	case transactiondetail.FieldTransactionID:
		return m.TransactionID()
	case transactiondetail.FieldTransactionType:
		return m.TransactionType()
	case transactiondetail.FieldDeliveryCost:
		return m.DeliveryCost()
	case transactiondetail.FieldMiscFee:
		return m.MiscFee()
	case transactiondetail.FieldFuelFee:
		return m.FuelFee()
	case transactiondetail.FieldRegistrationFee:
		return m.RegistrationFee()
	case transactiondetail.FieldProcessingFee:
		return m.ProcessingFee()
	case transactiondetail.FieldPackageFee:
		return m.PackageFee()
	case transactiondetail.FieldHandlingFee:
		return m.HandlingFee()
	case transactiondetail.FieldVat:
		return m.Vat()
	case transactiondetail.FieldAmount:
		return m.Amount()
	case transactiondetail.FieldWeight:
		return m.Weight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactiondetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transactiondetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transactiondetail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transactiondetail.FieldOrderID:
		return m.OldOrderID(ctx)
	case transactiondetail.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case transactiondetail.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transactiondetail.FieldDeliveryCost:
		return m.OldDeliveryCost(ctx)
	case transactiondetail.FieldMiscFee:
		return m.OldMiscFee(ctx)
	case transactiondetail.FieldFuelFee:
		return m.OldFuelFee(ctx)
	case transactiondetail.FieldRegistrationFee:
		return m.OldRegistrationFee(ctx)
	case transactiondetail.FieldProcessingFee:
		return m.OldProcessingFee(ctx)
	case transactiondetail.FieldPackageFee:
		return m.OldPackageFee(ctx)
	case transactiondetail.FieldHandlingFee:
		return m.OldHandlingFee(ctx)
	case transactiondetail.FieldVat:
		return m.OldVat(ctx)
	case transactiondetail.FieldAmount:
		return m.OldAmount(ctx)
	case transactiondetail.FieldWeight:
		return m.OldWeight(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactiondetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transactiondetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transactiondetail.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transactiondetail.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case transactiondetail.FieldTransactionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case transactiondetail.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transactiondetail.FieldDeliveryCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryCost(v)
		return nil
	case transactiondetail.FieldMiscFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiscFee(v)
		return nil
	case transactiondetail.FieldFuelFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelFee(v)
		return nil
	case transactiondetail.FieldRegistrationFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationFee(v)
		return nil
	case transactiondetail.FieldProcessingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessingFee(v)
		return nil
	case transactiondetail.FieldPackageFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageFee(v)
		return nil
	case transactiondetail.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandlingFee(v)
		return nil
	case transactiondetail.FieldVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVat(v)
		return nil
	case transactiondetail.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transactiondetail.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionDetailMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, transactiondetail.FieldOrderID)
	}
	if m.addtransaction_id != nil {
		fields = append(fields, transactiondetail.FieldTransactionID)
	}
	if m.adddelivery_cost != nil {
		fields = append(fields, transactiondetail.FieldDeliveryCost)
	}
	if m.addmisc_fee != nil {
		fields = append(fields, transactiondetail.FieldMiscFee)
	}
	if m.addfuel_fee != nil {
		fields = append(fields, transactiondetail.FieldFuelFee)
	}
	if m.addregistration_fee != nil {
		fields = append(fields, transactiondetail.FieldRegistrationFee)
	}
	if m.addprocessing_fee != nil {
		fields = append(fields, transactiondetail.FieldProcessingFee)
	}
	if m.addpackage_fee != nil {
		fields = append(fields, transactiondetail.FieldPackageFee)
	}
	if m.addhandling_fee != nil {
		fields = append(fields, transactiondetail.FieldHandlingFee)
	}
	if m.addvat != nil {
		fields = append(fields, transactiondetail.FieldVat)
	}
	if m.addamount != nil {
		fields = append(fields, transactiondetail.FieldAmount)
	}
	if m.addweight != nil {
		fields = append(fields, transactiondetail.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactiondetail.FieldOrderID:
		return m.AddedOrderID()
	case transactiondetail.FieldTransactionID:
		return m.AddedTransactionID()
	case transactiondetail.FieldDeliveryCost:
		return m.AddedDeliveryCost()
	case transactiondetail.FieldMiscFee:
		return m.AddedMiscFee()
	case transactiondetail.FieldFuelFee:
		return m.AddedFuelFee()
	case transactiondetail.FieldRegistrationFee:
		return m.AddedRegistrationFee()
	case transactiondetail.FieldProcessingFee:
		return m.AddedProcessingFee()
	case transactiondetail.FieldPackageFee:
		return m.AddedPackageFee()
	case transactiondetail.FieldHandlingFee:
		return m.AddedHandlingFee()
	case transactiondetail.FieldVat:
		return m.AddedVat()
	case transactiondetail.FieldAmount:
		return m.AddedAmount()
	case transactiondetail.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactiondetail.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case transactiondetail.FieldTransactionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionID(v)
		return nil
	case transactiondetail.FieldDeliveryCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryCost(v)
		return nil
	case transactiondetail.FieldMiscFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMiscFee(v)
		return nil
	case transactiondetail.FieldFuelFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFuelFee(v)
		return nil
	case transactiondetail.FieldRegistrationFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegistrationFee(v)
		return nil
	case transactiondetail.FieldProcessingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessingFee(v)
		return nil
	case transactiondetail.FieldPackageFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPackageFee(v)
		return nil
	case transactiondetail.FieldHandlingFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandlingFee(v)
		return nil
	case transactiondetail.FieldVat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVat(v)
		return nil
	case transactiondetail.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case transactiondetail.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactiondetail.FieldDeletedAt) {
		fields = append(fields, transactiondetail.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionDetailMutation) ClearField(name string) error {
	switch name {
	case transactiondetail.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TransactionDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionDetailMutation) ResetField(name string) error {
	switch name {
	case transactiondetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transactiondetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transactiondetail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transactiondetail.FieldOrderID:
		m.ResetOrderID()
		return nil
	case transactiondetail.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case transactiondetail.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transactiondetail.FieldDeliveryCost:
		m.ResetDeliveryCost()
		return nil
	case transactiondetail.FieldMiscFee:
		m.ResetMiscFee()
		return nil
	case transactiondetail.FieldFuelFee:
		m.ResetFuelFee()
		return nil
	case transactiondetail.FieldRegistrationFee:
		m.ResetRegistrationFee()
		return nil
	case transactiondetail.FieldProcessingFee:
		m.ResetProcessingFee()
		return nil
	case transactiondetail.FieldPackageFee:
		m.ResetPackageFee()
		return nil
	case transactiondetail.FieldHandlingFee:
		m.ResetHandlingFee()
		return nil
	case transactiondetail.FieldVat:
		m.ResetVat()
		return nil
	case transactiondetail.FieldAmount:
		m.ResetAmount()
		return nil
	case transactiondetail.FieldWeight:
		m.ResetWeight()
		return nil
	}
	return fmt.Errorf("unknown TransactionDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TransactionDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TransactionDetail edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	email                    *string
	_type                    *string
	password                 *string
	selected_warehouse_id    *int64
	addselected_warehouse_id *int64
	avatar                   *string
	code                     *string
	status                   *int8
	addstatus                *int8
	guide_finished           *bool
	guide_status             *int
	addguide_status          *int
	hs_object_id             *string
	questions                *string
	last_logged_time         *time.Time
	website                  *string
	platform                 *string
	concerns                 *string
	store_code               *string
	phone                    *string
	source                   *string
	source_tag               *string
	clearedFields            map[string]struct{}
	tenant                   *int64
	clearedtenant            bool
	announcements            map[int64]struct{}
	removedannouncements     map[int64]struct{}
	clearedannouncements     bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetSelectedWarehouseID sets the "selected_warehouse_id" field.
func (m *UserMutation) SetSelectedWarehouseID(i int64) {
	m.selected_warehouse_id = &i
	m.addselected_warehouse_id = nil
}

// SelectedWarehouseID returns the value of the "selected_warehouse_id" field in the mutation.
func (m *UserMutation) SelectedWarehouseID() (r int64, exists bool) {
	v := m.selected_warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedWarehouseID returns the old "selected_warehouse_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSelectedWarehouseID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedWarehouseID: %w", err)
	}
	return oldValue.SelectedWarehouseID, nil
}

// AddSelectedWarehouseID adds i to the "selected_warehouse_id" field.
func (m *UserMutation) AddSelectedWarehouseID(i int64) {
	if m.addselected_warehouse_id != nil {
		*m.addselected_warehouse_id += i
	} else {
		m.addselected_warehouse_id = &i
	}
}

// AddedSelectedWarehouseID returns the value that was added to the "selected_warehouse_id" field in this mutation.
func (m *UserMutation) AddedSelectedWarehouseID() (r int64, exists bool) {
	v := m.addselected_warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSelectedWarehouseID clears the value of the "selected_warehouse_id" field.
func (m *UserMutation) ClearSelectedWarehouseID() {
	m.selected_warehouse_id = nil
	m.addselected_warehouse_id = nil
	m.clearedFields[user.FieldSelectedWarehouseID] = struct{}{}
}

// SelectedWarehouseIDCleared returns if the "selected_warehouse_id" field was cleared in this mutation.
func (m *UserMutation) SelectedWarehouseIDCleared() bool {
	_, ok := m.clearedFields[user.FieldSelectedWarehouseID]
	return ok
}

// ResetSelectedWarehouseID resets all changes to the "selected_warehouse_id" field.
func (m *UserMutation) ResetSelectedWarehouseID() {
	m.selected_warehouse_id = nil
	m.addselected_warehouse_id = nil
	delete(m.clearedFields, user.FieldSelectedWarehouseID)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetCode sets the "code" field.
func (m *UserMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *UserMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *UserMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetGuideFinished sets the "guide_finished" field.
func (m *UserMutation) SetGuideFinished(b bool) {
	m.guide_finished = &b
}

// GuideFinished returns the value of the "guide_finished" field in the mutation.
func (m *UserMutation) GuideFinished() (r bool, exists bool) {
	v := m.guide_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldGuideFinished returns the old "guide_finished" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGuideFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuideFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuideFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuideFinished: %w", err)
	}
	return oldValue.GuideFinished, nil
}

// ResetGuideFinished resets all changes to the "guide_finished" field.
func (m *UserMutation) ResetGuideFinished() {
	m.guide_finished = nil
}

// SetGuideStatus sets the "guide_status" field.
func (m *UserMutation) SetGuideStatus(i int) {
	m.guide_status = &i
	m.addguide_status = nil
}

// GuideStatus returns the value of the "guide_status" field in the mutation.
func (m *UserMutation) GuideStatus() (r int, exists bool) {
	v := m.guide_status
	if v == nil {
		return
	}
	return *v, true
}

// OldGuideStatus returns the old "guide_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGuideStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuideStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuideStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuideStatus: %w", err)
	}
	return oldValue.GuideStatus, nil
}

// AddGuideStatus adds i to the "guide_status" field.
func (m *UserMutation) AddGuideStatus(i int) {
	if m.addguide_status != nil {
		*m.addguide_status += i
	} else {
		m.addguide_status = &i
	}
}

// AddedGuideStatus returns the value that was added to the "guide_status" field in this mutation.
func (m *UserMutation) AddedGuideStatus() (r int, exists bool) {
	v := m.addguide_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetGuideStatus resets all changes to the "guide_status" field.
func (m *UserMutation) ResetGuideStatus() {
	m.guide_status = nil
	m.addguide_status = nil
}

// SetHsObjectID sets the "hs_object_id" field.
func (m *UserMutation) SetHsObjectID(s string) {
	m.hs_object_id = &s
}

// HsObjectID returns the value of the "hs_object_id" field in the mutation.
func (m *UserMutation) HsObjectID() (r string, exists bool) {
	v := m.hs_object_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHsObjectID returns the old "hs_object_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHsObjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHsObjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHsObjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHsObjectID: %w", err)
	}
	return oldValue.HsObjectID, nil
}

// ResetHsObjectID resets all changes to the "hs_object_id" field.
func (m *UserMutation) ResetHsObjectID() {
	m.hs_object_id = nil
}

// SetQuestions sets the "questions" field.
func (m *UserMutation) SetQuestions(s string) {
	m.questions = &s
}

// Questions returns the value of the "questions" field in the mutation.
func (m *UserMutation) Questions() (r string, exists bool) {
	v := m.questions
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestions returns the old "questions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldQuestions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestions: %w", err)
	}
	return oldValue.Questions, nil
}

// ClearQuestions clears the value of the "questions" field.
func (m *UserMutation) ClearQuestions() {
	m.questions = nil
	m.clearedFields[user.FieldQuestions] = struct{}{}
}

// QuestionsCleared returns if the "questions" field was cleared in this mutation.
func (m *UserMutation) QuestionsCleared() bool {
	_, ok := m.clearedFields[user.FieldQuestions]
	return ok
}

// ResetQuestions resets all changes to the "questions" field.
func (m *UserMutation) ResetQuestions() {
	m.questions = nil
	delete(m.clearedFields, user.FieldQuestions)
}

// SetLastLoggedTime sets the "last_logged_time" field.
func (m *UserMutation) SetLastLoggedTime(t time.Time) {
	m.last_logged_time = &t
}

// LastLoggedTime returns the value of the "last_logged_time" field in the mutation.
func (m *UserMutation) LastLoggedTime() (r time.Time, exists bool) {
	v := m.last_logged_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoggedTime returns the old "last_logged_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoggedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoggedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoggedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoggedTime: %w", err)
	}
	return oldValue.LastLoggedTime, nil
}

// ClearLastLoggedTime clears the value of the "last_logged_time" field.
func (m *UserMutation) ClearLastLoggedTime() {
	m.last_logged_time = nil
	m.clearedFields[user.FieldLastLoggedTime] = struct{}{}
}

// LastLoggedTimeCleared returns if the "last_logged_time" field was cleared in this mutation.
func (m *UserMutation) LastLoggedTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoggedTime]
	return ok
}

// ResetLastLoggedTime resets all changes to the "last_logged_time" field.
func (m *UserMutation) ResetLastLoggedTime() {
	m.last_logged_time = nil
	delete(m.clearedFields, user.FieldLastLoggedTime)
}

// SetWebsite sets the "website" field.
func (m *UserMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *UserMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ResetWebsite resets all changes to the "website" field.
func (m *UserMutation) ResetWebsite() {
	m.website = nil
}

// SetPlatform sets the "platform" field.
func (m *UserMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *UserMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *UserMutation) ResetPlatform() {
	m.platform = nil
}

// SetConcerns sets the "concerns" field.
func (m *UserMutation) SetConcerns(s string) {
	m.concerns = &s
}

// Concerns returns the value of the "concerns" field in the mutation.
func (m *UserMutation) Concerns() (r string, exists bool) {
	v := m.concerns
	if v == nil {
		return
	}
	return *v, true
}

// OldConcerns returns the old "concerns" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConcerns(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcerns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcerns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcerns: %w", err)
	}
	return oldValue.Concerns, nil
}

// ResetConcerns resets all changes to the "concerns" field.
func (m *UserMutation) ResetConcerns() {
	m.concerns = nil
}

// SetStoreCode sets the "store_code" field.
func (m *UserMutation) SetStoreCode(s string) {
	m.store_code = &s
}

// StoreCode returns the value of the "store_code" field in the mutation.
func (m *UserMutation) StoreCode() (r string, exists bool) {
	v := m.store_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreCode returns the old "store_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStoreCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreCode: %w", err)
	}
	return oldValue.StoreCode, nil
}

// ResetStoreCode resets all changes to the "store_code" field.
func (m *UserMutation) ResetStoreCode() {
	m.store_code = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetSource sets the "source" field.
func (m *UserMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *UserMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *UserMutation) ResetSource() {
	m.source = nil
}

// SetSourceTag sets the "source_tag" field.
func (m *UserMutation) SetSourceTag(s string) {
	m.source_tag = &s
}

// SourceTag returns the value of the "source_tag" field in the mutation.
func (m *UserMutation) SourceTag() (r string, exists bool) {
	v := m.source_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceTag returns the old "source_tag" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSourceTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceTag: %w", err)
	}
	return oldValue.SourceTag, nil
}

// ResetSourceTag resets all changes to the "source_tag" field.
func (m *UserMutation) ResetSourceTag() {
	m.source_tag = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *UserMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *UserMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddAnnouncementIDs adds the "announcements" edge to the Announcements entity by ids.
func (m *UserMutation) AddAnnouncementIDs(ids ...int64) {
	if m.announcements == nil {
		m.announcements = make(map[int64]struct{})
	}
	for i := range ids {
		m.announcements[ids[i]] = struct{}{}
	}
}

// ClearAnnouncements clears the "announcements" edge to the Announcements entity.
func (m *UserMutation) ClearAnnouncements() {
	m.clearedannouncements = true
}

// AnnouncementsCleared reports if the "announcements" edge to the Announcements entity was cleared.
func (m *UserMutation) AnnouncementsCleared() bool {
	return m.clearedannouncements
}

// RemoveAnnouncementIDs removes the "announcements" edge to the Announcements entity by IDs.
func (m *UserMutation) RemoveAnnouncementIDs(ids ...int64) {
	if m.removedannouncements == nil {
		m.removedannouncements = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.announcements, ids[i])
		m.removedannouncements[ids[i]] = struct{}{}
	}
}

// RemovedAnnouncements returns the removed IDs of the "announcements" edge to the Announcements entity.
func (m *UserMutation) RemovedAnnouncementsIDs() (ids []int64) {
	for id := range m.removedannouncements {
		ids = append(ids, id)
	}
	return
}

// AnnouncementsIDs returns the "announcements" edge IDs in the mutation.
func (m *UserMutation) AnnouncementsIDs() (ids []int64) {
	for id := range m.announcements {
		ids = append(ids, id)
	}
	return
}

// ResetAnnouncements resets all changes to the "announcements" edge.
func (m *UserMutation) ResetAnnouncements() {
	m.announcements = nil
	m.clearedannouncements = false
	m.removedannouncements = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.selected_warehouse_id != nil {
		fields = append(fields, user.FieldSelectedWarehouseID)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.code != nil {
		fields = append(fields, user.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.guide_finished != nil {
		fields = append(fields, user.FieldGuideFinished)
	}
	if m.guide_status != nil {
		fields = append(fields, user.FieldGuideStatus)
	}
	if m.hs_object_id != nil {
		fields = append(fields, user.FieldHsObjectID)
	}
	if m.questions != nil {
		fields = append(fields, user.FieldQuestions)
	}
	if m.last_logged_time != nil {
		fields = append(fields, user.FieldLastLoggedTime)
	}
	if m.website != nil {
		fields = append(fields, user.FieldWebsite)
	}
	if m.platform != nil {
		fields = append(fields, user.FieldPlatform)
	}
	if m.concerns != nil {
		fields = append(fields, user.FieldConcerns)
	}
	if m.store_code != nil {
		fields = append(fields, user.FieldStoreCode)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.source != nil {
		fields = append(fields, user.FieldSource)
	}
	if m.source_tag != nil {
		fields = append(fields, user.FieldSourceTag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldType:
		return m.GetType()
	case user.FieldPassword:
		return m.Password()
	case user.FieldSelectedWarehouseID:
		return m.SelectedWarehouseID()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldCode:
		return m.Code()
	case user.FieldStatus:
		return m.Status()
	case user.FieldGuideFinished:
		return m.GuideFinished()
	case user.FieldGuideStatus:
		return m.GuideStatus()
	case user.FieldHsObjectID:
		return m.HsObjectID()
	case user.FieldQuestions:
		return m.Questions()
	case user.FieldLastLoggedTime:
		return m.LastLoggedTime()
	case user.FieldWebsite:
		return m.Website()
	case user.FieldPlatform:
		return m.Platform()
	case user.FieldConcerns:
		return m.Concerns()
	case user.FieldStoreCode:
		return m.StoreCode()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldSource:
		return m.Source()
	case user.FieldSourceTag:
		return m.SourceTag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldSelectedWarehouseID:
		return m.OldSelectedWarehouseID(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldCode:
		return m.OldCode(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldGuideFinished:
		return m.OldGuideFinished(ctx)
	case user.FieldGuideStatus:
		return m.OldGuideStatus(ctx)
	case user.FieldHsObjectID:
		return m.OldHsObjectID(ctx)
	case user.FieldQuestions:
		return m.OldQuestions(ctx)
	case user.FieldLastLoggedTime:
		return m.OldLastLoggedTime(ctx)
	case user.FieldWebsite:
		return m.OldWebsite(ctx)
	case user.FieldPlatform:
		return m.OldPlatform(ctx)
	case user.FieldConcerns:
		return m.OldConcerns(ctx)
	case user.FieldStoreCode:
		return m.OldStoreCode(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldSource:
		return m.OldSource(ctx)
	case user.FieldSourceTag:
		return m.OldSourceTag(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldSelectedWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedWarehouseID(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldGuideFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuideFinished(v)
		return nil
	case user.FieldGuideStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuideStatus(v)
		return nil
	case user.FieldHsObjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHsObjectID(v)
		return nil
	case user.FieldQuestions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestions(v)
		return nil
	case user.FieldLastLoggedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoggedTime(v)
		return nil
	case user.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case user.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case user.FieldConcerns:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcerns(v)
		return nil
	case user.FieldStoreCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreCode(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case user.FieldSourceTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceTag(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addselected_warehouse_id != nil {
		fields = append(fields, user.FieldSelectedWarehouseID)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.addguide_status != nil {
		fields = append(fields, user.FieldGuideStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldSelectedWarehouseID:
		return m.AddedSelectedWarehouseID()
	case user.FieldStatus:
		return m.AddedStatus()
	case user.FieldGuideStatus:
		return m.AddedGuideStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldSelectedWarehouseID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelectedWarehouseID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case user.FieldGuideStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGuideStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldSelectedWarehouseID) {
		fields = append(fields, user.FieldSelectedWarehouseID)
	}
	if m.FieldCleared(user.FieldQuestions) {
		fields = append(fields, user.FieldQuestions)
	}
	if m.FieldCleared(user.FieldLastLoggedTime) {
		fields = append(fields, user.FieldLastLoggedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldSelectedWarehouseID:
		m.ClearSelectedWarehouseID()
		return nil
	case user.FieldQuestions:
		m.ClearQuestions()
		return nil
	case user.FieldLastLoggedTime:
		m.ClearLastLoggedTime()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldSelectedWarehouseID:
		m.ResetSelectedWarehouseID()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldCode:
		m.ResetCode()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldGuideFinished:
		m.ResetGuideFinished()
		return nil
	case user.FieldGuideStatus:
		m.ResetGuideStatus()
		return nil
	case user.FieldHsObjectID:
		m.ResetHsObjectID()
		return nil
	case user.FieldQuestions:
		m.ResetQuestions()
		return nil
	case user.FieldLastLoggedTime:
		m.ResetLastLoggedTime()
		return nil
	case user.FieldWebsite:
		m.ResetWebsite()
		return nil
	case user.FieldPlatform:
		m.ResetPlatform()
		return nil
	case user.FieldConcerns:
		m.ResetConcerns()
		return nil
	case user.FieldStoreCode:
		m.ResetStoreCode()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldSource:
		m.ResetSource()
		return nil
	case user.FieldSourceTag:
		m.ResetSourceTag()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, user.EdgeTenant)
	}
	if m.announcements != nil {
		edges = append(edges, user.EdgeAnnouncements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAnnouncements:
		ids := make([]ent.Value, 0, len(m.announcements))
		for id := range m.announcements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedannouncements != nil {
		edges = append(edges, user.EdgeAnnouncements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAnnouncements:
		ids := make([]ent.Value, 0, len(m.removedannouncements))
		for id := range m.removedannouncements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, user.EdgeTenant)
	}
	if m.clearedannouncements {
		edges = append(edges, user.EdgeAnnouncements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenant:
		return m.clearedtenant
	case user.EdgeAnnouncements:
		return m.clearedannouncements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ResetTenant()
		return nil
	case user.EdgeAnnouncements:
		m.ResetAnnouncements()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserReferralMutation represents an operation that mutates the UserReferral nodes in the graph.
type UserReferralMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	user_id               *int64
	adduser_id            *int64
	first_shipment_date   *time.Time
	total_commission      *float64
	addtotal_commission   *float64
	invited_by_user_id    *int64
	addinvited_by_user_id *int64
	status                *int8
	addstatus             *int8
	clearedFields         map[string]struct{}
	tenant                *int64
	clearedtenant         bool
	done                  bool
	oldValue              func(context.Context) (*UserReferral, error)
	predicates            []predicate.UserReferral
}

var _ ent.Mutation = (*UserReferralMutation)(nil)

// userreferralOption allows management of the mutation configuration using functional options.
type userreferralOption func(*UserReferralMutation)

// newUserReferralMutation creates new mutation for the UserReferral entity.
func newUserReferralMutation(c config, op Op, opts ...userreferralOption) *UserReferralMutation {
	m := &UserReferralMutation{
		config:        c,
		op:            op,
		typ:           TypeUserReferral,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserReferralID sets the ID field of the mutation.
func withUserReferralID(id int64) userreferralOption {
	return func(m *UserReferralMutation) {
		var (
			err   error
			once  sync.Once
			value *UserReferral
		)
		m.oldValue = func(ctx context.Context) (*UserReferral, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserReferral.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserReferral sets the old UserReferral of the mutation.
func withUserReferral(node *UserReferral) userreferralOption {
	return func(m *UserReferralMutation) {
		m.oldValue = func(context.Context) (*UserReferral, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserReferralMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserReferralMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserReferral entities.
func (m *UserReferralMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserReferralMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserReferralMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserReferral.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserReferralMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserReferralMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserReferralMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserReferralMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserReferralMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserReferralMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserReferralMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserReferralMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserReferralMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userreferral.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserReferralMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userreferral.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserReferralMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userreferral.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserReferralMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserReferralMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserReferralMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserReferralMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserReferralMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[userreferral.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserReferralMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userreferral.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserReferralMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, userreferral.FieldUserID)
}

// SetFirstShipmentDate sets the "first_shipment_date" field.
func (m *UserReferralMutation) SetFirstShipmentDate(t time.Time) {
	m.first_shipment_date = &t
}

// FirstShipmentDate returns the value of the "first_shipment_date" field in the mutation.
func (m *UserReferralMutation) FirstShipmentDate() (r time.Time, exists bool) {
	v := m.first_shipment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstShipmentDate returns the old "first_shipment_date" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldFirstShipmentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstShipmentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstShipmentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstShipmentDate: %w", err)
	}
	return oldValue.FirstShipmentDate, nil
}

// ClearFirstShipmentDate clears the value of the "first_shipment_date" field.
func (m *UserReferralMutation) ClearFirstShipmentDate() {
	m.first_shipment_date = nil
	m.clearedFields[userreferral.FieldFirstShipmentDate] = struct{}{}
}

// FirstShipmentDateCleared returns if the "first_shipment_date" field was cleared in this mutation.
func (m *UserReferralMutation) FirstShipmentDateCleared() bool {
	_, ok := m.clearedFields[userreferral.FieldFirstShipmentDate]
	return ok
}

// ResetFirstShipmentDate resets all changes to the "first_shipment_date" field.
func (m *UserReferralMutation) ResetFirstShipmentDate() {
	m.first_shipment_date = nil
	delete(m.clearedFields, userreferral.FieldFirstShipmentDate)
}

// SetTotalCommission sets the "total_commission" field.
func (m *UserReferralMutation) SetTotalCommission(f float64) {
	m.total_commission = &f
	m.addtotal_commission = nil
}

// TotalCommission returns the value of the "total_commission" field in the mutation.
func (m *UserReferralMutation) TotalCommission() (r float64, exists bool) {
	v := m.total_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCommission returns the old "total_commission" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldTotalCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCommission: %w", err)
	}
	return oldValue.TotalCommission, nil
}

// AddTotalCommission adds f to the "total_commission" field.
func (m *UserReferralMutation) AddTotalCommission(f float64) {
	if m.addtotal_commission != nil {
		*m.addtotal_commission += f
	} else {
		m.addtotal_commission = &f
	}
}

// AddedTotalCommission returns the value that was added to the "total_commission" field in this mutation.
func (m *UserReferralMutation) AddedTotalCommission() (r float64, exists bool) {
	v := m.addtotal_commission
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCommission resets all changes to the "total_commission" field.
func (m *UserReferralMutation) ResetTotalCommission() {
	m.total_commission = nil
	m.addtotal_commission = nil
}

// SetInvitedByUserID sets the "invited_by_user_id" field.
func (m *UserReferralMutation) SetInvitedByUserID(i int64) {
	m.invited_by_user_id = &i
	m.addinvited_by_user_id = nil
}

// InvitedByUserID returns the value of the "invited_by_user_id" field in the mutation.
func (m *UserReferralMutation) InvitedByUserID() (r int64, exists bool) {
	v := m.invited_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitedByUserID returns the old "invited_by_user_id" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldInvitedByUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitedByUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitedByUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitedByUserID: %w", err)
	}
	return oldValue.InvitedByUserID, nil
}

// AddInvitedByUserID adds i to the "invited_by_user_id" field.
func (m *UserReferralMutation) AddInvitedByUserID(i int64) {
	if m.addinvited_by_user_id != nil {
		*m.addinvited_by_user_id += i
	} else {
		m.addinvited_by_user_id = &i
	}
}

// AddedInvitedByUserID returns the value that was added to the "invited_by_user_id" field in this mutation.
func (m *UserReferralMutation) AddedInvitedByUserID() (r int64, exists bool) {
	v := m.addinvited_by_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInvitedByUserID clears the value of the "invited_by_user_id" field.
func (m *UserReferralMutation) ClearInvitedByUserID() {
	m.invited_by_user_id = nil
	m.addinvited_by_user_id = nil
	m.clearedFields[userreferral.FieldInvitedByUserID] = struct{}{}
}

// InvitedByUserIDCleared returns if the "invited_by_user_id" field was cleared in this mutation.
func (m *UserReferralMutation) InvitedByUserIDCleared() bool {
	_, ok := m.clearedFields[userreferral.FieldInvitedByUserID]
	return ok
}

// ResetInvitedByUserID resets all changes to the "invited_by_user_id" field.
func (m *UserReferralMutation) ResetInvitedByUserID() {
	m.invited_by_user_id = nil
	m.addinvited_by_user_id = nil
	delete(m.clearedFields, userreferral.FieldInvitedByUserID)
}

// SetStatus sets the "status" field.
func (m *UserReferralMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserReferralMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserReferral entity.
// If the UserReferral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReferralMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserReferralMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserReferralMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserReferralMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTenantID sets the "tenant" edge to the Tenant entity by id.
func (m *UserReferralMutation) SetTenantID(id int64) {
	m.tenant = &id
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserReferralMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserReferralMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantID returns the "tenant" edge ID in the mutation.
func (m *UserReferralMutation) TenantID() (id int64, exists bool) {
	if m.tenant != nil {
		return *m.tenant, true
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserReferralMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserReferralMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the UserReferralMutation builder.
func (m *UserReferralMutation) Where(ps ...predicate.UserReferral) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserReferralMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserReferral).
func (m *UserReferralMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserReferralMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, userreferral.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userreferral.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userreferral.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, userreferral.FieldUserID)
	}
	if m.first_shipment_date != nil {
		fields = append(fields, userreferral.FieldFirstShipmentDate)
	}
	if m.total_commission != nil {
		fields = append(fields, userreferral.FieldTotalCommission)
	}
	if m.invited_by_user_id != nil {
		fields = append(fields, userreferral.FieldInvitedByUserID)
	}
	if m.status != nil {
		fields = append(fields, userreferral.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserReferralMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userreferral.FieldCreatedAt:
		return m.CreatedAt()
	case userreferral.FieldUpdatedAt:
		return m.UpdatedAt()
	case userreferral.FieldDeletedAt:
		return m.DeletedAt()
	case userreferral.FieldUserID:
		return m.UserID()
	case userreferral.FieldFirstShipmentDate:
		return m.FirstShipmentDate()
	case userreferral.FieldTotalCommission:
		return m.TotalCommission()
	case userreferral.FieldInvitedByUserID:
		return m.InvitedByUserID()
	case userreferral.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserReferralMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userreferral.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userreferral.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userreferral.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userreferral.FieldUserID:
		return m.OldUserID(ctx)
	case userreferral.FieldFirstShipmentDate:
		return m.OldFirstShipmentDate(ctx)
	case userreferral.FieldTotalCommission:
		return m.OldTotalCommission(ctx)
	case userreferral.FieldInvitedByUserID:
		return m.OldInvitedByUserID(ctx)
	case userreferral.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserReferral field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserReferralMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userreferral.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userreferral.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userreferral.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userreferral.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userreferral.FieldFirstShipmentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstShipmentDate(v)
		return nil
	case userreferral.FieldTotalCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCommission(v)
		return nil
	case userreferral.FieldInvitedByUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitedByUserID(v)
		return nil
	case userreferral.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserReferral field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserReferralMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userreferral.FieldUserID)
	}
	if m.addtotal_commission != nil {
		fields = append(fields, userreferral.FieldTotalCommission)
	}
	if m.addinvited_by_user_id != nil {
		fields = append(fields, userreferral.FieldInvitedByUserID)
	}
	if m.addstatus != nil {
		fields = append(fields, userreferral.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserReferralMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userreferral.FieldUserID:
		return m.AddedUserID()
	case userreferral.FieldTotalCommission:
		return m.AddedTotalCommission()
	case userreferral.FieldInvitedByUserID:
		return m.AddedInvitedByUserID()
	case userreferral.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserReferralMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userreferral.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userreferral.FieldTotalCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCommission(v)
		return nil
	case userreferral.FieldInvitedByUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvitedByUserID(v)
		return nil
	case userreferral.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserReferral numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserReferralMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userreferral.FieldDeletedAt) {
		fields = append(fields, userreferral.FieldDeletedAt)
	}
	if m.FieldCleared(userreferral.FieldUserID) {
		fields = append(fields, userreferral.FieldUserID)
	}
	if m.FieldCleared(userreferral.FieldFirstShipmentDate) {
		fields = append(fields, userreferral.FieldFirstShipmentDate)
	}
	if m.FieldCleared(userreferral.FieldInvitedByUserID) {
		fields = append(fields, userreferral.FieldInvitedByUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserReferralMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserReferralMutation) ClearField(name string) error {
	switch name {
	case userreferral.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case userreferral.FieldUserID:
		m.ClearUserID()
		return nil
	case userreferral.FieldFirstShipmentDate:
		m.ClearFirstShipmentDate()
		return nil
	case userreferral.FieldInvitedByUserID:
		m.ClearInvitedByUserID()
		return nil
	}
	return fmt.Errorf("unknown UserReferral nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserReferralMutation) ResetField(name string) error {
	switch name {
	case userreferral.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userreferral.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userreferral.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userreferral.FieldUserID:
		m.ResetUserID()
		return nil
	case userreferral.FieldFirstShipmentDate:
		m.ResetFirstShipmentDate()
		return nil
	case userreferral.FieldTotalCommission:
		m.ResetTotalCommission()
		return nil
	case userreferral.FieldInvitedByUserID:
		m.ResetInvitedByUserID()
		return nil
	case userreferral.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserReferral field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserReferralMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, userreferral.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserReferralMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userreferral.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserReferralMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserReferralMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserReferralMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, userreferral.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserReferralMutation) EdgeCleared(name string) bool {
	switch name {
	case userreferral.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserReferralMutation) ClearEdge(name string) error {
	switch name {
	case userreferral.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown UserReferral unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserReferralMutation) ResetEdge(name string) error {
	switch name {
	case userreferral.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown UserReferral edge %s", name)
}

// ValueAddedTaxMutation represents an operation that mutates the ValueAddedTax nodes in the graph.
type ValueAddedTaxMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	country_code         *string
	standard_rate        *float64
	addstandard_rate     *float64
	without_ioss_rate    *float64
	addwithout_ioss_rate *float64
	exemption_in_usd     *float64
	addexemption_in_usd  *float64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ValueAddedTax, error)
	predicates           []predicate.ValueAddedTax
}

var _ ent.Mutation = (*ValueAddedTaxMutation)(nil)

// valueaddedtaxOption allows management of the mutation configuration using functional options.
type valueaddedtaxOption func(*ValueAddedTaxMutation)

// newValueAddedTaxMutation creates new mutation for the ValueAddedTax entity.
func newValueAddedTaxMutation(c config, op Op, opts ...valueaddedtaxOption) *ValueAddedTaxMutation {
	m := &ValueAddedTaxMutation{
		config:        c,
		op:            op,
		typ:           TypeValueAddedTax,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withValueAddedTaxID sets the ID field of the mutation.
func withValueAddedTaxID(id int64) valueaddedtaxOption {
	return func(m *ValueAddedTaxMutation) {
		var (
			err   error
			once  sync.Once
			value *ValueAddedTax
		)
		m.oldValue = func(ctx context.Context) (*ValueAddedTax, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ValueAddedTax.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withValueAddedTax sets the old ValueAddedTax of the mutation.
func withValueAddedTax(node *ValueAddedTax) valueaddedtaxOption {
	return func(m *ValueAddedTaxMutation) {
		m.oldValue = func(context.Context) (*ValueAddedTax, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ValueAddedTaxMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ValueAddedTaxMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ValueAddedTax entities.
func (m *ValueAddedTaxMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ValueAddedTaxMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ValueAddedTaxMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ValueAddedTax.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ValueAddedTaxMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ValueAddedTaxMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ValueAddedTaxMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ValueAddedTaxMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ValueAddedTaxMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ValueAddedTaxMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ValueAddedTaxMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ValueAddedTaxMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ValueAddedTaxMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[valueaddedtax.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ValueAddedTaxMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[valueaddedtax.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ValueAddedTaxMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, valueaddedtax.FieldDeletedAt)
}

// SetCountryCode sets the "country_code" field.
func (m *ValueAddedTaxMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *ValueAddedTaxMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *ValueAddedTaxMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetStandardRate sets the "standard_rate" field.
func (m *ValueAddedTaxMutation) SetStandardRate(f float64) {
	m.standard_rate = &f
	m.addstandard_rate = nil
}

// StandardRate returns the value of the "standard_rate" field in the mutation.
func (m *ValueAddedTaxMutation) StandardRate() (r float64, exists bool) {
	v := m.standard_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldStandardRate returns the old "standard_rate" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldStandardRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStandardRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStandardRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandardRate: %w", err)
	}
	return oldValue.StandardRate, nil
}

// AddStandardRate adds f to the "standard_rate" field.
func (m *ValueAddedTaxMutation) AddStandardRate(f float64) {
	if m.addstandard_rate != nil {
		*m.addstandard_rate += f
	} else {
		m.addstandard_rate = &f
	}
}

// AddedStandardRate returns the value that was added to the "standard_rate" field in this mutation.
func (m *ValueAddedTaxMutation) AddedStandardRate() (r float64, exists bool) {
	v := m.addstandard_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetStandardRate resets all changes to the "standard_rate" field.
func (m *ValueAddedTaxMutation) ResetStandardRate() {
	m.standard_rate = nil
	m.addstandard_rate = nil
}

// SetWithoutIossRate sets the "without_ioss_rate" field.
func (m *ValueAddedTaxMutation) SetWithoutIossRate(f float64) {
	m.without_ioss_rate = &f
	m.addwithout_ioss_rate = nil
}

// WithoutIossRate returns the value of the "without_ioss_rate" field in the mutation.
func (m *ValueAddedTaxMutation) WithoutIossRate() (r float64, exists bool) {
	v := m.without_ioss_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldWithoutIossRate returns the old "without_ioss_rate" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldWithoutIossRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithoutIossRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithoutIossRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithoutIossRate: %w", err)
	}
	return oldValue.WithoutIossRate, nil
}

// AddWithoutIossRate adds f to the "without_ioss_rate" field.
func (m *ValueAddedTaxMutation) AddWithoutIossRate(f float64) {
	if m.addwithout_ioss_rate != nil {
		*m.addwithout_ioss_rate += f
	} else {
		m.addwithout_ioss_rate = &f
	}
}

// AddedWithoutIossRate returns the value that was added to the "without_ioss_rate" field in this mutation.
func (m *ValueAddedTaxMutation) AddedWithoutIossRate() (r float64, exists bool) {
	v := m.addwithout_ioss_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithoutIossRate resets all changes to the "without_ioss_rate" field.
func (m *ValueAddedTaxMutation) ResetWithoutIossRate() {
	m.without_ioss_rate = nil
	m.addwithout_ioss_rate = nil
}

// SetExemptionInUsd sets the "exemption_in_usd" field.
func (m *ValueAddedTaxMutation) SetExemptionInUsd(f float64) {
	m.exemption_in_usd = &f
	m.addexemption_in_usd = nil
}

// ExemptionInUsd returns the value of the "exemption_in_usd" field in the mutation.
func (m *ValueAddedTaxMutation) ExemptionInUsd() (r float64, exists bool) {
	v := m.exemption_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldExemptionInUsd returns the old "exemption_in_usd" field's value of the ValueAddedTax entity.
// If the ValueAddedTax object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ValueAddedTaxMutation) OldExemptionInUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExemptionInUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExemptionInUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExemptionInUsd: %w", err)
	}
	return oldValue.ExemptionInUsd, nil
}

// AddExemptionInUsd adds f to the "exemption_in_usd" field.
func (m *ValueAddedTaxMutation) AddExemptionInUsd(f float64) {
	if m.addexemption_in_usd != nil {
		*m.addexemption_in_usd += f
	} else {
		m.addexemption_in_usd = &f
	}
}

// AddedExemptionInUsd returns the value that was added to the "exemption_in_usd" field in this mutation.
func (m *ValueAddedTaxMutation) AddedExemptionInUsd() (r float64, exists bool) {
	v := m.addexemption_in_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetExemptionInUsd resets all changes to the "exemption_in_usd" field.
func (m *ValueAddedTaxMutation) ResetExemptionInUsd() {
	m.exemption_in_usd = nil
	m.addexemption_in_usd = nil
}

// Where appends a list predicates to the ValueAddedTaxMutation builder.
func (m *ValueAddedTaxMutation) Where(ps ...predicate.ValueAddedTax) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ValueAddedTaxMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ValueAddedTax).
func (m *ValueAddedTaxMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ValueAddedTaxMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, valueaddedtax.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, valueaddedtax.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, valueaddedtax.FieldDeletedAt)
	}
	if m.country_code != nil {
		fields = append(fields, valueaddedtax.FieldCountryCode)
	}
	if m.standard_rate != nil {
		fields = append(fields, valueaddedtax.FieldStandardRate)
	}
	if m.without_ioss_rate != nil {
		fields = append(fields, valueaddedtax.FieldWithoutIossRate)
	}
	if m.exemption_in_usd != nil {
		fields = append(fields, valueaddedtax.FieldExemptionInUsd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ValueAddedTaxMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case valueaddedtax.FieldCreatedAt:
		return m.CreatedAt()
	case valueaddedtax.FieldUpdatedAt:
		return m.UpdatedAt()
	case valueaddedtax.FieldDeletedAt:
		return m.DeletedAt()
	case valueaddedtax.FieldCountryCode:
		return m.CountryCode()
	case valueaddedtax.FieldStandardRate:
		return m.StandardRate()
	case valueaddedtax.FieldWithoutIossRate:
		return m.WithoutIossRate()
	case valueaddedtax.FieldExemptionInUsd:
		return m.ExemptionInUsd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ValueAddedTaxMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case valueaddedtax.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case valueaddedtax.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case valueaddedtax.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case valueaddedtax.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case valueaddedtax.FieldStandardRate:
		return m.OldStandardRate(ctx)
	case valueaddedtax.FieldWithoutIossRate:
		return m.OldWithoutIossRate(ctx)
	case valueaddedtax.FieldExemptionInUsd:
		return m.OldExemptionInUsd(ctx)
	}
	return nil, fmt.Errorf("unknown ValueAddedTax field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValueAddedTaxMutation) SetField(name string, value ent.Value) error {
	switch name {
	case valueaddedtax.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case valueaddedtax.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case valueaddedtax.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case valueaddedtax.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case valueaddedtax.FieldStandardRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandardRate(v)
		return nil
	case valueaddedtax.FieldWithoutIossRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithoutIossRate(v)
		return nil
	case valueaddedtax.FieldExemptionInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExemptionInUsd(v)
		return nil
	}
	return fmt.Errorf("unknown ValueAddedTax field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ValueAddedTaxMutation) AddedFields() []string {
	var fields []string
	if m.addstandard_rate != nil {
		fields = append(fields, valueaddedtax.FieldStandardRate)
	}
	if m.addwithout_ioss_rate != nil {
		fields = append(fields, valueaddedtax.FieldWithoutIossRate)
	}
	if m.addexemption_in_usd != nil {
		fields = append(fields, valueaddedtax.FieldExemptionInUsd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ValueAddedTaxMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case valueaddedtax.FieldStandardRate:
		return m.AddedStandardRate()
	case valueaddedtax.FieldWithoutIossRate:
		return m.AddedWithoutIossRate()
	case valueaddedtax.FieldExemptionInUsd:
		return m.AddedExemptionInUsd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ValueAddedTaxMutation) AddField(name string, value ent.Value) error {
	switch name {
	case valueaddedtax.FieldStandardRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStandardRate(v)
		return nil
	case valueaddedtax.FieldWithoutIossRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithoutIossRate(v)
		return nil
	case valueaddedtax.FieldExemptionInUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExemptionInUsd(v)
		return nil
	}
	return fmt.Errorf("unknown ValueAddedTax numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ValueAddedTaxMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(valueaddedtax.FieldDeletedAt) {
		fields = append(fields, valueaddedtax.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ValueAddedTaxMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ValueAddedTaxMutation) ClearField(name string) error {
	switch name {
	case valueaddedtax.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ValueAddedTax nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ValueAddedTaxMutation) ResetField(name string) error {
	switch name {
	case valueaddedtax.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case valueaddedtax.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case valueaddedtax.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case valueaddedtax.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case valueaddedtax.FieldStandardRate:
		m.ResetStandardRate()
		return nil
	case valueaddedtax.FieldWithoutIossRate:
		m.ResetWithoutIossRate()
		return nil
	case valueaddedtax.FieldExemptionInUsd:
		m.ResetExemptionInUsd()
		return nil
	}
	return fmt.Errorf("unknown ValueAddedTax field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ValueAddedTaxMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ValueAddedTaxMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ValueAddedTaxMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ValueAddedTaxMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ValueAddedTaxMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ValueAddedTaxMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ValueAddedTaxMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ValueAddedTax unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ValueAddedTaxMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ValueAddedTax edge %s", name)
}

// WarehouseMutation represents an operation that mutates the Warehouse nodes in the graph.
type WarehouseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	code                *string
	quicktron_code      *string
	enable_quicktron    *int
	addenable_quicktron *int
	name                *string
	company             *string
	first_name          *string
	last_name           *string
	address1            *string
	address2            *string
	country_code        *string
	country_name        *string
	province            *string
	city                *string
	zip_code            *string
	phone               *string
	status              *int
	addstatus           *int
	clearedFields       map[string]struct{}
	orders              map[int64]struct{}
	removedorders       map[int64]struct{}
	clearedorders       bool
	done                bool
	oldValue            func(context.Context) (*Warehouse, error)
	predicates          []predicate.Warehouse
}

var _ ent.Mutation = (*WarehouseMutation)(nil)

// warehouseOption allows management of the mutation configuration using functional options.
type warehouseOption func(*WarehouseMutation)

// newWarehouseMutation creates new mutation for the Warehouse entity.
func newWarehouseMutation(c config, op Op, opts ...warehouseOption) *WarehouseMutation {
	m := &WarehouseMutation{
		config:        c,
		op:            op,
		typ:           TypeWarehouse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarehouseID sets the ID field of the mutation.
func withWarehouseID(id int64) warehouseOption {
	return func(m *WarehouseMutation) {
		var (
			err   error
			once  sync.Once
			value *Warehouse
		)
		m.oldValue = func(ctx context.Context) (*Warehouse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Warehouse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarehouse sets the old Warehouse of the mutation.
func withWarehouse(node *Warehouse) warehouseOption {
	return func(m *WarehouseMutation) {
		m.oldValue = func(context.Context) (*Warehouse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarehouseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarehouseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("gen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Warehouse entities.
func (m *WarehouseMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WarehouseMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WarehouseMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Warehouse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WarehouseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WarehouseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WarehouseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WarehouseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WarehouseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WarehouseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WarehouseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WarehouseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WarehouseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[warehouse.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WarehouseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[warehouse.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WarehouseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, warehouse.FieldDeletedAt)
}

// SetCode sets the "code" field.
func (m *WarehouseMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *WarehouseMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *WarehouseMutation) ResetCode() {
	m.code = nil
}

// SetQuicktronCode sets the "quicktron_code" field.
func (m *WarehouseMutation) SetQuicktronCode(s string) {
	m.quicktron_code = &s
}

// QuicktronCode returns the value of the "quicktron_code" field in the mutation.
func (m *WarehouseMutation) QuicktronCode() (r string, exists bool) {
	v := m.quicktron_code
	if v == nil {
		return
	}
	return *v, true
}

// OldQuicktronCode returns the old "quicktron_code" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldQuicktronCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuicktronCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuicktronCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuicktronCode: %w", err)
	}
	return oldValue.QuicktronCode, nil
}

// ResetQuicktronCode resets all changes to the "quicktron_code" field.
func (m *WarehouseMutation) ResetQuicktronCode() {
	m.quicktron_code = nil
}

// SetEnableQuicktron sets the "enable_quicktron" field.
func (m *WarehouseMutation) SetEnableQuicktron(i int) {
	m.enable_quicktron = &i
	m.addenable_quicktron = nil
}

// EnableQuicktron returns the value of the "enable_quicktron" field in the mutation.
func (m *WarehouseMutation) EnableQuicktron() (r int, exists bool) {
	v := m.enable_quicktron
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableQuicktron returns the old "enable_quicktron" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldEnableQuicktron(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableQuicktron is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableQuicktron requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableQuicktron: %w", err)
	}
	return oldValue.EnableQuicktron, nil
}

// AddEnableQuicktron adds i to the "enable_quicktron" field.
func (m *WarehouseMutation) AddEnableQuicktron(i int) {
	if m.addenable_quicktron != nil {
		*m.addenable_quicktron += i
	} else {
		m.addenable_quicktron = &i
	}
}

// AddedEnableQuicktron returns the value that was added to the "enable_quicktron" field in this mutation.
func (m *WarehouseMutation) AddedEnableQuicktron() (r int, exists bool) {
	v := m.addenable_quicktron
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnableQuicktron resets all changes to the "enable_quicktron" field.
func (m *WarehouseMutation) ResetEnableQuicktron() {
	m.enable_quicktron = nil
	m.addenable_quicktron = nil
}

// SetName sets the "name" field.
func (m *WarehouseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WarehouseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WarehouseMutation) ResetName() {
	m.name = nil
}

// SetCompany sets the "company" field.
func (m *WarehouseMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *WarehouseMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *WarehouseMutation) ResetCompany() {
	m.company = nil
}

// SetFirstName sets the "first_name" field.
func (m *WarehouseMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *WarehouseMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *WarehouseMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *WarehouseMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *WarehouseMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *WarehouseMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddress1 sets the "address1" field.
func (m *WarehouseMutation) SetAddress1(s string) {
	m.address1 = &s
}

// Address1 returns the value of the "address1" field in the mutation.
func (m *WarehouseMutation) Address1() (r string, exists bool) {
	v := m.address1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress1 returns the old "address1" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldAddress1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress1: %w", err)
	}
	return oldValue.Address1, nil
}

// ResetAddress1 resets all changes to the "address1" field.
func (m *WarehouseMutation) ResetAddress1() {
	m.address1 = nil
}

// SetAddress2 sets the "address2" field.
func (m *WarehouseMutation) SetAddress2(s string) {
	m.address2 = &s
}

// Address2 returns the value of the "address2" field in the mutation.
func (m *WarehouseMutation) Address2() (r string, exists bool) {
	v := m.address2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress2 returns the old "address2" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldAddress2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress2: %w", err)
	}
	return oldValue.Address2, nil
}

// ResetAddress2 resets all changes to the "address2" field.
func (m *WarehouseMutation) ResetAddress2() {
	m.address2 = nil
}

// SetCountryCode sets the "country_code" field.
func (m *WarehouseMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *WarehouseMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *WarehouseMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetCountryName sets the "country_name" field.
func (m *WarehouseMutation) SetCountryName(s string) {
	m.country_name = &s
}

// CountryName returns the value of the "country_name" field in the mutation.
func (m *WarehouseMutation) CountryName() (r string, exists bool) {
	v := m.country_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryName returns the old "country_name" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldCountryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryName: %w", err)
	}
	return oldValue.CountryName, nil
}

// ResetCountryName resets all changes to the "country_name" field.
func (m *WarehouseMutation) ResetCountryName() {
	m.country_name = nil
}

// SetProvince sets the "province" field.
func (m *WarehouseMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *WarehouseMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *WarehouseMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *WarehouseMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *WarehouseMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *WarehouseMutation) ResetCity() {
	m.city = nil
}

// SetZipCode sets the "zip_code" field.
func (m *WarehouseMutation) SetZipCode(s string) {
	m.zip_code = &s
}

// ZipCode returns the value of the "zip_code" field in the mutation.
func (m *WarehouseMutation) ZipCode() (r string, exists bool) {
	v := m.zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "zip_code" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ResetZipCode resets all changes to the "zip_code" field.
func (m *WarehouseMutation) ResetZipCode() {
	m.zip_code = nil
}

// SetPhone sets the "phone" field.
func (m *WarehouseMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *WarehouseMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *WarehouseMutation) ResetPhone() {
	m.phone = nil
}

// SetStatus sets the "status" field.
func (m *WarehouseMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *WarehouseMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Warehouse entity.
// If the Warehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WarehouseMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *WarehouseMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *WarehouseMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *WarehouseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *WarehouseMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *WarehouseMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *WarehouseMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *WarehouseMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *WarehouseMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *WarehouseMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *WarehouseMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the WarehouseMutation builder.
func (m *WarehouseMutation) Where(ps ...predicate.Warehouse) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WarehouseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Warehouse).
func (m *WarehouseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WarehouseMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, warehouse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, warehouse.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, warehouse.FieldDeletedAt)
	}
	if m.code != nil {
		fields = append(fields, warehouse.FieldCode)
	}
	if m.quicktron_code != nil {
		fields = append(fields, warehouse.FieldQuicktronCode)
	}
	if m.enable_quicktron != nil {
		fields = append(fields, warehouse.FieldEnableQuicktron)
	}
	if m.name != nil {
		fields = append(fields, warehouse.FieldName)
	}
	if m.company != nil {
		fields = append(fields, warehouse.FieldCompany)
	}
	if m.first_name != nil {
		fields = append(fields, warehouse.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, warehouse.FieldLastName)
	}
	if m.address1 != nil {
		fields = append(fields, warehouse.FieldAddress1)
	}
	if m.address2 != nil {
		fields = append(fields, warehouse.FieldAddress2)
	}
	if m.country_code != nil {
		fields = append(fields, warehouse.FieldCountryCode)
	}
	if m.country_name != nil {
		fields = append(fields, warehouse.FieldCountryName)
	}
	if m.province != nil {
		fields = append(fields, warehouse.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, warehouse.FieldCity)
	}
	if m.zip_code != nil {
		fields = append(fields, warehouse.FieldZipCode)
	}
	if m.phone != nil {
		fields = append(fields, warehouse.FieldPhone)
	}
	if m.status != nil {
		fields = append(fields, warehouse.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WarehouseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warehouse.FieldCreatedAt:
		return m.CreatedAt()
	case warehouse.FieldUpdatedAt:
		return m.UpdatedAt()
	case warehouse.FieldDeletedAt:
		return m.DeletedAt()
	case warehouse.FieldCode:
		return m.Code()
	case warehouse.FieldQuicktronCode:
		return m.QuicktronCode()
	case warehouse.FieldEnableQuicktron:
		return m.EnableQuicktron()
	case warehouse.FieldName:
		return m.Name()
	case warehouse.FieldCompany:
		return m.Company()
	case warehouse.FieldFirstName:
		return m.FirstName()
	case warehouse.FieldLastName:
		return m.LastName()
	case warehouse.FieldAddress1:
		return m.Address1()
	case warehouse.FieldAddress2:
		return m.Address2()
	case warehouse.FieldCountryCode:
		return m.CountryCode()
	case warehouse.FieldCountryName:
		return m.CountryName()
	case warehouse.FieldProvince:
		return m.Province()
	case warehouse.FieldCity:
		return m.City()
	case warehouse.FieldZipCode:
		return m.ZipCode()
	case warehouse.FieldPhone:
		return m.Phone()
	case warehouse.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WarehouseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warehouse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warehouse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warehouse.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case warehouse.FieldCode:
		return m.OldCode(ctx)
	case warehouse.FieldQuicktronCode:
		return m.OldQuicktronCode(ctx)
	case warehouse.FieldEnableQuicktron:
		return m.OldEnableQuicktron(ctx)
	case warehouse.FieldName:
		return m.OldName(ctx)
	case warehouse.FieldCompany:
		return m.OldCompany(ctx)
	case warehouse.FieldFirstName:
		return m.OldFirstName(ctx)
	case warehouse.FieldLastName:
		return m.OldLastName(ctx)
	case warehouse.FieldAddress1:
		return m.OldAddress1(ctx)
	case warehouse.FieldAddress2:
		return m.OldAddress2(ctx)
	case warehouse.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case warehouse.FieldCountryName:
		return m.OldCountryName(ctx)
	case warehouse.FieldProvince:
		return m.OldProvince(ctx)
	case warehouse.FieldCity:
		return m.OldCity(ctx)
	case warehouse.FieldZipCode:
		return m.OldZipCode(ctx)
	case warehouse.FieldPhone:
		return m.OldPhone(ctx)
	case warehouse.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Warehouse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warehouse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warehouse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warehouse.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case warehouse.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case warehouse.FieldQuicktronCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuicktronCode(v)
		return nil
	case warehouse.FieldEnableQuicktron:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableQuicktron(v)
		return nil
	case warehouse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case warehouse.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case warehouse.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case warehouse.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case warehouse.FieldAddress1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress1(v)
		return nil
	case warehouse.FieldAddress2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress2(v)
		return nil
	case warehouse.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case warehouse.FieldCountryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryName(v)
		return nil
	case warehouse.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case warehouse.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case warehouse.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case warehouse.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case warehouse.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Warehouse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WarehouseMutation) AddedFields() []string {
	var fields []string
	if m.addenable_quicktron != nil {
		fields = append(fields, warehouse.FieldEnableQuicktron)
	}
	if m.addstatus != nil {
		fields = append(fields, warehouse.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WarehouseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case warehouse.FieldEnableQuicktron:
		return m.AddedEnableQuicktron()
	case warehouse.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WarehouseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case warehouse.FieldEnableQuicktron:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnableQuicktron(v)
		return nil
	case warehouse.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Warehouse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WarehouseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(warehouse.FieldDeletedAt) {
		fields = append(fields, warehouse.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WarehouseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarehouseMutation) ClearField(name string) error {
	switch name {
	case warehouse.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Warehouse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WarehouseMutation) ResetField(name string) error {
	switch name {
	case warehouse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warehouse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warehouse.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case warehouse.FieldCode:
		m.ResetCode()
		return nil
	case warehouse.FieldQuicktronCode:
		m.ResetQuicktronCode()
		return nil
	case warehouse.FieldEnableQuicktron:
		m.ResetEnableQuicktron()
		return nil
	case warehouse.FieldName:
		m.ResetName()
		return nil
	case warehouse.FieldCompany:
		m.ResetCompany()
		return nil
	case warehouse.FieldFirstName:
		m.ResetFirstName()
		return nil
	case warehouse.FieldLastName:
		m.ResetLastName()
		return nil
	case warehouse.FieldAddress1:
		m.ResetAddress1()
		return nil
	case warehouse.FieldAddress2:
		m.ResetAddress2()
		return nil
	case warehouse.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case warehouse.FieldCountryName:
		m.ResetCountryName()
		return nil
	case warehouse.FieldProvince:
		m.ResetProvince()
		return nil
	case warehouse.FieldCity:
		m.ResetCity()
		return nil
	case warehouse.FieldZipCode:
		m.ResetZipCode()
		return nil
	case warehouse.FieldPhone:
		m.ResetPhone()
		return nil
	case warehouse.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Warehouse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WarehouseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, warehouse.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WarehouseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case warehouse.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WarehouseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorders != nil {
		edges = append(edges, warehouse.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WarehouseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case warehouse.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WarehouseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorders {
		edges = append(edges, warehouse.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WarehouseMutation) EdgeCleared(name string) bool {
	switch name {
	case warehouse.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WarehouseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Warehouse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WarehouseMutation) ResetEdge(name string) error {
	switch name {
	case warehouse.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Warehouse edge %s", name)
}
